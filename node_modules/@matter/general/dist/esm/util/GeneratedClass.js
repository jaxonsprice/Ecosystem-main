/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
function GeneratedClass(options) {
  const { base, name, beforeSuper, mixins: extraMixins } = options;
  const mixins = extraMixins ? [...extraMixins, options] : [options];
  const klass = createConstructor({
    name: name ?? (base ? `${base.name}$` : "GeneratedClass"),
    base,
    beforeSuper,
    mixins
  });
  configureClass(klass, base, mixins);
  return klass;
}
function createConstructor({ name, base, beforeSuper, mixins }) {
  let construct;
  if (base) {
    construct = function(self, args) {
      return reflectConstruct(base, args, self.constructor);
    };
  } else {
    construct = function(self) {
      return self;
    };
  }
  if (mixins) {
    for (const { initialize, instanceProperties } of mixins) {
      const before = construct;
      if (initialize) {
        if (instanceProperties) {
          construct = function(self, args) {
            self = before(self, args);
            for (const k in instanceProperties) {
              self[k] = instanceProperties[k];
            }
            initialize.apply(self, args);
            return self;
          };
        } else {
          construct = function(self, args) {
            self = before(self, args);
            initialize.apply(self, args);
            return self;
          };
        }
      } else if (instanceProperties) {
        construct = function(self, args) {
          self = before(self, args);
          for (const k in instanceProperties) {
            self[k] = instanceProperties[k];
          }
          return self;
        };
      }
    }
  }
  let klass;
  if (beforeSuper) {
    ({ [name]: klass } = {
      [name]: function(...args) {
        if (!(this instanceof klass)) {
          throw new TypeError(`Class constructor ${klass.name} cannot be invoked without 'new'`);
        }
        args = beforeSuper(...args);
        return construct(this, args);
      }
    });
  } else {
    ({ [name]: klass } = {
      [name]: function(...args) {
        if (!(this instanceof klass)) {
          throw new TypeError(`Class constructor ${klass.name} cannot be invoked without 'new'`);
        }
        return construct(this, args);
      }
    });
  }
  return klass;
}
function configureClass(klass, base, mixins) {
  if (base) {
    Object.setPrototypeOf(klass, base);
    klass.prototype = Reflect.construct(base, []);
  }
  Object.defineProperty(klass.prototype, "constructor", { value: klass });
  if (mixins) {
    for (const { staticProperties, staticDescriptors, instanceDescriptors } of mixins) {
      if (staticProperties) {
        Object.assign(klass, staticProperties);
      }
      if (staticDescriptors) {
        Object.defineProperties(klass, staticDescriptors);
      }
      if (instanceDescriptors) {
        Object.defineProperties(klass.prototype, instanceDescriptors);
      }
    }
  }
}
let reflectConstruct;
if (typeof globalThis.Reflect?.construct === "function") {
  reflectConstruct = Reflect.construct;
} else {
  reflectConstruct = (target, args, newTarget) => {
    if (typeof newTarget === "undefined") {
      newTarget = target;
    }
    const initialThis = Object.create(newTarget.prototype);
    const constructorResult = target.apply(initialThis, args);
    if (typeof constructorResult === "object" && constructorResult !== null || typeof constructorResult === "function") {
      return constructorResult;
    }
    return initialThis;
  };
}
export {
  GeneratedClass
};
//# sourceMappingURL=GeneratedClass.js.map
