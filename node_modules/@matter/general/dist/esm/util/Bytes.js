/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { UnexpectedDataError } from "../MatterError.js";
var Endian = /* @__PURE__ */ ((Endian2) => {
  Endian2[Endian2["Little"] = 0] = "Little";
  Endian2[Endian2["Big"] = 1] = "Big";
  return Endian2;
})(Endian || {});
function b$(strings, ...values) {
  if (strings.length === 1 && values.length === 0) {
    return Bytes.fromHex(strings[0]);
  }
  const parts = Array();
  for (let i = 0; i < strings.length; i++) {
    parts.push(strings[i]);
    if (i < values.length) {
      parts.push(`${values[i]}`);
    }
  }
  return Bytes.fromHex(parts.join(""));
}
var Bytes;
((Bytes2) => {
  function toHex(array) {
    const hexArray = new Array();
    hexArray.length = array.length;
    array.forEach((byte) => hexArray.push(byte.toString(16).padStart(2, "0")));
    return hexArray.join("");
  }
  Bytes2.toHex = toHex;
  function toBase64(array) {
    let result = "";
    array.forEach((byte) => result += String.fromCharCode(byte));
    return btoa(result);
  }
  Bytes2.toBase64 = toBase64;
  function dataViewOf(array) {
    return new DataView(array.buffer, array.byteOffset, array.byteLength);
  }
  Bytes2.dataViewOf = dataViewOf;
  function areEqual(array1, array2) {
    if (array1.length !== array2.length) return false;
    return array1.every((value, index) => array2[index] === value);
  }
  Bytes2.areEqual = areEqual;
  function fromHex(hexString) {
    if (hexString.length === 0) return new Uint8Array(0);
    if (hexString.length % 2 !== 0) throw new UnexpectedDataError("Hex string should have an even length.");
    const bytes = hexString.match(/.{1,2}/g)?.map((byteHex) => parseInt(byteHex, 16));
    if (bytes === void 0) throw new UnexpectedDataError("Failed to parse the hex string.");
    return Uint8Array.from(bytes);
  }
  Bytes2.fromHex = fromHex;
  function fromBase64(base64String) {
    const raw = atob(base64String);
    let result = "";
    for (let i = 0; i < raw.length; i++) {
      const hex = raw.charCodeAt(i).toString(16);
      result += hex.length === 2 ? hex : "0" + hex;
    }
    return fromHex(result);
  }
  Bytes2.fromBase64 = fromBase64;
  function fromString(string) {
    return new TextEncoder().encode(string);
  }
  Bytes2.fromString = fromString;
  function concat(...arrays) {
    let length = 0;
    arrays.forEach((array) => length += array.length);
    const result = new Uint8Array(length);
    let offset = 0;
    arrays.forEach((array) => {
      result.set(array, offset);
      offset += array.length;
    });
    return result;
  }
  Bytes2.concat = concat;
  function asBigInt(bytes) {
    const view = new DataView(bytes.buffer);
    let result = 0n;
    for (let i = 0; i < bytes.length; ) {
      const remaining = bytes.length - i;
      if (remaining >= 8) {
        result = (result << 64n) + view.getBigUint64(i);
        i += 8;
      } else if (remaining >= 4) {
        result = (result << 32n) + BigInt(view.getUint32(i));
        i += 4;
      } else if (remaining >= 2) {
        result = (result << 16n) + BigInt(view.getUint16(i));
        i += 2;
      } else {
        result = (result << 8n) + BigInt(view.getUint8(i));
        i++;
      }
    }
    return result;
  }
  Bytes2.asBigInt = asBigInt;
})(Bytes || (Bytes = {}));
export {
  Bytes,
  Endian,
  b$
};
//# sourceMappingURL=Bytes.js.map
