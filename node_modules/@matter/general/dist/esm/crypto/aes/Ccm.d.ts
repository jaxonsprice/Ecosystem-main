/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
/**
 * WARNING: Unaudited.  Consider platform replacement if available.
 *
 * This AES-CCM implementation is tailored for Matter:
 *
 * * Only supports 2-byte length
 *
 * * Only supports 13-byte nonce
 *
 * * Stores the MIC in the ciphertext buffer following the ciphertext
 *
 * * Our AES implementation supports multiple key sizes but only 16 bytes are legal
 *
 * We take a few approaches to improve performance:
 *
 * * Uses singletons for temporary working buffers to avoid GC
 *
 * * Uses Uint8Array, Int32Array and DataView depending on which is most efficient while addressing platform byte order
 *
 * * Performs data conversion one block at a time rather than converting entire input/output buffer
 *
 * * Functions are monomorphic and should JIT well
 *
 * Implementation notes:
 *
 * * Data operations operate on 128-bit blocks, either as bytes or as 4 32-bit words in platform byte order.  We share
 *   underlying memory for both formats, but on little-endian platforms they are not directly interchangeable without a
 *   round-trip through a DataView
 *
 * * We encode words as a signed Int32Array because JS bit operations operate on signed 32-bit integers and a
 *   Uint32Array would require manually casting from signed to unsigned
 *
 * * Use of singleton buffers require this code to be synchronous.  If that were to change we would need to convert to a
 *   buffer pool
 *
 * * Some functions only modify singleton buffers and thus do not directly return a value
 *
 * * We use {@link DataView} to read/write words where possible.  However, byte buffers may not align to word
 *   boundaries.  We detect this case and manually read/write the last word
 */
export declare function Ccm(key: Uint8Array): {
    encrypt(input: Ccm.EncryptInput): Uint8Array;
    decrypt(input: Ccm.DecryptInput): Uint8Array;
};
export declare namespace Ccm {
    interface Input {
        nonce: Uint8Array;
        adata: Uint8Array | undefined;
    }
    interface EncryptInput extends Input {
        /**
         * Plaintext
         */
        pt: Uint8Array;
    }
    interface DecryptInput extends Input {
        /**
         * Ciphertext + tag
         */
        ct: Uint8Array;
    }
}
export declare const BYTES_IN_LENGTH = 2;
export declare const MAX_CIPHERTEXT_LENGTH: number;
export declare const MAX_PLAINTEXT_LENGTH: number;
//# sourceMappingURL=Ccm.d.ts.map