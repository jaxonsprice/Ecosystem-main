/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { WordArray } from "./WordArray.js";
function Aes(key) {
  const { encryptKey, decryptKey } = expandKey(key);
  return {
    encrypt(pt, ct = pt) {
      return crypt(pt, ct, encryptKey, Tables.enc);
    },
    decrypt(ct, pt = ct) {
      return crypt(ct, pt, decryptKey, Tables.dec);
    }
  };
}
let etabs, dtabs;
const Tables = {
  get enc() {
    if (!etabs) {
      generateTables();
    }
    return etabs;
  },
  get dec() {
    if (!dtabs) {
      generateTables();
    }
    return dtabs;
  }
};
const mixNames = ["mix1", "mix2", "mix3", "mix4"];
function generateTables() {
  etabs = Tables2();
  dtabs = Tables2();
  const d = Table(), th = Table();
  let i, x, xInv, x2, x4, x8, s, tEnc, tDec;
  for (i = 0; i < 256; i++) {
    th[(d[i] = i << 1 ^ (i >> 7) * 283) ^ i] = i;
  }
  for (x = xInv = 0; !etabs.sbox[x]; x ^= x2 || 1, xInv = th[xInv] || 1) {
    s = xInv ^ xInv << 1 ^ xInv << 2 ^ xInv << 3 ^ xInv << 4;
    s = s >> 8 ^ s & 255 ^ 99;
    etabs.sbox[x] = s;
    dtabs.sbox[s] = x;
    x8 = d[x4 = d[x2 = d[x]]];
    tDec = x8 * 16843009 ^ x4 * 65537 ^ x2 * 257 ^ x * 16843008;
    tEnc = d[s] * 257 ^ s * 16843008;
    for (const name of mixNames) {
      etabs[name][x] = tEnc = tEnc << 24 ^ tEnc >>> 8;
      dtabs[name][s] = tDec = tDec << 24 ^ tDec >>> 8;
    }
  }
  function Tables2() {
    return Object.fromEntries([...mixNames, "sbox"].map((k) => [k, Table()]));
  }
  function Table() {
    return WordArray(256);
  }
}
function crypt(input, output, roundKeys, tabs) {
  const decrypt = tabs === dtabs, numRounds = roundKeys.length / 4 - 2;
  const { mix1, mix2, mix3, mix4, sbox } = tabs;
  let a = input[0] ^ roundKeys[0], b = input[decrypt ? 3 : 1] ^ roundKeys[1], c = input[2] ^ roundKeys[2], d = input[decrypt ? 1 : 3] ^ roundKeys[3], roundKeyAt = 4;
  for (let i = 0; i < numRounds; i++) {
    const atemp = mix1[a >>> 24] ^ mix2[b >> 16 & 255] ^ mix3[c >> 8 & 255] ^ mix4[d & 255] ^ roundKeys[roundKeyAt++];
    const btemp = mix1[b >>> 24] ^ mix2[c >> 16 & 255] ^ mix3[d >> 8 & 255] ^ mix4[a & 255] ^ roundKeys[roundKeyAt++];
    const ctemp = mix1[c >>> 24] ^ mix2[d >> 16 & 255] ^ mix3[a >> 8 & 255] ^ mix4[b & 255] ^ roundKeys[roundKeyAt++];
    d = mix1[d >>> 24] ^ mix2[a >> 16 & 255] ^ mix3[b >> 8 & 255] ^ mix4[c & 255] ^ roundKeys[roundKeyAt++];
    a = atemp;
    b = btemp;
    c = ctemp;
  }
  for (let i = 0; i < 4; i++) {
    output[decrypt ? 3 & -i : i] = sbox[a >>> 24] << 24 ^ sbox[b >> 16 & 255] << 16 ^ sbox[c >> 8 & 255] << 8 ^ sbox[d & 255] ^ roundKeys[roundKeyAt++];
    const atemp = a;
    a = b;
    b = c;
    c = d;
    d = atemp;
  }
  return output;
}
function expandKey(key) {
  const inputLength = key.length / 4, roundsNeeded = inputLength + 7, wordsNeeded = roundsNeeded * 4, encryptKey = WordArray.fromByteArray(key, wordsNeeded), sbox = Tables.enc.sbox;
  for (let i = inputLength, rcon = 1; i < wordsNeeded; i++) {
    let temp = encryptKey[i - 1];
    if (i % inputLength === 0 || inputLength === 8 && i % inputLength === 4) {
      temp = sbox[temp >>> 24] << 24 ^ sbox[temp >> 16 & 255] << 16 ^ sbox[temp >> 8 & 255] << 8 ^ sbox[temp & 255];
      if (i % inputLength === 0) {
        temp = temp << 8 ^ temp >>> 24 ^ rcon << 24;
        rcon = rcon << 1 ^ (rcon >> 7) * 283;
      }
    }
    encryptKey[i] = encryptKey[i - inputLength] ^ temp;
  }
  const { mix1, mix2, mix3, mix4 } = Tables.dec, decryptKey = WordArray(encryptKey.length);
  for (let i = encryptKey.length, j = 0; i; j++, i--) {
    const tmp = encryptKey[j & 3 ? i : i - 4];
    if (i <= 4 || j < 4) {
      decryptKey[j] = tmp;
    } else {
      decryptKey[j] = mix1[sbox[tmp >>> 24]] ^ mix2[sbox[tmp >> 16 & 255]] ^ mix3[sbox[tmp >> 8 & 255]] ^ mix4[sbox[tmp & 255]];
    }
  }
  return { encryptKey, decryptKey };
}
export {
  Aes
};
//# sourceMappingURL=Aes.js.map
