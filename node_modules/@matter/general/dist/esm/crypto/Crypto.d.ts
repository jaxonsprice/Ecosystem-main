/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { MaybePromise } from "#util/Promises.js";
import * as mod from "@noble/curves/abstract/modular";
import * as utils from "@noble/curves/abstract/utils";
import { PrivateKey, PublicKey } from "./Key.js";
export declare const ec: {
    mod(a: bigint, b: bigint): bigint;
    pow(num: bigint, power: bigint, modulo: bigint): bigint;
    pow2(x: bigint, power: bigint, modulo: bigint): bigint;
    invert(number: bigint, modulo: bigint): bigint;
    tonelliShanks(P: bigint): <T>(Fp: mod.IField<T>, n: T) => T;
    FpSqrt(P: bigint): <T>(Fp: mod.IField<T>, n: T) => T;
    validateField<T>(field: mod.IField<T>): mod.IField<T>;
    FpPow<T>(Fp: mod.IField<T>, num: T, power: bigint): T;
    FpInvertBatch<T>(Fp: mod.IField<T>, nums: T[], passZero?: boolean): T[];
    FpDiv<T>(Fp: mod.IField<T>, lhs: T, rhs: T | bigint): T;
    FpLegendre<T>(Fp: mod.IField<T>, n: T): -1 | 0 | 1;
    FpIsSquare<T>(Fp: mod.IField<T>, n: T): boolean;
    nLength(n: bigint, nBitLength?: number): mod.NLength;
    Field(ORDER: bigint, bitLenOrOpts?: number | Partial<{
        sqrt: (n: bigint) => bigint;
        isLE: boolean;
        BITS: number;
        modFromBytes: boolean;
        allowedLengths?: readonly number[];
    }>, isLE?: boolean, opts?: {
        sqrt?: (n: bigint) => bigint;
    }): Readonly<mod.IField<bigint> & Required<Pick<mod.IField<bigint>, "isOdd">>>;
    FpSqrtOdd<T>(Fp: mod.IField<T>, elm: T): T;
    FpSqrtEven<T>(Fp: mod.IField<T>, elm: T): T;
    hashToPrivateScalar(hash: string | Uint8Array, groupOrder: bigint, isLE?: boolean): bigint;
    getFieldBytesLength(fieldOrder: bigint): number;
    getMinHashLength(fieldOrder: bigint): number;
    mapHashToField(key: Uint8Array, fieldOrder: bigint, isLE?: boolean): Uint8Array;
    isNegativeLE: (num: bigint, modulo: bigint) => boolean;
    abool(title: string, value: boolean): void;
    _abool2(value: boolean, title?: string): boolean;
    _abytes2(value: Uint8Array, length?: number, title?: string): Uint8Array;
    numberToHexUnpadded(num: number | bigint): string;
    hexToNumber(hex: string): bigint;
    bytesToNumberBE(bytes: Uint8Array): bigint;
    bytesToNumberLE(bytes: Uint8Array): bigint;
    numberToBytesBE(n: number | bigint, len: number): Uint8Array;
    numberToBytesLE(n: number | bigint, len: number): Uint8Array;
    numberToVarBytesBE(n: number | bigint): Uint8Array;
    ensureBytes(title: string, hex: utils.Hex, expectedLength?: number): Uint8Array;
    equalBytes(a: Uint8Array, b: Uint8Array): boolean;
    copyBytes(bytes: Uint8Array): Uint8Array;
    asciiToBytes(ascii: string): Uint8Array;
    inRange(n: bigint, min: bigint, max: bigint): boolean;
    aInRange(title: string, n: bigint, min: bigint, max: bigint): void;
    bitLen(n: bigint): number;
    bitGet(n: bigint, pos: number): bigint;
    bitSet(n: bigint, pos: number, value: boolean): bigint;
    createHmacDrbg<T>(hashLen: number, qByteLen: number, hmacFn: (key: Uint8Array, ...messages: Uint8Array[]) => Uint8Array): (seed: Uint8Array, predicate: (v: Uint8Array) => T | undefined) => T;
    validateObject<T extends Record<string, any>>(object: T, validators: { [K in keyof T]?: "string" | "bigint" | "boolean" | "function" | "hash" | "stringOrUint8Array" | "isSafeInteger" | "array" | "field" | undefined; }, optValidators?: { [K in keyof T]?: "string" | "bigint" | "boolean" | "function" | "hash" | "stringOrUint8Array" | "isSafeInteger" | "array" | "field" | undefined; }): T;
    isHash(val: utils.CHash): boolean;
    _validateObject(object: Record<string, any>, fields: Record<string, string>, optFields?: Record<string, string>): void;
    memoized<T extends object, R, O extends any[]>(fn: (arg: T, ...args: O) => R): (arg: T, ...args: O) => R;
    abytes: typeof utils.abytes;
    anumber: typeof utils.anumber;
    bytesToHex: typeof utils.bytesToHex;
    bytesToUtf8: typeof utils.bytesToUtf8;
    concatBytes: typeof utils.concatBytes;
    hexToBytes: typeof utils.hexToBytes;
    isBytes: typeof utils.isBytes;
    randomBytes: typeof utils.randomBytes;
    utf8ToBytes: typeof utils.utf8ToBytes;
    bitMask: (n: number) => bigint;
    notImplemented: () => never;
    p256: import("@noble/curves/_shortw_utils").CurveFnWithCreate;
};
export declare const CRYPTO_ENCRYPT_ALGORITHM = "aes-128-ccm";
export declare const CRYPTO_HASH_ALGORITHM = "sha256";
export declare const CRYPTO_EC_CURVE = "prime256v1";
export declare const CRYPTO_EC_KEY_BYTES = 32;
export declare const CRYPTO_AUTH_TAG_LENGTH = 16;
export declare const CRYPTO_SYMMETRIC_KEY_LENGTH = 16;
export type CryptoDsaEncoding = "ieee-p1363" | "der";
/**
 * These are the cryptographic primitives required to implement the Matter protocol.
 *
 * We provide a platform-independent implementation that uses Web Crypto via {@link crypto.subtle} and a JS-based
 * AES-CCM implementation.
 *
 * If your platform does not fully implement Web Crypto, or offers a native implementation of AES-CCM, you can replace
 * the implementation in {@link Environment.default}.
 *
 * WARNING: The standard implementation is unaudited.  See relevant warnings in StandardCrypto.ts.
 */
export declare abstract class Crypto {
    /**
     * The name used in log messages.
     */
    abstract implementationName: string;
    /**
     * Encrypt using AES-CCM with constants limited to those required by Matter.
     */
    abstract encrypt(key: Uint8Array, data: Uint8Array, nonce: Uint8Array, aad?: Uint8Array): Uint8Array;
    /**
     * Decrypt using AES-CCM with constants limited to those required by Matter.
     */
    abstract decrypt(key: Uint8Array, data: Uint8Array, nonce: Uint8Array, aad?: Uint8Array): Uint8Array;
    /**
     * Create a random buffer from the most cryptographically-appropriate source available.
     */
    abstract randomBytes(length: number): Uint8Array;
    /**
     * Compute the SHA-256 hash of a buffer.
     */
    abstract computeSha256(data: Uint8Array | Uint8Array[]): MaybePromise<Uint8Array>;
    /**
     * Create a key from a secret using PBKDF2.
     */
    abstract createPbkdf2Key(secret: Uint8Array, salt: Uint8Array, iteration: number, keyLength: number): MaybePromise<Uint8Array>;
    /**
     * Create a key from a secret using HKDF.
     */
    abstract createHkdfKey(secret: Uint8Array, salt: Uint8Array, info: Uint8Array, length?: number): MaybePromise<Uint8Array>;
    /**
     * Create an HMAC signature.
     */
    abstract signHmac(key: Uint8Array, data: Uint8Array): MaybePromise<Uint8Array>;
    /**
     * Create an ECDSA signature.
     */
    abstract signEcdsa(privateKey: JsonWebKey, data: Uint8Array | Uint8Array[], dsaEncoding?: CryptoDsaEncoding): MaybePromise<Uint8Array>;
    /**
     * Authenticate an ECDSA signature.
     */
    abstract verifyEcdsa(publicKey: JsonWebKey, data: Uint8Array, signature: Uint8Array, dsaEncoding?: CryptoDsaEncoding): MaybePromise<void>;
    /**
     * Create a general-purpose EC key.
     */
    abstract createKeyPair(): MaybePromise<PrivateKey>;
    /**
     * Compute the shared secret for a Diffie-Hellman exchange.
     */
    abstract generateDhSecret(key: PrivateKey, peerKey: PublicKey): MaybePromise<Uint8Array>;
    get randomUint8(): number;
    get randomUint16(): number;
    get randomUint32(): number;
    get randomBigUint64(): bigint;
    randomBigInt(size: number, maxValue?: bigint): bigint;
    reportUsage(component?: string): void;
}
//# sourceMappingURL=Crypto.d.ts.map