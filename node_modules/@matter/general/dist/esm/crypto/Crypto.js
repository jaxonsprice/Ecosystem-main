/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { Diagnostic } from "#log/Diagnostic.js";
import { Logger } from "#log/Logger.js";
import { Bytes } from "#util/Bytes.js";
import * as mod from "@noble/curves/abstract/modular";
import * as utils from "@noble/curves/abstract/utils";
import { p256 } from "@noble/curves/p256";
const ec = {
  p256,
  ...utils,
  ...mod
};
const CRYPTO_ENCRYPT_ALGORITHM = "aes-128-ccm";
const CRYPTO_HASH_ALGORITHM = "sha256";
const CRYPTO_EC_CURVE = "prime256v1";
const CRYPTO_EC_KEY_BYTES = 32;
const CRYPTO_AUTH_TAG_LENGTH = 16;
const CRYPTO_SYMMETRIC_KEY_LENGTH = 16;
const logger = Logger.get("Crypto");
class Crypto {
  get randomUint8() {
    return this.randomBytes(1)[0];
  }
  get randomUint16() {
    return new DataView(this.randomBytes(2).buffer).getUint16(0);
  }
  get randomUint32() {
    return new DataView(this.randomBytes(4).buffer).getUint32(0);
  }
  get randomBigUint64() {
    return new DataView(this.randomBytes(8).buffer).getBigUint64(0);
  }
  randomBigInt(size, maxValue) {
    if (maxValue === void 0) {
      return Bytes.asBigInt(this.randomBytes(size));
    }
    while (true) {
      const random = Bytes.asBigInt(this.randomBytes(size));
      if (random < maxValue) return random;
    }
  }
  reportUsage(component) {
    const message = ["Using", Diagnostic.strong(this.implementationName), "crypto implementation"];
    if (component) {
      message.push("for", component);
    }
    logger.debug(...message);
  }
}
export {
  CRYPTO_AUTH_TAG_LENGTH,
  CRYPTO_EC_CURVE,
  CRYPTO_EC_KEY_BYTES,
  CRYPTO_ENCRYPT_ALGORITHM,
  CRYPTO_HASH_ALGORITHM,
  CRYPTO_SYMMETRIC_KEY_LENGTH,
  Crypto,
  ec
};
//# sourceMappingURL=Crypto.js.map
