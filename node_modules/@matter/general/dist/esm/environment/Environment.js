/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { InternalError } from "#MatterError.js";
import { DiagnosticSource } from "../log/DiagnosticSource.js";
import { Logger } from "../log/Logger.js";
import "../polyfills/disposable.js";
import { Time } from "../time/Time.js";
import { UnsupportedDependencyError } from "../util/Lifecycle.js";
import { Observable } from "../util/Observable.js";
import { Environmental } from "./Environmental.js";
import { RuntimeService } from "./RuntimeService.js";
import { VariableService } from "./VariableService.js";
const logger = Logger.get("Environment");
class Environment {
  #services;
  #name;
  #parent;
  #added = Observable();
  #deleted = Observable();
  #serviceEvents = /* @__PURE__ */ new Map();
  constructor(name, parent) {
    this.#name = name;
    this.#parent = parent;
  }
  /**
   * Determine if an environmental service is available.
   */
  has(type) {
    const mine = this.#services?.get(type);
    if (mine === null) {
      return false;
    }
    return mine !== void 0 || (this.#parent?.has(type) ?? false);
  }
  /**
   * Access an environmental service.
   */
  get(type) {
    const mine = this.#services?.get(type);
    if (mine !== void 0 && mine !== null) {
      return mine;
    }
    if (mine === void 0) {
      const instance = this.#parent?.maybeGet(type);
      if (instance !== void 0 && instance !== null) {
        return instance;
      }
    }
    if (type[Environmental.create]) {
      const instance = type[Environmental.create](this);
      if (!(instance instanceof type)) {
        throw new InternalError(`Service creation did not produce instance of ${type.name}`);
      }
      return instance;
    }
    throw new UnsupportedDependencyError(`Required dependency ${type.name}`, "is not available");
  }
  /**
   * Access an environmental service that may not exist.
   */
  maybeGet(type) {
    if (this.has(type)) {
      return this.get(type);
    }
  }
  /**
   * Remove an environmental service.
   *
   * @param type the class of the service to remove
   * @param instance optional instance expected, if existing instance does not match it is not deleted
   */
  delete(type, instance) {
    const localInstance = this.#services?.get(type);
    this.#services?.set(type, null);
    if (localInstance === void 0 || localInstance === null) {
      return;
    }
    if (instance !== void 0 && localInstance !== instance) {
      return;
    }
    this.#deleted.emit(type, localInstance);
    const serviceEvents = this.#serviceEvents.get(type);
    if (serviceEvents) {
      serviceEvents.deleted.emit(localInstance);
    }
  }
  /**
   * Remove and close an environmental service.
   */
  close(type) {
    const instance = this.maybeGet(type);
    this.delete(type, instance);
    if (instance !== void 0) {
      return instance.close?.();
    }
  }
  /**
   * Access an environmental service, waiting for any async initialization to complete.
   */
  async load(type) {
    const instance = this.get(type);
    await instance.construction;
    return instance;
  }
  /**
   * Install a preinitialized version of an environmental service.
   */
  set(type, instance) {
    if (!this.#services) {
      this.#services = /* @__PURE__ */ new Map();
    }
    this.#services.set(type, instance);
    this.#added.emit(type, instance);
    const serviceEvents = this.#serviceEvents.get(type);
    if (serviceEvents) {
      serviceEvents.added.emit(instance);
    }
  }
  /**
   * Name of the environment.
   */
  get name() {
    return this.#name;
  }
  get root() {
    return this.#parent?.root ?? this;
  }
  /**
   * Emits on service add.
   *
   * Currently only emits for services owned directly by this environment.
   */
  get added() {
    return this.#added;
  }
  /**
   * Emits on service delete.
   *
   * Currently only emits for services owned directly by this environment.
   */
  get deleted() {
    return this.#deleted;
  }
  /**
   * Obtain an object with events that trigger when a specific service is added or deleted.
   *
   * This is a more convenient way to observe a specific service than {@link added} and {@link deleted}.
   */
  eventsFor(type) {
    let events = this.#serviceEvents.get(type);
    if (events === void 0) {
      events = {
        added: Observable(),
        deleted: Observable()
      };
      this.#serviceEvents.set(type, events);
    }
    return events;
  }
  /**
   * The default environment.
   *
   * Currently only emits for services owned directly by this environment.
   */
  static get default() {
    return global;
  }
  /**
   * Set the default environment.
   */
  static set default(env) {
    global = env;
    env.vars.use(() => {
      Logger.level = env.vars.get("log.level", Logger.level);
      Logger.format = env.vars.get("log.format", Logger.format);
      const stackLimit = global.vars.number("log.stack.limit");
      if (stackLimit !== void 0) {
        Error.stackTraceLimit = stackLimit;
      }
    });
  }
  /**
   * Shortcut for accessing {@link VariableService.vars}.
   */
  get vars() {
    return this.get(VariableService);
  }
  /**
   * Shortcut for accessing {@link RuntimeService}.
   */
  get runtime() {
    return this.get(RuntimeService);
  }
  /**
   * Display tasks that supply diagnostics.
   */
  diagnose() {
    Time.getTimer("Diagnostics", 0, () => {
      try {
        logger.notice("Diagnostics follow", DiagnosticSource);
      } catch (e) {
        logger.error(`Unhandled error gathering diagnostics:`, e);
      }
    }).start();
  }
  loadVariables() {
    return {};
  }
}
let global = new Environment("default");
export {
  Environment
};
//# sourceMappingURL=Environment.js.map
