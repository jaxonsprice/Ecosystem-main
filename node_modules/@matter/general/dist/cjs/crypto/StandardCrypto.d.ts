/**
 * @license
 *
 * Portions copyright 2022-2023 Project CHIP Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { Crypto, CryptoDsaEncoding } from "./Crypto.js";
import { PrivateKey, PublicKey } from "./Key.js";
/**
 * A {@link Crypto} implementation that uses only JS standards.
 *
 * WARNING: This code is unaudited.  Use a trusted native alternative where available.
 *
 * This module is mostly based on  {@link crypto.subtle}.  This should be a reliable native implementation.  However,
 * Web Crypto doesn't support AES-CCM required by Matter so we use a JS implementation for that.  See relevant warnings
 * in the "aes" subdirectory.
 */
export declare class StandardCrypto extends Crypto {
    #private;
    implementationName: string;
    constructor(subtle?: SubtleCrypto);
    static provider(): StandardCrypto;
    randomBytes(length: number): Uint8Array;
    encrypt(key: Uint8Array, data: Uint8Array, nonce: Uint8Array, associatedData?: Uint8Array): Uint8Array<ArrayBufferLike>;
    decrypt(key: Uint8Array, data: Uint8Array, nonce: Uint8Array, associatedData?: Uint8Array): Uint8Array<ArrayBufferLike>;
    computeSha256(buffer: Uint8Array | Uint8Array[]): Promise<Uint8Array<ArrayBuffer>>;
    createPbkdf2Key(secret: Uint8Array, salt: Uint8Array, iteration: number, keyLength: number): Promise<Uint8Array<ArrayBuffer>>;
    createHkdfKey(secret: Uint8Array, salt: Uint8Array, info: Uint8Array, length?: number): Promise<Uint8Array<ArrayBuffer>>;
    signHmac(secret: Uint8Array, data: Uint8Array): Promise<Uint8Array<ArrayBuffer>>;
    signEcdsa(key: JsonWebKey, data: Uint8Array | Uint8Array[], dsaEncoding?: CryptoDsaEncoding): Promise<Uint8Array<ArrayBuffer>>;
    verifyEcdsa(key: JsonWebKey, data: Uint8Array, signature: Uint8Array, dsaEncoding?: CryptoDsaEncoding): Promise<void>;
    createKeyPair(): Promise<PrivateKey>;
    generateDhSecret(key: PrivateKey, peerKey: PublicKey): Promise<Uint8Array<ArrayBuffer>>;
}
//# sourceMappingURL=StandardCrypto.d.ts.map