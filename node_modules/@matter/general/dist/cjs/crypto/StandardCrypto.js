"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var StandardCrypto_exports = {};
__export(StandardCrypto_exports, {
  StandardCrypto: () => StandardCrypto
});
module.exports = __toCommonJS(StandardCrypto_exports);
var import_DerCodec = require("#codec/DerCodec.js");
var import_Environment = require("#environment/Environment.js");
var import_MatterError = require("#MatterError.js");
var import_Bytes = require("#util/Bytes.js");
var import_String = require("#util/String.js");
var import_Ccm = require("./aes/Ccm.js");
var import_Crypto = require("./Crypto.js");
var import_CryptoError = require("./CryptoError.js");
var import_Key = require("./Key.js");
/**
 * @license
 *
 * Portions copyright 2022-2023 Project CHIP Authors
 * SPDX-License-Identifier: Apache-2.0
 */
const SIGNATURE_ALGORITHM = {
  name: "ECDSA",
  namedCurve: "P-256",
  hash: { name: "SHA-256" }
};
const requiredSubtleMethods = [
  "digest",
  "deriveBits",
  "sign",
  "verify",
  "generateKey",
  "exportKey",
  "importKey"
];
class StandardCrypto extends import_Crypto.Crypto {
  implementationName = "JS";
  #subtle;
  constructor(subtle = globalThis.crypto?.subtle) {
    if (typeof subtle !== "object" || subtle === null) {
      throw new import_MatterError.ImplementationError(
        "You cannot instantiate StandardCrypto in this runtime because crypto.subtle is not present"
      );
    }
    const missingMethods = requiredSubtleMethods.filter((name) => typeof subtle[name] !== "function");
    if (missingMethods.length) {
      throw new import_MatterError.ImplementationError(
        `SubtleCrypto implementation is missing required method${missingMethods.length === 1 ? "" : "s"} ${(0, import_String.describeList)("and", ...missingMethods)}`
      );
    }
    super();
    this.#subtle = subtle;
  }
  static provider() {
    return new StandardCrypto();
  }
  randomBytes(length) {
    const result = new Uint8Array(length);
    crypto.getRandomValues(result);
    return result;
  }
  encrypt(key, data, nonce, associatedData) {
    const ccm = (0, import_Ccm.Ccm)(key);
    return ccm.encrypt({ pt: data, nonce, adata: associatedData });
  }
  decrypt(key, data, nonce, associatedData) {
    const ccm = (0, import_Ccm.Ccm)(key);
    return ccm.decrypt({ ct: data, nonce, adata: associatedData });
  }
  async computeSha256(buffer) {
    if (Array.isArray(buffer)) {
      buffer = import_Bytes.Bytes.concat(...buffer);
    }
    return new Uint8Array(await this.#subtle.digest("SHA-256", buffer));
  }
  async createPbkdf2Key(secret, salt, iteration, keyLength) {
    const key = await this.#importKey("raw", secret, "PBKDF2", false, ["deriveBits"]);
    const bits = await this.#subtle.deriveBits(
      {
        name: "PBKDF2",
        hash: "SHA-256",
        salt,
        iterations: iteration
      },
      key,
      keyLength * 8
    );
    return new Uint8Array(bits);
  }
  async createHkdfKey(secret, salt, info, length = import_Crypto.CRYPTO_SYMMETRIC_KEY_LENGTH) {
    const key = await this.#importKey("raw", secret, "HKDF", false, ["deriveBits"]);
    const bits = await this.#subtle.deriveBits(
      {
        name: "HKDF",
        hash: "SHA-256",
        salt,
        info
      },
      key,
      8 * length
    );
    return new Uint8Array(bits);
  }
  async signHmac(secret, data) {
    const key = await this.#importKey("raw", secret, { name: "HMAC", hash: "SHA-256" }, false, ["sign"]);
    return new Uint8Array(await this.#subtle.sign("HMAC", key, data));
  }
  async signEcdsa(key, data, dsaEncoding) {
    if (Array.isArray(data)) {
      data = import_Bytes.Bytes.concat(...data);
    }
    const { crv, kty, d, x, y } = key;
    key = {
      kty,
      crv,
      d,
      x,
      y,
      ext: true,
      // Required by some subtle implementations to sign
      key_ops: ["sign"]
    };
    const subtleKey = await this.#importKey("jwk", key, SIGNATURE_ALGORITHM, false, ["sign"]);
    const ieeeP1363 = await this.#subtle.sign(SIGNATURE_ALGORITHM, subtleKey, data);
    if (dsaEncoding !== "der") return new Uint8Array(ieeeP1363);
    const bytesPerComponent = ieeeP1363.byteLength / 2;
    return import_DerCodec.DerCodec.encode({
      r: (0, import_DerCodec.DerBigUint)(ieeeP1363.slice(0, bytesPerComponent)),
      s: (0, import_DerCodec.DerBigUint)(ieeeP1363.slice(bytesPerComponent))
    });
  }
  async verifyEcdsa(key, data, signature, dsaEncoding) {
    const { crv, kty, x, y } = key;
    key = { crv, kty, x, y };
    const subtleKey = await this.#importKey("jwk", key, SIGNATURE_ALGORITHM, false, ["verify"]);
    if (dsaEncoding === "der") {
      try {
        const decoded = import_DerCodec.DerCodec.decode(signature);
        const r = import_DerCodec.DerCodec.decodeBigUint(decoded?._elements?.[0], 32);
        const s = import_DerCodec.DerCodec.decodeBigUint(decoded?._elements?.[1], 32);
        signature = import_Bytes.Bytes.concat(r, s);
      } catch (cause) {
        import_DerCodec.DerError.accept(cause);
        throw new import_CryptoError.CryptoVerifyError("Invalid DER signature", { cause });
      }
    }
    const verified = await this.#subtle.verify(SIGNATURE_ALGORITHM, subtleKey, signature, data);
    if (!verified) {
      throw new import_CryptoError.CryptoVerifyError("Signature verification failed");
    }
  }
  async createKeyPair() {
    const subtleKey = await this.#subtle.generateKey(
      {
        // We must specify either ECDH or ECDSA to get an EC key but we may use the key for either (but not for
        // both)
        name: "ECDH",
        namedCurve: "P-256"
      },
      true,
      // We must also specify usage but will drop this on export
      ["deriveKey"]
    );
    const key = await this.#subtle.exportKey("jwk", subtleKey.privateKey);
    return (0, import_Key.Key)({
      kty: import_Key.KeyType.EC,
      crv: import_Key.CurveType.p256,
      d: key.d,
      x: key.x,
      y: key.y
    });
  }
  async generateDhSecret(key, peerKey) {
    const subtleKey = await this.#importKey(
      "jwk",
      key,
      {
        name: "ECDH",
        namedCurve: "P-256"
      },
      false,
      ["deriveBits"]
    );
    const subtlePeerKey = await this.#importKey(
      "jwk",
      peerKey,
      {
        name: "ECDH",
        namedCurve: "P-256"
      },
      false,
      []
    );
    const secret = await this.#subtle.deriveBits(
      {
        name: "ECDH",
        public: subtlePeerKey
      },
      subtleKey,
      256
    );
    return new Uint8Array(secret);
  }
  async #importKey(...params) {
    try {
      return await this.#subtle.importKey(...params);
    } catch (cause) {
      throw new import_CryptoError.KeyInputError("Invalid key", { cause });
    }
  }
}
if ("crypto" in globalThis && globalThis.crypto?.subtle) {
  import_Environment.Environment.default.set(import_Crypto.Crypto, new StandardCrypto(globalThis.crypto.subtle));
}
//# sourceMappingURL=StandardCrypto.js.map
