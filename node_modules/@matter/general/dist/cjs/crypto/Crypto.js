"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod2, isNodeMode, target) => (target = mod2 != null ? __create(__getProtoOf(mod2)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod2 || !mod2.__esModule ? __defProp(target, "default", { value: mod2, enumerable: true }) : target,
  mod2
));
var __toCommonJS = (mod2) => __copyProps(__defProp({}, "__esModule", { value: true }), mod2);
var Crypto_exports = {};
__export(Crypto_exports, {
  CRYPTO_AUTH_TAG_LENGTH: () => CRYPTO_AUTH_TAG_LENGTH,
  CRYPTO_EC_CURVE: () => CRYPTO_EC_CURVE,
  CRYPTO_EC_KEY_BYTES: () => CRYPTO_EC_KEY_BYTES,
  CRYPTO_ENCRYPT_ALGORITHM: () => CRYPTO_ENCRYPT_ALGORITHM,
  CRYPTO_HASH_ALGORITHM: () => CRYPTO_HASH_ALGORITHM,
  CRYPTO_SYMMETRIC_KEY_LENGTH: () => CRYPTO_SYMMETRIC_KEY_LENGTH,
  Crypto: () => Crypto,
  ec: () => ec
});
module.exports = __toCommonJS(Crypto_exports);
var import_Diagnostic = require("#log/Diagnostic.js");
var import_Logger = require("#log/Logger.js");
var import_Bytes = require("#util/Bytes.js");
var mod = __toESM(require("@noble/curves/abstract/modular"), 1);
var utils = __toESM(require("@noble/curves/abstract/utils"), 1);
var import_p256 = require("@noble/curves/p256");
/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
const ec = {
  p256: import_p256.p256,
  ...utils,
  ...mod
};
const CRYPTO_ENCRYPT_ALGORITHM = "aes-128-ccm";
const CRYPTO_HASH_ALGORITHM = "sha256";
const CRYPTO_EC_CURVE = "prime256v1";
const CRYPTO_EC_KEY_BYTES = 32;
const CRYPTO_AUTH_TAG_LENGTH = 16;
const CRYPTO_SYMMETRIC_KEY_LENGTH = 16;
const logger = import_Logger.Logger.get("Crypto");
class Crypto {
  get randomUint8() {
    return this.randomBytes(1)[0];
  }
  get randomUint16() {
    return new DataView(this.randomBytes(2).buffer).getUint16(0);
  }
  get randomUint32() {
    return new DataView(this.randomBytes(4).buffer).getUint32(0);
  }
  get randomBigUint64() {
    return new DataView(this.randomBytes(8).buffer).getBigUint64(0);
  }
  randomBigInt(size, maxValue) {
    if (maxValue === void 0) {
      return import_Bytes.Bytes.asBigInt(this.randomBytes(size));
    }
    while (true) {
      const random = import_Bytes.Bytes.asBigInt(this.randomBytes(size));
      if (random < maxValue) return random;
    }
  }
  reportUsage(component) {
    const message = ["Using", import_Diagnostic.Diagnostic.strong(this.implementationName), "crypto implementation"];
    if (component) {
      message.push("for", component);
    }
    logger.debug(...message);
  }
}
//# sourceMappingURL=Crypto.js.map
