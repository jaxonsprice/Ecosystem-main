/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { Endian } from "../util/Bytes.js";
import { DataReader } from "../util/DataReader.js";
/**
 * The maximum MDNS message size to usually fit into one UDP network MTU packet. Data are split into multiple messages
 * when needed.
 */
export declare const MAX_MDNS_MESSAGE_SIZE = 1232;
export declare const PtrRecord: (name: string, ptr: string, forInstance?: string, ttl?: number, flushCache?: boolean) => DnsRecord<string>;
export declare const ARecord: (name: string, ip: string, ttl?: number, flushCache?: boolean) => DnsRecord<string>;
export declare const AAAARecord: (name: string, ip: string, ttl?: number, flushCache?: boolean) => DnsRecord<string>;
export declare const TxtRecord: (name: string, entries: string[], forInstance?: string, ttl?: number, flushCache?: boolean) => DnsRecord<string[]>;
export declare const SrvRecord: (name: string, srv: SrvRecordValue, forInstance?: string, ttl?: number, flushCache?: boolean) => DnsRecord<SrvRecordValue>;
export type SrvRecordValue = {
    priority: number;
    weight: number;
    port: number;
    target: string;
};
export type DnsQuery = {
    name: string;
    recordType: DnsRecordType;
    recordClass: DnsRecordClass;
    uniCastResponse?: boolean;
};
export type DnsRecord<T> = {
    name: string;
    recordType: DnsRecordType;
    recordClass: DnsRecordClass;
    flushCache?: boolean;
    ttl: number;
    value: T;
    forInstance?: string;
};
export type DnsMessage = {
    transactionId: number;
    messageType: DnsMessageType;
    queries: DnsQuery[];
    answers: DnsRecord<any>[];
    authorities: DnsRecord<any>[];
    additionalRecords: DnsRecord<any>[];
};
export type DnsMessagePartiallyPreEncoded = Omit<DnsMessage, "answers" | "additionalRecords"> & {
    answers: (DnsRecord<any> | Uint8Array)[];
    additionalRecords: (DnsRecord<any> | Uint8Array)[];
};
/** Bit flags to use to determine separate flags in the DnsMessageType field */
export declare enum DnsMessageTypeFlag {
    /** Indicates if the message is a query (0) or a reply (1). */
    QR = 32768,
    /** The type can be QUERY (standard query, 0), IQUERY (inverse query, 1), or STATUS (server status request, 2). */
    OPCODE = 30720,
    /** Authoritative Answer, in a response, indicates if the DNS server is authoritative for the queried hostname. */
    AA = 1024,
    /** TrunCation, indicates that this message was truncated due to excessive length. */
    TC = 512,
    /** Recursion Desired, indicates if the client means a recursive query. */
    RD = 256,
    /** Recursion Available, in a response, indicates if the replying DNS server supports recursion. */
    RA = 128,
    /** Authentic Data, in a response, indicates if the replying DNS server verified the data. */
    AD = 32,
    /** Checking Disabled, in a query, indicates that non-verified data is acceptable in a response. */
    CD = 16,
    /** Response code, can be NOERROR (0), FORMERR (1, Format error), SERVFAIL (2), NXDOMAIN (3, Nonexistent domain), etc. */
    RCODE = 15
}
/** Convenient Message types we use when sending mDNS messages */
export declare enum DnsMessageType {
    Query = 0,// No bit set
    TruncatedQuery = 512,
    Response = 33792
}
export declare namespace DnsMessageType {
    function isQuery(type: number): boolean;
    function isResponse(type: number): boolean;
}
export declare enum DnsRecordType {
    A = 1,
    PTR = 12,
    TXT = 16,
    AAAA = 28,
    SRV = 33,
    NSEC = 47,
    ANY = 255
}
export declare enum DnsRecordClass {
    IN = 1,
    ANY = 255
}
export declare class DnsCodec {
    static decode(message: Uint8Array): DnsMessage | undefined;
    static decodeQuery(reader: DataReader<Endian.Big>, message: Uint8Array): DnsQuery;
    static decodeRecord(reader: DataReader<Endian.Big>, message: Uint8Array): DnsRecord<any>;
    static decodeQName(reader: DataReader<Endian.Big>, message: Uint8Array, visited?: Set<number>): string;
    private static decodeRecordValue;
    static decodeSrvRecord(valueBytes: Uint8Array, message: Uint8Array): SrvRecordValue;
    static decodeTxtRecord(valueBytes: Uint8Array): string[];
    static decodeAaaaRecord(valueBytes: Uint8Array): string;
    static decodeARecord(valueBytes: Uint8Array): string;
    static encode({ messageType, transactionId, queries, answers, authorities, additionalRecords, }: Partial<DnsMessagePartiallyPreEncoded>): Uint8Array;
    static encodeRecord(record: DnsRecord<any>): Uint8Array;
    private static encodeRecordValue;
    static encodeARecord(ip: string): Uint8Array<ArrayBuffer>;
    static encodeAaaaRecord(ip: string): Uint8Array<ArrayBuffer>;
    static encodeTxtRecord(entries: string[]): Uint8Array<ArrayBuffer>;
    static encodeSrvRecord({ priority, weight, port, target }: SrvRecordValue): Uint8Array<ArrayBuffer>;
    static encodeQName(qname: string): Uint8Array<ArrayBuffer>;
}
//# sourceMappingURL=DnsCodec.d.ts.map