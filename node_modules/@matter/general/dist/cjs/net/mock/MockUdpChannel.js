"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var MockUdpChannel_exports = {};
__export(MockUdpChannel_exports, {
  MockUdpChannel: () => MockUdpChannel
});
module.exports = __toCommonJS(MockUdpChannel_exports);
var import_Channel = require("#net/Channel.js");
var import_Network = require("../Network.js");
var import_UdpChannel = require("../UdpChannel.js");
var import_MockRouter = require("./MockRouter.js");
/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
class MockUdpChannel {
  #host;
  #router;
  #sendFrom;
  #receiveFrom;
  #listeningPort;
  maxPayloadSize = import_UdpChannel.MAX_UDP_MESSAGE_SIZE;
  constructor(network, { listeningAddress, listeningPort, netInterface, type }, packetManipulator) {
    this.#router = (0, import_MockRouter.MockRouter)(packetManipulator);
    const { ipV4, ipV6 } = network.getIpMac(netInterface ?? "fake0");
    let addresses = type === "udp4" ? ipV4 : ipV6;
    this.#sendFrom = addresses[0];
    if (listeningAddress !== void 0 && listeningAddress !== "*") {
      addresses = addresses.filter((addr) => addr === listeningAddress);
    }
    if (!addresses.length) {
      throw new import_Network.NetworkError(`No ${type} IP matches ${listeningAddress ?? "*"} on the specified interface`);
    }
    this.#host = network;
    this.#receiveFrom = new Set(addresses);
    this.#listeningPort = listeningPort ?? 1024 + Math.floor(Math.random() * 64511);
    network.router.add(this.#router);
  }
  onData(listener) {
    const router = (packet) => {
      if (packet.kind !== "udp") {
        return;
      }
      if (!this.#receiveFrom.has(packet.destAddress)) {
        return;
      }
      if (packet.destPort !== this.#listeningPort) {
        return;
      }
      listener("fake0", packet.sourceAddress, packet.sourcePort, packet.payload);
    };
    this.#router.add(router);
    return {
      close: async () => {
        this.#router.delete(router);
      }
    };
  }
  async send(host, port, payload) {
    this.#host.simulator.router({
      kind: "udp",
      sourceAddress: this.#sendFrom,
      sourcePort: this.#listeningPort,
      destAddress: host,
      destPort: port,
      payload
    });
  }
  async close() {
    this.#host.router.delete(this.#router);
  }
  async [Symbol.asyncDispose]() {
    return this.close();
  }
  get port() {
    return this.#listeningPort;
  }
  supports(type, _address) {
    return type === import_Channel.ChannelType.UDP;
  }
  addMembership(address) {
    this.#receiveFrom.add(address);
  }
  dropMembership(address) {
    this.#receiveFrom.delete(address);
  }
}
//# sourceMappingURL=MockUdpChannel.js.map
