/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { Access, Aspect, Conformance, Constraint, Quality } from "../aspects/index.js";
import { ElementTag, FieldValue, Metatype } from "../common/index.js";
import { ValueElement } from "../elements/index.js";
import { Model } from "./Model.js";
import type { PropertyModel } from "./PropertyModel.js";
import type { FieldModel } from "./FieldModel.js";
/**
 * Each {@link ValueElement} type has a corresponding implementation that derives from this class.
 */
export declare abstract class ValueModel<T extends ValueElement = ValueElement> extends Model<T, FieldModel> implements ValueElement {
    #private;
    byteSize?: ValueElement.ByteSize;
    default?: FieldValue;
    metatype?: Metatype;
    isType?: boolean | undefined;
    get constraint(): Constraint;
    set constraint(definition: Constraint | Constraint.Definition);
    get effectiveConstraint(): Constraint;
    get conformance(): Conformance;
    set conformance(definition: Conformance | Conformance.Definition);
    get effectiveConformance(): Conformance;
    get access(): Access;
    set access(definition: Access | Access.Definition);
    get effectiveAccess(): Access;
    get quality(): Quality;
    set quality(definition: Quality | Quality.Definition);
    get effectiveQuality(): Quality;
    get fields(): FieldModel[];
    /**
     * Metatype is only present on global types with specific semantic meaning. This model is significant because it
     * gives us information about how to manipulate the data.  This accessor retrieves this model.
     */
    get metabase(): ValueModel | undefined;
    /**
     * Get the primitive type for this value model.  This is an integer type for enums and bitmaps.  Otherwise it's the
     * metabase.
     */
    get primitiveBase(): ValueModel | undefined;
    /**
     * The "effective type" may be inferred from context.
     */
    get effectiveType(): string | undefined;
    /**
     * The working metatype for this object.
     */
    get effectiveMetatype(): Metatype | undefined;
    /**
     * Get the first derived ancestor with children, if any.
     */
    get definingModel(): ValueModel<ValueElement> | undefined;
    /**
     * Get the entry type for lists, if any.
     */
    get listEntry(): FieldModel | undefined;
    /**
     * ValueModels may only derive from ValueModels.
     */
    get base(): ValueModel | undefined;
    /**
     * ValueModels may derive from models of the same type or from generic Datatype models.
     */
    get allowedBaseTags(): ElementTag[];
    /**
     * All {@link FieldModel} children in the context of the model's containing scope.
     */
    get members(): PropertyModel[];
    /**
     * Collect constraints and conformance for this type and all base types.
     */
    get validationAspects(): Aspect<any>[];
    /**
     * Is this model deprecated?
     */
    get isDeprecated(): boolean;
    /**
     * Is this model disallowed?
     */
    get isDisallowed(): boolean;
    /**
     * Can this model be omitted?
     */
    get nullable(): boolean;
    /**
     * Is the model mandatory?
     */
    get mandatory(): boolean;
    /**
     * Determine whether this element overrides key properties of its shadow.
     */
    get overridesShadow(): true | undefined;
    /**
     * Search the inheritance chain for a bitmap field defining a specific bit.
     */
    bitDefinition(bit: number): FieldModel | undefined;
    /**
     * Clone the model with minimum metadata required to ensure model is valid.
     */
    cloneAsReference<This extends ValueModel>(this: This): This;
    get requiredFields(): T;
    constructor(definition: Model.Definition<ValueModel<T>>, ...children: Model.ChildDefinition<FieldModel>[]);
    toElement(omitResources?: boolean, extra?: Record<string, unknown>): T;
}
//# sourceMappingURL=ValueModel.d.ts.map