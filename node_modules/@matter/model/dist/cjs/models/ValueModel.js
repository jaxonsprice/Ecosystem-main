"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var ValueModel_exports = {};
__export(ValueModel_exports, {
  ValueModel: () => ValueModel
});
module.exports = __toCommonJS(ValueModel_exports);
var import_Scope = require("#logic/Scope.js");
var import_aspects = require("../aspects/index.js");
var import_common = require("../common/index.js");
var import_ModelTraversal = require("../logic/ModelTraversal.js");
var import_Model = require("./Model.js");
/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
class ValueModel extends import_Model.Model {
  byteSize;
  default;
  metatype;
  isType = true;
  #constraint;
  #conformance;
  #access;
  #quality;
  get constraint() {
    return this.#constraint;
  }
  set constraint(definition) {
    this.#constraint = import_aspects.Constraint.create(definition);
  }
  get effectiveConstraint() {
    return new import_ModelTraversal.ModelTraversal().findConstraint(this) || this.constraint;
  }
  get conformance() {
    return this.#conformance;
  }
  set conformance(definition) {
    this.#conformance = import_aspects.Conformance.create(definition);
  }
  get effectiveConformance() {
    return new import_ModelTraversal.ModelTraversal().findAspect(this, "conformance", import_aspects.Conformance) ?? this.#conformance;
  }
  get access() {
    return this.#access;
  }
  set access(definition) {
    this.#access = import_aspects.Access.create(definition);
  }
  get effectiveAccess() {
    return new import_ModelTraversal.ModelTraversal().findAccess(this, ValueModel);
  }
  get quality() {
    return this.#quality;
  }
  set quality(definition) {
    this.#quality = import_aspects.Quality.create(definition);
  }
  get effectiveQuality() {
    return new import_ModelTraversal.ModelTraversal().findAspect(this, "quality", import_aspects.Quality) ?? this.#quality;
  }
  get fields() {
    return (0, import_Scope.Scope)(this).membersOf(this, { tags: [import_common.ElementTag.Field] });
  }
  /**
   * Metatype is only present on global types with specific semantic meaning. This model is significant because it
   * gives us information about how to manipulate the data.  This accessor retrieves this model.
   */
  get metabase() {
    return new import_ModelTraversal.ModelTraversal().findMetabase(this);
  }
  /**
   * Get the primitive type for this value model.  This is an integer type for enums and bitmaps.  Otherwise it's the
   * metabase.
   */
  get primitiveBase() {
    const metabase = this.metabase;
    if (!metabase) {
      return;
    }
    if (metabase.metatype === import_common.Metatype.enum) {
      return metabase.base;
    }
    if (metabase.metatype === import_common.Metatype.bitmap) {
      const primitiveName = metabase.name.replace("map", "uint");
      return metabase.parent?.children.find((c) => c.name === primitiveName);
    }
    return metabase;
  }
  /**
   * The "effective type" may be inferred from context.
   */
  get effectiveType() {
    const type = super.effectiveType;
    if (type) {
      return type;
    }
    return new import_ModelTraversal.ModelTraversal().getTypeName(this);
  }
  /**
   * The working metatype for this object.
   */
  get effectiveMetatype() {
    const metaBase = this.metabase;
    if (metaBase) {
      return metaBase.metatype;
    }
  }
  /**
   * Get the first derived ancestor with children, if any.
   */
  get definingModel() {
    return new import_ModelTraversal.ModelTraversal().findDefiningModel(this);
  }
  /**
   * Get the entry type for lists, if any.
   */
  get listEntry() {
    return this.member("entry", [import_common.ElementTag.Field]);
  }
  /**
   * ValueModels may only derive from ValueModels.
   */
  get base() {
    return super.base;
  }
  /**
   * ValueModels may derive from models of the same type or from generic Datatype models.
   */
  get allowedBaseTags() {
    if (this.tag === import_common.ElementTag.Field) {
      return [import_common.ElementTag.Field, import_common.ElementTag.Datatype, import_common.ElementTag.Attribute];
    }
    return [this.tag, import_common.ElementTag.Datatype];
  }
  /**
   * All {@link FieldModel} children in the context of the model's containing scope.
   */
  get members() {
    return (0, import_Scope.Scope)(this).membersOf(this);
  }
  /**
   * Collect constraints and conformance for this type and all base types.
   */
  get validationAspects() {
    const aspects = Array();
    new import_ModelTraversal.ModelTraversal().visitInheritance(this, (model) => {
      if (model instanceof ValueModel) {
        if (!model.conformance.isEmpty && model.conformance.type !== import_aspects.Conformance.Special.Desc) {
          aspects.push(model.conformance);
        }
        if (!model.constraint.isEmpty && !model.constraint.desc) {
          aspects.push(model.constraint);
        }
        if (model.quality.nullable === false) {
          aspects.push(model.quality);
        }
      }
    });
    return aspects;
  }
  /**
   * Is this model deprecated?
   */
  get isDeprecated() {
    return this.effectiveConformance.type === import_aspects.Conformance.Flag.Deprecated;
  }
  /**
   * Is this model disallowed?
   */
  get isDisallowed() {
    return this.effectiveConformance.type === import_aspects.Conformance.Flag.Disallowed;
  }
  /**
   * Can this model be omitted?
   */
  get nullable() {
    return !!this.effectiveQuality.nullable;
  }
  /**
   * Is the model mandatory?
   */
  get mandatory() {
    return this.effectiveConformance.isMandatory;
  }
  /**
   * Determine whether this element overrides key properties of its shadow.
   */
  get overridesShadow() {
    const shadow = this.shadow;
    if (!shadow || !(shadow instanceof ValueModel)) {
      return;
    }
    if (this.type && this.type !== shadow.type) {
      return true;
    }
    if (!this.conformance.isEmpty && !this.conformance.equals(shadow.conformance)) {
      return true;
    }
    if (!this.quality.isEmpty && !this.quality.equals(shadow.quality)) {
      return true;
    }
    if (!this.constraint.isEmpty && !this.constraint.equals(shadow.constraint)) {
      return true;
    }
    if (!this.access.isEmpty && !this.access.equals(shadow.access)) {
      return true;
    }
  }
  /**
   * Search the inheritance chain for a bitmap field defining a specific bit.
   */
  bitDefinition(bit) {
    return new import_ModelTraversal.ModelTraversal().findBitDefinition(this, bit);
  }
  /**
   * Clone the model with minimum metadata required to ensure model is valid.
   */
  cloneAsReference() {
    const Type = this.constructor;
    return new Type(this.requiredFields);
  }
  get requiredFields() {
    return { name: this.name };
  }
  constructor(definition, ...children) {
    super(definition, ...children);
    this.byteSize = definition.byteSize;
    this.default = definition.default;
    this.#constraint = import_aspects.Constraint.create(definition.constraint);
    this.#conformance = import_aspects.Conformance.create(definition.conformance);
    this.#access = import_aspects.Access.create(definition.access);
    this.#quality = import_aspects.Quality.create(definition.quality);
    const match = this.type?.match(/^list\[(.*)\]$/);
    if (match) {
      this.type = "list";
      this.children.push(new import_Model.Model.types.field({ name: "entry", type: match[1] }));
    }
  }
  toElement(omitResources = false, extra) {
    return super.toElement(omitResources, {
      byteSize: this.byteSize,
      default: this.default,
      constraint: this.#constraint.valueOf(),
      conformance: this.#conformance.valueOf(),
      access: this.#access.valueOf(),
      quality: this.#quality.valueOf(),
      ...extra
    });
  }
}
//# sourceMappingURL=ValueModel.js.map
