/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { camelize, describeList } from "#general";
import { ModelTraversal } from "#logic/ModelTraversal.js";
import { Access } from "../aspects/Access.js";
import { Quality } from "../aspects/Quality.js";
import { SchemaImplementationError } from "../common/errors.js";
import { ElementTag, FeatureSet, Metatype } from "../common/index.js";
import { ClusterElement } from "../elements/index.js";
import { ClusterRevision, FeatureMap } from "../standard/elements/definitions.js";
import { AttributeModel } from "./AttributeModel.js";
import { Model } from "./Model.js";
import { ScopeModel } from "./ScopeModel.js";
class ClusterModel extends ScopeModel {
  tag = ClusterElement.Tag;
  #quality;
  get diagnostics() {
    return this.effectiveQuality.diagnostics;
  }
  get quality() {
    return this.#quality;
  }
  set quality(definition) {
    this.#quality = Quality.create(definition);
  }
  get effectiveQuality() {
    return new ModelTraversal().findAspect(this, "quality", Quality) ?? this.#quality;
  }
  get attributes() {
    return this.scope.membersOf(this, { tags: [ElementTag.Attribute] });
  }
  get commands() {
    return this.scope.membersOf(this, { tags: [ElementTag.Command] });
  }
  get events() {
    return this.scope.membersOf(this, { tags: [ElementTag.Event] });
  }
  get datatypes() {
    return this.scope.membersOf(this, { tags: [ElementTag.Datatype] });
  }
  get classification() {
    return this.resource?.classification;
  }
  set classification(classification) {
    if (classification || this.hasLocalResource) {
      this.localResource.classification = classification;
    }
  }
  get pics() {
    return this.hasLocalResource ? this.localResource.pics : void 0;
  }
  set pics(pics) {
    if (pics || this.hasLocalResource) {
      this.localResource.pics = pics;
    }
  }
  /**
   * Get attributes, commands and events whether inherited or defined directly in this model.
   */
  get allAces() {
    return this.scope.membersOf(this, { tags: [ElementTag.Attribute, ElementTag.Command, ElementTag.Event] });
  }
  get revision() {
    let revision = 1;
    const revisionAttr = this.get(AttributeModel, ClusterRevision.id);
    if (typeof revisionAttr?.default === "number") {
      revision = revisionAttr.default;
    }
    return revision;
  }
  get features() {
    return this.featureMap.children ?? [];
  }
  get featureMap() {
    return this.member(FeatureMap.id, [ElementTag.Attribute]) ?? new AttributeModel(FeatureMap);
  }
  get featureNames() {
    return new FeatureSet(this.features.map((feature) => feature.name));
  }
  get supportedFeatures() {
    const supported = {};
    for (const feature of this.features) {
      if (feature.default) {
        supported[feature.name] = true;
      }
    }
    return new FeatureSet(supported);
  }
  set supportedFeatures(features) {
    const featureSet = new FeatureSet(features);
    let featureMap = this.featureMap;
    if (featureMap.parent !== this) {
      featureMap = featureMap.clone();
      this.children.push(featureMap);
    }
    for (const feature of featureMap.children) {
      const desc = feature.title && camelize(feature.title);
      if (desc !== void 0 && featureSet.has(desc)) {
        feature.default = true;
        featureSet.delete(desc);
        continue;
      }
      if (featureSet.has(feature.name)) {
        featureSet.delete(feature.name);
        feature.default = true;
        continue;
      }
      feature.default = void 0;
    }
    if (featureSet.size) {
      throw new SchemaImplementationError(
        this,
        `Cannot set unknown feature${featureSet.size > 1 ? "s" : ""} ${describeList("and", ...featureSet)}`
      );
    }
  }
  get effectiveMetatype() {
    return Metatype.object;
  }
  get effectiveAccess() {
    return Access.Default;
  }
  constructor(definition, ...children) {
    super(definition, ...children);
    this.#quality = Quality.create(definition.quality);
    if (!(definition instanceof Model)) {
      this.pics = definition.pics;
      this.classification = definition.classification;
    }
  }
  toElement(omitResources = false, extra) {
    return super.toElement(omitResources, {
      quality: this.quality.valueOf(),
      ...extra
    });
  }
  static Tag = ClusterElement.Tag;
}
ClusterModel.register();
export {
  ClusterModel
};
//# sourceMappingURL=ClusterModel.js.map
