/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { camelize, decamelize, ImplementationError } from "#general";
import { ElementTag, Metatype } from "../common/index.js";
import { ModelTraversal } from "../logic/ModelTraversal.js";
import { Children } from "./Children.js";
import { Resource, ResourceBundle } from "./Resource.js";
const inspect = Symbol.for("nodejs.util.inspect.custom");
class StructuralModelError extends ImplementationError {
}
class Model {
  type;
  isSeed;
  #id;
  #name;
  #frozen;
  #resource;
  /**
   * Indicates that an element defines a datatype.
   */
  isType;
  /**
   * Normally {@link base} performs lookup based on {@link type}.  Setting this field short circuits this resolution.
   *
   * The operational base also enables resolution from the operational base's tree.  This enables resolution on
   * operational models that are not installed in a parent hierarchy.
   *
   * We set the operational base when freezing the model.
   */
  operationalBase;
  /**
   * This is like {@link operationalBase} except for the element's shadow.
   */
  operationalShadow;
  #children;
  #parent;
  #root;
  get id() {
    return this.#id;
  }
  set id(value) {
    const oldId = this.effectiveId;
    this.#id = value;
    (this.#parent?.children).updateId(this, oldId);
  }
  get name() {
    return this.#name;
  }
  set name(value) {
    const oldName = this.#name;
    this.#name = value;
    (this.#parent?.children).updateName(this, oldName);
  }
  /**
   * Did validation find errors?
   */
  get valid() {
    return !this.errors;
  }
  /**
   * The path ("." delimited) in the Matter tree.
   *
   * This is informational and generally tries to adhere to JS API conventions.
   */
  get path() {
    if (this.parent && this.parent.tag !== ElementTag.Matter) {
      if (this.parent.tag === ElementTag.Field) {
        return `${this.parent.path}.${camelize(this.name)}`;
      }
      if (this.parent.tag === ElementTag.Cluster) {
        switch (this.tag) {
          case ElementTag.Attribute:
            return `${this.parent.path}.state.${camelize(this.name, false)}`;
          case ElementTag.Command:
            return `${this.parent.path}.${camelize(this.name, false)}`;
          case ElementTag.Event:
            return `${this.parent.path}.events.${camelize(this.name, false)}`;
        }
      }
      const parent = this.parent;
      if (parent.tag !== ElementTag.Cluster) {
        const parentMetatype = parent?.effectiveMetatype;
        if (parentMetatype === Metatype.object || parentMetatype === Metatype.array) {
          return `${parent.path}.${camelize(this.name, false)}`;
        }
      }
      return `${parent.path}.${this.name}`;
    } else {
      return this.name;
    }
  }
  /**
   * Determine if this model resides in the global namespace.
   */
  get isGlobal() {
    return this.tag === "matter" || this.parent?.tag === "matter";
  }
  /**
   * The structural parent.  This is the model for the element that contains this element's definition.
   */
  get parent() {
    return this.#parent;
  }
  /**
   * The structural root.  This is the MatterModel that owns this model.
   */
  get root() {
    return this.#root;
  }
  set parent(parent) {
    if (this.parent === parent) {
      return;
    }
    if (this.parent) {
      const index = this.parent.children.indexOf(this);
      if (index !== -1) {
        this.parent.children.splice(index, 1);
      }
    }
    if (parent) {
      parent.children.push(this);
    }
  }
  /**
   * Allows subclasses to pull a working ID from an alternate source.
   */
  get effectiveId() {
    return this.id;
  }
  /**
   * Get a string that uniquely identifies this model.  This is normally the effective ID but some models require a
   * generated identifier.
   */
  get key() {
    const key = this.effectiveId?.toString();
    if (key === void 0) {
      return key;
    }
    const discriminator = this.discriminator;
    if (discriminator === void 0) {
      return key;
    }
    return `${key}\u241C${discriminator}`;
  }
  /**
   * Obtain a discriminator that differentiates different models with the same name
   */
  get discriminator() {
    return;
  }
  /**
   * Children of models are always models.
   */
  get children() {
    if (!this.#children) {
      this.children = [];
    }
    return this.#children;
  }
  get hasChildren() {
    return !!this.#children?.length;
  }
  /**
   * Set the children of the model.
   */
  set children(children) {
    this.#children = Children(
      children,
      (child) => {
        if (child.#parent === this) {
          return;
        }
        if (child.#parent) {
          const position = child.#parent.children.indexOf(child);
          if (position !== -1) {
            child.#parent.children.splice(position, 1);
          }
        }
        child.#parent = this;
      },
      (child, sharesRoot) => {
        const root = sharesRoot ? this.root : void 0;
        if (child.#root === root) {
          return false;
        }
        child.#root = root;
        return true;
      },
      (child) => {
        if (child.#parent === this) {
          child.#parent = void 0;
          return true;
        }
        return false;
      }
    );
  }
  /**
   * Factory support.
   */
  static types = {};
  /**
   * Add a new model implementation.
   */
  static register() {
    Model.types[this.Tag] = this;
  }
  /**
   * All possible tags for registered models of this type.
   */
  static get tags() {
    return Object.values(Model.types).filter((type) => type instanceof this).map((type) => type.Tag);
  }
  /**
   * In some circumstances the base type can be inferred.  This inference happens here.
   *
   * Does not recurse so only returns the direct base type.
   */
  get effectiveType() {
    return this.type;
  }
  /**
   * Get a model for my base type as defined by {@link type}, if any.
   */
  get base() {
    if (this.operationalBase !== void 0) {
      return this.operationalBase ?? void 0;
    }
    return new ModelTraversal().findBase(this);
  }
  /**
   * Get shadow model, if any.  A "shadow" is an element in my parent's inheritance hierarchy that I override.
   */
  get shadow() {
    if (this.operationalShadow !== void 0) {
      return this.operationalShadow ?? void 0;
    }
    return new ModelTraversal().findShadow(this);
  }
  /**
   * Get the first global base type.  This may have semantic meaning more specific than the base primitive type.
   */
  get globalBase() {
    return new ModelTraversal().findGlobalBase(this);
  }
  /**
   * A local or parent xref.
   */
  get effectiveXref() {
    return new ModelTraversal().findXref(this);
  }
  /**
   * The set of tags from which this model may derive.
   */
  get allowedBaseTags() {
    return [this.tag];
  }
  /**
   * Update a subset of fields.
   *
   * Only allows for updates to element properties.  Recurses to children.
   */
  patch(values) {
    for (const [name, value] of Object.entries(values.valueOf())) {
      this[name] = value;
    }
  }
  /**
   * Determine whether this element applies to a specific revision.
   */
  appliesTo(revision) {
    return (this.asOf === void 0 || revision >= this.asOf) && (this.until === void 0 || revision < this.until);
  }
  /**
   * Create a model for an element.
   */
  static create(definition) {
    if (typeof definition !== "object") {
      throw new StructuralModelError(`Model definition must be object, not ${typeof definition}`);
    }
    const t = definition["tag"];
    const constructor = Model.types[t];
    if (!constructor) {
      throw new StructuralModelError(`Unknown element tag "${t}"`);
    }
    return new constructor(definition);
  }
  /**
   * Retrieve all models of a specific element type from local scope.
   *
   * @param type model class or a predicate object
   * @param key filters to models matching a specific type
   */
  all(type, key) {
    return this.children.all(type, key);
  }
  /**
   * Retrieve a specific child by ID or name.
   */
  get(type, key) {
    return this.children.get(type, key);
  }
  /**
   * Retrieve a model of a specific type from the ownership hierarchy.
   */
  owner(constructor) {
    return new ModelTraversal().findOwner(constructor, this);
  }
  /**
   * Record a validation error for this model.
   */
  error(code, message) {
    if (!this.errors) {
      this.errors = [];
    }
    this.errors.push({
      code,
      source: this.path,
      message,
      xref: this.effectiveXref?.toString()
    });
  }
  /**
   * Convert model to JSON.
   */
  toJSON() {
    const fields = this.valueOf();
    if (this.children.length) {
      fields.children = this.children.map((child) => child.toJSON());
    }
    return fields;
  }
  /**
   * Convert to non-class structure.
   */
  valueOf() {
    return this.toElement();
  }
  /**
   * Convert to elemental form.
   */
  toElement(omitResources = false, extra) {
    if (omitResources) {
      return {
        tag: this.tag,
        type: this.type,
        isSeed: this.isSeed,
        id: this.id,
        name: this.name,
        ...extra
      };
    }
    const result = {
      tag: this.tag,
      type: this.type,
      isSeed: this.isSeed,
      id: this.#id,
      name: this.#name,
      ...this.resource,
      ...extra
    };
    delete result.errors;
    return result;
  }
  /**
   * Apply a function to all tree elements.
   */
  visit(visitor) {
    return new ModelTraversal().visit(this, visitor);
  }
  /**
   * Visit this model and each of its ancestors.
   */
  forEachAncestor(fn) {
    new ModelTraversal().visitInheritance(this, fn);
  }
  /**
   * Find all children that reference a specific type.
   */
  references(type) {
    return new ModelTraversal().findReferences(this, type);
  }
  /**
   * Search the inheritance chain for a child property.
   */
  member(key, allowedTags = [ElementTag.Field, ElementTag.Attribute]) {
    return new ModelTraversal().findMember(this, key, allowedTags);
  }
  /**
   * Access a member that must exist.
   */
  require(type, key) {
    let member = this.member(key, [type.Tag]);
    if (member === void 0 && typeof key === "string") {
      member = this.member(camelize(key, true));
    }
    if (member !== void 0) {
      return member;
    }
    let what;
    switch (typeof key) {
      case "string":
        what = `"${key}"`;
        break;
      case "number":
        what = `#${key}"`;
        break;
      default:
        what = `selected`;
    }
    throw new StructuralModelError(`No ${type.Tag} ${what} for ${this.tag} ${this.name}`);
  }
  /**
   * Does this model derive from another?
   */
  instanceOf(other) {
    return new ModelTraversal().instanceOf(this, other);
  }
  /**
   * Clone the model.  This deep copies all descendant child models but not other properties.
   */
  clone() {
    const Type = this.constructor;
    return new Type(this);
  }
  /**
   * Create an operational extension of the model.  This creates a new model that inherits from this model for
   * operational purposes.
   */
  extend(properties, ...children) {
    const constructor = this.constructor;
    const definition = {
      id: this.id,
      name: this.name,
      ...properties,
      tag: this.tag,
      operationalBase: this
    };
    if (children.length) {
      if (definition.children) {
        definition.children = [...definition.children, ...children];
      } else {
        definition.children = children;
      }
    }
    const extension = new constructor(definition);
    return extension;
  }
  constructor(definition, ...children) {
    if (typeof definition !== "object") {
      throw new StructuralModelError(`Model definition must be an object, not ${typeof definition}`);
    }
    const isClone = definition instanceof Model;
    this.#id = definition.id;
    this.#name = definition.name;
    this.type = definition.type;
    this.isSeed = definition.isSeed;
    this.operationalBase = definition.operationalBase;
    this.operationalShadow = definition.operationalShadow;
    if (isClone) {
      if (definition.hasLocalResource) {
        this.resource = definition.resource;
      }
    } else {
      if ("description" in definition || "xref" in definition || "details" in definition || "xref" in definition || "errors" in definition || "asOf" in definition || "until" in definition || "matchTo" in definition) {
        this.resource = new Resource(definition);
      }
    }
    if (isClone) {
      for (const child of definition.children) {
        this.children.push(child.clone());
      }
    } else if (definition.children) {
      this.children.push(...definition.children);
    }
    if (children.length) {
      this.children.push(...children);
    }
  }
  /**
   * Freeze the model hierarchy rooted at this model.
   *
   * When using a model as operational schema we implement various optimizations that assume the schema is immutable.
   * This function enforces that assumption and caches a few values that only make sense with frozen schema.
   *
   * To make changes to a frozen model use {@link clone}.
   */
  freeze() {
    if (this.#frozen) {
      return;
    }
    const base = this.operationalBase ?? (this.operationalBase = this.base ?? null);
    const shadow = this.operationalShadow ?? (this.operationalShadow = this.shadow ?? null);
    this.#frozen = true;
    this.children.freeze();
    Object.freeze(this);
    base?.freeze();
    shadow?.freeze();
  }
  toString() {
    return `${this.tag}${this.type ? `<${this.type}>` : ""}#${this.path}`;
  }
  get resource() {
    return this.#resource || (this.#root?.resources || ResourceBundle.default).get(this);
  }
  set resource(resource) {
    if (resource instanceof Resource) {
      this.#resource = resource;
    } else {
      this.#resource = new Resource(resource);
    }
  }
  get description() {
    return this.resource?.description;
  }
  set description(description) {
    this.localResource.description = description;
  }
  get details() {
    return this.resource?.details;
  }
  set details(details) {
    this.localResource.details = details;
  }
  get xref() {
    return this.resource?.xref;
  }
  set xref(xref) {
    this.localResource.xref = xref;
  }
  get errors() {
    return this.resource?.errors;
  }
  set errors(errors) {
    this.localResource.errors = errors;
  }
  get asOf() {
    return this.resource?.asOf;
  }
  set asOf(asOf) {
    this.localResource.asOf = asOf;
  }
  get until() {
    return this.resource?.until;
  }
  set until(until) {
    this.localResource.until = until;
  }
  get matchTo() {
    return this.resource?.matchTo;
  }
  set matchTo(matchTo) {
    this.localResource.matchTo = matchTo;
  }
  get localResource() {
    return this.resource ?? (this.resource = new Resource());
  }
  get hasLocalResource() {
    return !!(this.#resource || (this.#root?.resources || ResourceBundle.default).get(this));
  }
  [inspect](_depth, options, inspect2) {
    const json = this.valueOf();
    const props = {
      name: json.name
    };
    if (json.id !== void 0) {
      props.id = json.id;
    }
    for (const key in json) {
      if (key === "id" || key === "name" || key === "tag") {
        continue;
      }
      props[key] = json[key];
    }
    if (this.#children !== void 0 && this.#children.length) {
      props.children = this.#children.length;
    }
    if (!inspect2) {
      inspect2 = (value) => `${value}`;
    }
    return `${inspect2(props, options)}`.replace(/^\{/, `${decamelize(this.tag)} {`);
  }
}
Children.installModelConstructor(Model);
export {
  Model,
  StructuralModelError
};
//# sourceMappingURL=Model.js.map
