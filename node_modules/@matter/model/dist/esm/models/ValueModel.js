/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { Scope } from "#logic/Scope.js";
import { Access, Conformance, Constraint, Quality } from "../aspects/index.js";
import { ElementTag, Metatype } from "../common/index.js";
import { ModelTraversal } from "../logic/ModelTraversal.js";
import { Model } from "./Model.js";
class ValueModel extends Model {
  byteSize;
  default;
  metatype;
  isType = true;
  #constraint;
  #conformance;
  #access;
  #quality;
  get constraint() {
    return this.#constraint;
  }
  set constraint(definition) {
    this.#constraint = Constraint.create(definition);
  }
  get effectiveConstraint() {
    return new ModelTraversal().findConstraint(this) || this.constraint;
  }
  get conformance() {
    return this.#conformance;
  }
  set conformance(definition) {
    this.#conformance = Conformance.create(definition);
  }
  get effectiveConformance() {
    return new ModelTraversal().findAspect(this, "conformance", Conformance) ?? this.#conformance;
  }
  get access() {
    return this.#access;
  }
  set access(definition) {
    this.#access = Access.create(definition);
  }
  get effectiveAccess() {
    return new ModelTraversal().findAccess(this, ValueModel);
  }
  get quality() {
    return this.#quality;
  }
  set quality(definition) {
    this.#quality = Quality.create(definition);
  }
  get effectiveQuality() {
    return new ModelTraversal().findAspect(this, "quality", Quality) ?? this.#quality;
  }
  get fields() {
    return Scope(this).membersOf(this, { tags: [ElementTag.Field] });
  }
  /**
   * Metatype is only present on global types with specific semantic meaning. This model is significant because it
   * gives us information about how to manipulate the data.  This accessor retrieves this model.
   */
  get metabase() {
    return new ModelTraversal().findMetabase(this);
  }
  /**
   * Get the primitive type for this value model.  This is an integer type for enums and bitmaps.  Otherwise it's the
   * metabase.
   */
  get primitiveBase() {
    const metabase = this.metabase;
    if (!metabase) {
      return;
    }
    if (metabase.metatype === Metatype.enum) {
      return metabase.base;
    }
    if (metabase.metatype === Metatype.bitmap) {
      const primitiveName = metabase.name.replace("map", "uint");
      return metabase.parent?.children.find((c) => c.name === primitiveName);
    }
    return metabase;
  }
  /**
   * The "effective type" may be inferred from context.
   */
  get effectiveType() {
    const type = super.effectiveType;
    if (type) {
      return type;
    }
    return new ModelTraversal().getTypeName(this);
  }
  /**
   * The working metatype for this object.
   */
  get effectiveMetatype() {
    const metaBase = this.metabase;
    if (metaBase) {
      return metaBase.metatype;
    }
  }
  /**
   * Get the first derived ancestor with children, if any.
   */
  get definingModel() {
    return new ModelTraversal().findDefiningModel(this);
  }
  /**
   * Get the entry type for lists, if any.
   */
  get listEntry() {
    return this.member("entry", [ElementTag.Field]);
  }
  /**
   * ValueModels may only derive from ValueModels.
   */
  get base() {
    return super.base;
  }
  /**
   * ValueModels may derive from models of the same type or from generic Datatype models.
   */
  get allowedBaseTags() {
    if (this.tag === ElementTag.Field) {
      return [ElementTag.Field, ElementTag.Datatype, ElementTag.Attribute];
    }
    return [this.tag, ElementTag.Datatype];
  }
  /**
   * All {@link FieldModel} children in the context of the model's containing scope.
   */
  get members() {
    return Scope(this).membersOf(this);
  }
  /**
   * Collect constraints and conformance for this type and all base types.
   */
  get validationAspects() {
    const aspects = Array();
    new ModelTraversal().visitInheritance(this, (model) => {
      if (model instanceof ValueModel) {
        if (!model.conformance.isEmpty && model.conformance.type !== Conformance.Special.Desc) {
          aspects.push(model.conformance);
        }
        if (!model.constraint.isEmpty && !model.constraint.desc) {
          aspects.push(model.constraint);
        }
        if (model.quality.nullable === false) {
          aspects.push(model.quality);
        }
      }
    });
    return aspects;
  }
  /**
   * Is this model deprecated?
   */
  get isDeprecated() {
    return this.effectiveConformance.type === Conformance.Flag.Deprecated;
  }
  /**
   * Is this model disallowed?
   */
  get isDisallowed() {
    return this.effectiveConformance.type === Conformance.Flag.Disallowed;
  }
  /**
   * Can this model be omitted?
   */
  get nullable() {
    return !!this.effectiveQuality.nullable;
  }
  /**
   * Is the model mandatory?
   */
  get mandatory() {
    return this.effectiveConformance.isMandatory;
  }
  /**
   * Determine whether this element overrides key properties of its shadow.
   */
  get overridesShadow() {
    const shadow = this.shadow;
    if (!shadow || !(shadow instanceof ValueModel)) {
      return;
    }
    if (this.type && this.type !== shadow.type) {
      return true;
    }
    if (!this.conformance.isEmpty && !this.conformance.equals(shadow.conformance)) {
      return true;
    }
    if (!this.quality.isEmpty && !this.quality.equals(shadow.quality)) {
      return true;
    }
    if (!this.constraint.isEmpty && !this.constraint.equals(shadow.constraint)) {
      return true;
    }
    if (!this.access.isEmpty && !this.access.equals(shadow.access)) {
      return true;
    }
  }
  /**
   * Search the inheritance chain for a bitmap field defining a specific bit.
   */
  bitDefinition(bit) {
    return new ModelTraversal().findBitDefinition(this, bit);
  }
  /**
   * Clone the model with minimum metadata required to ensure model is valid.
   */
  cloneAsReference() {
    const Type = this.constructor;
    return new Type(this.requiredFields);
  }
  get requiredFields() {
    return { name: this.name };
  }
  constructor(definition, ...children) {
    super(definition, ...children);
    this.byteSize = definition.byteSize;
    this.default = definition.default;
    this.#constraint = Constraint.create(definition.constraint);
    this.#conformance = Conformance.create(definition.conformance);
    this.#access = Access.create(definition.access);
    this.#quality = Quality.create(definition.quality);
    const match = this.type?.match(/^list\[(.*)\]$/);
    if (match) {
      this.type = "list";
      this.children.push(new Model.types.field({ name: "entry", type: match[1] }));
    }
  }
  toElement(omitResources = false, extra) {
    return super.toElement(omitResources, {
      byteSize: this.byteSize,
      default: this.default,
      constraint: this.#constraint.valueOf(),
      conformance: this.#conformance.valueOf(),
      access: this.#access.valueOf(),
      quality: this.#quality.valueOf(),
      ...extra
    });
  }
}
export {
  ValueModel
};
//# sourceMappingURL=ValueModel.js.map
