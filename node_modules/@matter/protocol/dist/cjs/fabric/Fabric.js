"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var Fabric_exports = {};
__export(Fabric_exports, {
  Fabric: () => Fabric,
  FabricBuilder: () => FabricBuilder,
  PublicKeyError: () => PublicKeyError
});
module.exports = __toCommonJS(Fabric_exports);
var import_Icac = require("#certificate/kinds/Icac.js");
var import_Noc = require("#certificate/kinds/Noc.js");
var import_Rcac = require("#certificate/kinds/Rcac.js");
var import_X509Base = require("#certificate/kinds/X509Base.js");
var import_general = require("#general");
var import_FabricGroups = require("#groups/FabricGroups.js");
var import_FabricAccessControl = require("#interaction/FabricAccessControl.js");
var import_PeerAddress = require("#peer/PeerAddress.js");
var import_types = require("#types");
/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
const logger = import_general.Logger.get("Fabric");
const COMPRESSED_FABRIC_ID_INFO = import_general.Bytes.fromString("CompressedFabric");
class PublicKeyError extends import_general.MatterError {
}
class Fabric {
  #crypto;
  fabricIndex;
  fabricId;
  nodeId;
  rootNodeId;
  operationalId;
  rootPublicKey;
  rootVendorId;
  rootCert;
  identityProtectionKey;
  operationalIdentityProtectionKey;
  intermediateCACert;
  operationalCert;
  #keyPair;
  #sessions = /* @__PURE__ */ new Set();
  #groups;
  #aclManager;
  #label;
  #removeCallbacks = new Array();
  #persistCallback;
  #storage;
  constructor(crypto, config) {
    this.#crypto = crypto;
    this.fabricIndex = config.fabricIndex;
    this.fabricId = config.fabricId;
    this.nodeId = config.nodeId;
    this.rootNodeId = config.rootNodeId;
    this.operationalId = config.operationalId;
    this.rootPublicKey = config.rootPublicKey;
    this.rootVendorId = config.rootVendorId;
    this.rootCert = config.rootCert;
    this.identityProtectionKey = config.identityProtectionKey;
    this.operationalIdentityProtectionKey = config.operationalIdentityProtectionKey;
    this.intermediateCACert = config.intermediateCACert;
    this.operationalCert = config.operationalCert;
    this.#label = config.label;
    this.#keyPair = (0, import_general.PrivateKey)(config.keyPair);
    this.#aclManager = new import_FabricAccessControl.FabricAccessControl(this);
    this.#groups = new import_FabricGroups.FabricGroups(this);
  }
  get crypto() {
    return this.#crypto;
  }
  get config() {
    return {
      fabricIndex: this.fabricIndex,
      fabricId: this.fabricId,
      nodeId: this.nodeId,
      rootNodeId: this.rootNodeId,
      operationalId: this.operationalId,
      rootPublicKey: this.rootPublicKey,
      keyPair: this.#keyPair.keyPair,
      rootVendorId: this.rootVendorId,
      rootCert: this.rootCert,
      identityProtectionKey: this.identityProtectionKey,
      operationalIdentityProtectionKey: this.operationalIdentityProtectionKey,
      intermediateCACert: this.intermediateCACert,
      operationalCert: this.operationalCert,
      label: this.#label
    };
  }
  get label() {
    return this.#label;
  }
  async setLabel(label) {
    if (label.length === 0 || label.length > 32) {
      throw new import_general.ImplementationError("Fabric label must be between 1 and 32 characters long.");
    }
    if (this.#label === label) {
      return;
    }
    this.#label = label;
    await this.persist();
  }
  set storage(storage) {
    this.#storage = storage;
    this.#groups.storage = storage;
  }
  get storage() {
    return this.#storage;
  }
  get groups() {
    return this.#groups;
  }
  get acl() {
    return this.#aclManager;
  }
  get publicKey() {
    return this.#keyPair.publicKey;
  }
  sign(data) {
    return this.crypto.signEcdsa(this.#keyPair, data);
  }
  async verifyCredentials(operationalCert, intermediateCACert) {
    const rootCert = import_Rcac.Rcac.fromTlv(this.rootCert);
    const nocCert = import_Noc.Noc.fromTlv(operationalCert);
    const icaCert = intermediateCACert !== void 0 ? import_Icac.Icac.fromTlv(intermediateCACert) : void 0;
    if (icaCert !== void 0) {
      await icaCert.verify(this.#crypto, rootCert);
    }
    await nocCert.verify(this.#crypto, rootCert, icaCert);
  }
  matchesFabricIdAndRootPublicKey(fabricId, rootPublicKey) {
    return this.fabricId === fabricId && import_general.Bytes.areEqual(this.rootPublicKey, rootPublicKey);
  }
  matchesKeyPair(keyPair) {
    return import_general.Bytes.areEqual(this.#keyPair.publicKey, keyPair.publicKey) && import_general.Bytes.areEqual(this.#keyPair.privateKey, keyPair.privateKey);
  }
  #generateSalt(nodeId, random) {
    const writer = new import_general.DataWriter(import_general.Endian.Little);
    writer.writeByteArray(random);
    writer.writeByteArray(this.rootPublicKey);
    writer.writeUInt64(this.fabricId);
    writer.writeUInt64(nodeId);
    return writer.toByteArray();
  }
  /**
   * Returns the destination IDs for a given nodeId, random value and optional groupId. When groupId is provided, it
   * returns the time-wise valid operational keys for that groupId.
   */
  async currentDestinationIdFor(nodeId, random) {
    return await this.#crypto.signHmac(
      this.groups.keySets.currentKeyForId(0).key,
      this.#generateSalt(nodeId, random)
    );
  }
  /**
   * Returns the destination IDs for a given nodeId, random value and optional groupId. When groupId is provided, it
   * returns all operational keys for that groupId.
   */
  async destinationIdsFor(nodeId, random) {
    const salt = this.#generateSalt(nodeId, random);
    const destinationIds = this.groups.keySets.allKeysForId(0).map(({ key }) => this.#crypto.signHmac(key, salt));
    return await Promise.all(destinationIds);
  }
  addSession(session) {
    this.#sessions.add(session);
  }
  removeSession(session) {
    this.#sessions.delete(session);
  }
  addRemoveCallback(callback) {
    this.#removeCallbacks.push(callback);
  }
  deleteRemoveCallback(callback) {
    const index = this.#removeCallbacks.indexOf(callback);
    if (index >= 0) {
      this.#removeCallbacks.splice(index, 1);
    }
  }
  set persistCallback(callback) {
    this.#persistCallback = callback;
  }
  async remove(currentSessionId) {
    for (const callback of this.#removeCallbacks) {
      await callback();
    }
    for (const session of [...this.#sessions]) {
      await session.destroy(false, session.id === currentSessionId);
    }
  }
  persist(isUpdate = true) {
    return this.#persistCallback?.(isUpdate);
  }
  get externalInformation() {
    return {
      fabricIndex: this.fabricIndex,
      fabricId: this.fabricId,
      nodeId: this.nodeId,
      rootNodeId: this.rootNodeId,
      rootVendorId: this.rootVendorId,
      label: this.#label
    };
  }
  addressOf(nodeId) {
    return (0, import_PeerAddress.PeerAddress)({ fabricIndex: this.fabricIndex, nodeId });
  }
  groupAddressOf(groupId) {
    import_types.GroupId.assertGroupId(groupId);
    return (0, import_PeerAddress.PeerAddress)({ fabricIndex: this.fabricIndex, nodeId: import_types.NodeId.fromGroupId(groupId) });
  }
}
class FabricBuilder {
  #crypto;
  #keyPair;
  #rootVendorId;
  #rootCert;
  #intermediateCACert;
  #operationalCert;
  #fabricId;
  #nodeId;
  #rootNodeId;
  #rootPublicKey;
  #identityProtectionKey;
  #fabricIndex;
  #label = "";
  constructor(crypto, key) {
    this.#crypto = crypto;
    this.#keyPair = key;
  }
  static async create(crypto) {
    return new FabricBuilder(crypto, await crypto.createKeyPair());
  }
  get publicKey() {
    return this.#keyPair.publicKey;
  }
  get fabricIndex() {
    return this.#fabricIndex;
  }
  createCertificateSigningRequest() {
    return import_X509Base.X509Base.createCertificateSigningRequest(this.#crypto, this.#keyPair);
  }
  async setRootCert(rootCert) {
    const root = import_Rcac.Rcac.fromTlv(rootCert);
    await root.verify(this.#crypto);
    this.#rootCert = rootCert;
    this.#rootPublicKey = root.cert.ellipticCurvePublicKey;
    return this;
  }
  get rootCert() {
    return this.#rootCert;
  }
  async setOperationalCert(operationalCert, intermediateCACert) {
    if (intermediateCACert !== void 0 && intermediateCACert.length === 0) {
      intermediateCACert = void 0;
    }
    const {
      subject: { nodeId, fabricId, caseAuthenticatedTags },
      ellipticCurvePublicKey
    } = import_Noc.Noc.fromTlv(operationalCert).cert;
    logger.debug(
      "Installing operational certificate",
      import_general.Diagnostic.dict({ nodeId, fabricId, caseAuthenticatedTags })
    );
    if (caseAuthenticatedTags !== void 0) {
      import_types.CaseAuthenticatedTag.validateNocTagList(caseAuthenticatedTags);
    }
    if (!import_general.Bytes.areEqual(ellipticCurvePublicKey, this.#keyPair.publicKey)) {
      throw new PublicKeyError("Operational certificate does not match public key");
    }
    if (this.#rootCert === void 0) {
      throw new import_general.MatterFlowError("Root certificate needs to be set first");
    }
    const rootCert = import_Rcac.Rcac.fromTlv(this.#rootCert);
    const nocCert = import_Noc.Noc.fromTlv(operationalCert);
    const icaCert = intermediateCACert !== void 0 ? import_Icac.Icac.fromTlv(intermediateCACert) : void 0;
    if (icaCert !== void 0) {
      await icaCert.verify(this.#crypto, rootCert);
    }
    await nocCert.verify(this.#crypto, rootCert, icaCert);
    this.#operationalCert = operationalCert;
    this.#intermediateCACert = intermediateCACert;
    this.#fabricId = (0, import_types.FabricId)(fabricId);
    this.#nodeId = nodeId;
    return this;
  }
  setRootVendorId(rootVendorId) {
    this.#rootVendorId = rootVendorId;
    return this;
  }
  setRootNodeId(rootNodeId) {
    this.#rootNodeId = rootNodeId;
    return this;
  }
  setIdentityProtectionKey(key) {
    this.#identityProtectionKey = key;
    return this;
  }
  setLabel(label) {
    if (label.length === 0 || label.length > 32) {
      throw new import_general.ImplementationError("Fabric label must be between 1 and 32 characters long.");
    }
    this.#label = label;
    return this;
  }
  initializeFromFabricForUpdate(fabric) {
    this.#rootVendorId = fabric.rootVendorId;
    this.#rootNodeId = fabric.rootNodeId;
    this.#identityProtectionKey = fabric.identityProtectionKey;
    this.#rootCert = fabric.rootCert;
    this.#rootPublicKey = fabric.rootPublicKey;
    this.#label = fabric.label;
  }
  matchesToFabric(fabric) {
    if (this.#fabricId === void 0 || this.#rootPublicKey === void 0) {
      throw new import_general.MatterFlowError("Node Operational Data needs to be set first.");
    }
    return fabric.matchesFabricIdAndRootPublicKey(this.#fabricId, this.#rootPublicKey);
  }
  get nodeId() {
    return this.#nodeId;
  }
  get fabricId() {
    return this.#fabricId;
  }
  get keyPair() {
    return this.#keyPair;
  }
  async build(fabricIndex) {
    if (this.#fabricIndex !== void 0) throw new import_general.InternalError("FabricBuilder can only be built once");
    if (this.#rootNodeId === void 0) throw new import_general.InternalError("rootNodeId needs to be set");
    if (this.#rootVendorId === void 0) throw new import_general.InternalError("vendorId needs to be set");
    if (this.#rootCert === void 0 || this.#rootPublicKey === void 0)
      throw new import_general.InternalError("rootCert needs to be set");
    if (this.#identityProtectionKey === void 0) throw new import_general.InternalError("identityProtectionKey needs to be set");
    if (this.#operationalCert === void 0 || this.#fabricId === void 0 || this.#nodeId === void 0)
      throw new import_general.InternalError("operationalCert needs to be set");
    this.#fabricIndex = fabricIndex;
    const saltWriter = new import_general.DataWriter();
    saltWriter.writeUInt64(this.#fabricId);
    const operationalId = await this.#crypto.createHkdfKey(
      this.#rootPublicKey.slice(1),
      saltWriter.toByteArray(),
      COMPRESSED_FABRIC_ID_INFO,
      8
    );
    return new Fabric(this.#crypto, {
      fabricIndex: this.#fabricIndex,
      fabricId: this.#fabricId,
      nodeId: this.#nodeId,
      rootNodeId: this.#rootNodeId,
      operationalId,
      rootPublicKey: this.#rootPublicKey,
      keyPair: this.#keyPair,
      rootVendorId: this.#rootVendorId,
      rootCert: this.#rootCert,
      identityProtectionKey: this.#identityProtectionKey,
      // Epoch Key
      operationalIdentityProtectionKey: await this.#crypto.createHkdfKey(
        this.#identityProtectionKey,
        operationalId,
        import_FabricGroups.GROUP_SECURITY_INFO
      ),
      intermediateCACert: this.#intermediateCACert,
      operationalCert: this.#operationalCert,
      label: this.#label
    });
  }
}
//# sourceMappingURL=Fabric.js.map
