"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var FabricAuthority_exports = {};
__export(FabricAuthority_exports, {
  DEFAULT_ADMIN_VENDOR_ID: () => DEFAULT_ADMIN_VENDOR_ID,
  FabricAuthority: () => FabricAuthority,
  FabricAuthorityConfigurationProvider: () => FabricAuthorityConfigurationProvider
});
module.exports = __toCommonJS(FabricAuthority_exports);
var import_CertificateAuthority = require("#certificate/CertificateAuthority.js");
var import_general = require("#general");
var import_types = require("#types");
var import_Fabric = require("./Fabric.js");
var import_FabricManager = require("./FabricManager.js");
/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
const logger = import_general.Logger.get("FabricAuthority");
class FabricAuthorityConfigurationProvider {
  get adminFabricLabel() {
    throw new import_general.ImplementationError("Admin Fabric Label must be set for FabricAuthorityConfigurationProvider.");
  }
}
const DEFAULT_ADMIN_VENDOR_ID = (0, import_types.VendorId)(65521);
class FabricAuthority {
  #construction;
  #ca;
  #fabrics;
  #config;
  #fabricAdded = new import_general.Observable();
  constructor({ ca, fabrics, config }) {
    this.#ca = ca;
    this.#fabrics = fabrics;
    this.#config = config;
    this.#construction = (0, import_general.Construction)(this, async () => {
      await this.#ca.construction;
      await this.#fabrics.construction;
    });
  }
  get construction() {
    return this.#construction;
  }
  /**
   * Access the certificate authority.
   */
  get ca() {
    return this.#ca;
  }
  /**
   * Obtain the default fabric for this authority.
   */
  async defaultFabric() {
    const fabric = this.fabrics[0];
    if (fabric !== void 0) {
      if (fabric.label !== this.#config.adminFabricLabel) {
        await fabric.setLabel(this.#config.adminFabricLabel);
      }
      return fabric;
    }
    return await this.createFabric();
  }
  /**
   * List all controlled fabrics.
   */
  get fabrics() {
    return Array.from(this.#fabrics).filter(this.hasControlOf.bind(this));
  }
  /**
   * Emits after creating a new fabric.
   */
  get fabricAdded() {
    return this.#fabricAdded;
  }
  /**
   * Determine whether a fabric belongs to this authority.
   */
  hasControlOf(fabric) {
    return import_general.Bytes.areEqual(fabric.rootCert, this.#ca.rootCert);
  }
  /**
   * Create a new fabric under our control.
   */
  async createFabric() {
    const rootNodeId = import_types.NodeId.randomOperationalNodeId(this.#fabrics.crypto);
    const ipkValue = this.#fabrics.crypto.randomBytes(import_general.CRYPTO_SYMMETRIC_KEY_LENGTH);
    let vendorId = this.#config.adminVendorId;
    if (vendorId === void 0) {
      vendorId = DEFAULT_ADMIN_VENDOR_ID;
      logger.warn(`Using test vendor ID 0x${vendorId.toString(16)} for controller fabric`);
    }
    const fabricBuilder = await import_Fabric.FabricBuilder.create(this.#fabrics.crypto);
    await fabricBuilder.setRootCert(this.#ca.rootCert);
    fabricBuilder.setRootNodeId(rootNodeId).setIdentityProtectionKey(ipkValue).setRootVendorId(this.#config.adminVendorId ?? DEFAULT_ADMIN_VENDOR_ID).setLabel(this.#config.adminFabricLabel);
    const fabricId = this.#config.fabricId ?? (0, import_types.FabricId)(this.#fabrics.crypto.randomBigInt(8));
    await fabricBuilder.setOperationalCert(
      await this.#ca.generateNoc(
        fabricBuilder.publicKey,
        fabricId,
        rootNodeId,
        this.#config.caseAuthenticatedTags
      )
    );
    let index = this.#config.fabricIndex;
    if (index === void 0) {
      index = this.#fabrics.allocateFabricIndex();
    } else if (this.#fabrics.findByIndex(index) !== void 0) {
      throw new import_general.ImplementationError(`Cannot allocate controller fabric ${index} because index is in use`);
    }
    const fabric = await fabricBuilder.build(index);
    this.#fabrics.addFabric(fabric);
    logger.debug(`Created new controller fabric ${index}`);
    this.#fabricAdded.emit(fabric);
    return fabric;
  }
  static [import_general.Environmental.create](env) {
    const instance = new FabricAuthority({
      ca: env.get(import_CertificateAuthority.CertificateAuthority),
      fabrics: env.get(import_FabricManager.FabricManager),
      config: env.get(FabricAuthorityConfigurationProvider)
    });
    env.set(FabricAuthority, instance);
    return instance;
  }
}
//# sourceMappingURL=FabricAuthority.js.map
