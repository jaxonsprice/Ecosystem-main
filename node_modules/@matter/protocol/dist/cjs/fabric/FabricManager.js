"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var FabricManager_exports = {};
__export(FabricManager_exports, {
  FabricAction: () => FabricAction,
  FabricManager: () => FabricManager,
  FabricNotFoundError: () => FabricNotFoundError,
  FabricTableFullError: () => FabricTableFullError
});
module.exports = __toCommonJS(FabricManager_exports);
var import_general = require("#general");
var import_types = require("#types");
var import_Fabric = require("./Fabric.js");
/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
class FabricNotFoundError extends import_general.MatterError {
}
class FabricTableFullError extends import_general.MatterError {
}
var FabricAction = /* @__PURE__ */ ((FabricAction2) => {
  FabricAction2[FabricAction2["Added"] = 0] = "Added";
  FabricAction2[FabricAction2["Removed"] = 1] = "Removed";
  FabricAction2[FabricAction2["Updated"] = 2] = "Updated";
  return FabricAction2;
})(FabricAction || {});
class FabricManager {
  #crypto;
  #nextFabricIndex = 1;
  #fabrics = /* @__PURE__ */ new Map();
  #initializationDone = false;
  #storage;
  #events = {
    added: (0, import_general.Observable)(),
    updated: (0, import_general.Observable)(),
    deleted: (0, import_general.Observable)(),
    failsafeClosed: (0, import_general.Observable)()
  };
  #construction;
  constructor(crypto, storage) {
    this.#crypto = crypto;
    this.#storage = storage;
    let construct;
    if (this.#storage === void 0) {
      construct = () => {
      };
    } else {
      construct = async () => {
        if (this.#storage === void 0) {
          return;
        }
        const fabrics = await this.#storage.get("fabrics", []);
        for (const fabricConfig of fabrics) {
          this.#addFabric(new import_Fabric.Fabric(crypto, fabricConfig));
        }
        this.#nextFabricIndex = await this.#storage.get("nextFabricIndex", this.#nextFabricIndex);
        this.#initializationDone = true;
      };
    }
    this.#construction = (0, import_general.Construction)(this, construct);
  }
  get crypto() {
    return this.#crypto;
  }
  get construction() {
    return this.#construction;
  }
  async [import_general.Construction.construct]() {
    await this.construction;
  }
  static [import_general.Environmental.create](env) {
    const instance = new FabricManager(env.get(import_general.Crypto), env.get(import_general.StorageManager).createContext("fabrics"));
    env.set(FabricManager, instance);
    return instance;
  }
  get events() {
    return this.#events;
  }
  async clear() {
    await this.#construction;
    this.#nextFabricIndex = 1;
    this.#fabrics.clear();
    await this.#storage?.clear();
  }
  has(address) {
    if (typeof address === "object") {
      address = address.fabricIndex;
    }
    return this.#fabrics.has(address);
  }
  for(address) {
    if (typeof address === "object") {
      address = address.fabricIndex;
    }
    const fabric = this.#fabrics.get(address);
    if (fabric === void 0) {
      throw new FabricNotFoundError(`Cannot access fabric for unknown index ${address}`);
    }
    return fabric;
  }
  allocateFabricIndex() {
    this.#construction.assert();
    for (let i = 0; i < 254; i++) {
      const fabricIndex = this.#nextFabricIndex++;
      if (this.#nextFabricIndex > 254) this.#nextFabricIndex = 1;
      if (!this.#fabrics.has((0, import_types.FabricIndex)(fabricIndex))) {
        return (0, import_types.FabricIndex)(fabricIndex);
      }
    }
    throw new FabricTableFullError("No free fabric index available.");
  }
  persistFabrics() {
    if (this.#storage === void 0) {
      throw new import_general.ImplementationError(
        "Fabric persistence is disabled because FabricManager constructed without storage"
      );
    }
    this.#construction.assert();
    const storeResult = this.#storage.set(
      "fabrics",
      Array.from(this.#fabrics.values()).map((fabric) => fabric.config)
    );
    if (import_general.MaybePromise.is(storeResult)) {
      return storeResult.then(() => this.#storage.set("nextFabricIndex", this.#nextFabricIndex));
    }
    return this.#storage.set("nextFabricIndex", this.#nextFabricIndex);
  }
  addFabric(fabric) {
    this.#construction.assert();
    this.#addFabric(fabric);
  }
  #addFabric(fabric) {
    const { fabricIndex } = fabric;
    if (this.#fabrics.has(fabricIndex)) {
      throw new import_general.MatterFlowError(`Fabric with index ${fabricIndex} already exists.`);
    }
    this.#fabrics.set(fabricIndex, fabric);
    fabric.addRemoveCallback(async () => this.removeFabric(fabricIndex));
    fabric.persistCallback = (isUpdate = true) => {
      if (!this.#storage) {
        return;
      }
      const persistResult = this.persistFabrics();
      return import_general.MaybePromise.then(persistResult, () => {
        if (isUpdate) {
          this.#events.updated.emit(fabric);
        }
      });
    };
    if (this.#storage !== void 0) {
      fabric.storage = this.#storage.createContext(`fabric-${fabricIndex}`);
    }
    if (this.#initializationDone) {
      this.#events.added.emit(fabric);
    }
  }
  async removeFabric(fabricIndex) {
    await this.#construction;
    const fabric = this.#fabrics.get(fabricIndex);
    if (fabric === void 0)
      throw new FabricNotFoundError(
        `Fabric with index ${fabricIndex} cannot be removed because it does not exist.`
      );
    this.#fabrics.delete(fabricIndex);
    if (this.#storage) {
      await this.persistFabrics();
    }
    await fabric.storage?.clearAll();
    this.#events.deleted.emit(fabric);
  }
  [Symbol.iterator]() {
    this.#construction.assert();
    return this.#fabrics.values();
  }
  get fabrics() {
    this.#construction.assert();
    return Array.from(this.#fabrics.values());
  }
  get length() {
    return this.fabrics.length;
  }
  find(predicate) {
    return this.fabrics.find(predicate);
  }
  map(translator) {
    return this.fabrics.map(translator);
  }
  async findFabricFromDestinationId(destinationId, initiatorRandom) {
    this.#construction.assert();
    for (const fabric of this.#fabrics.values()) {
      const candidateDestinationIds = await fabric.destinationIdsFor(fabric.nodeId, initiatorRandom);
      if (candidateDestinationIds.some((candidate) => import_general.Bytes.areEqual(candidate, destinationId))) {
        return fabric;
      }
    }
    throw new FabricNotFoundError();
  }
  findByKeypair(keypair) {
    this.#construction.assert();
    for (const fabric of this.#fabrics.values()) {
      if (fabric.matchesKeyPair(keypair)) {
        return fabric;
      }
    }
    return void 0;
  }
  findByIndex(index) {
    this.#construction.assert();
    return this.#fabrics.get(index);
  }
  async updateFabric(fabric) {
    await this.#construction;
    const { fabricIndex } = fabric;
    if (!this.#fabrics.has(fabricIndex)) {
      throw new FabricNotFoundError(
        `Fabric with index ${fabricIndex} cannot be updated because it does not exist.`
      );
    }
    this.#fabrics.set(fabricIndex, fabric);
    if (this.#storage) {
      await this.persistFabrics();
    }
    this.#events.updated.emit(fabric);
  }
  async revokeFabric(fabricIndex) {
    await this.#construction;
    const fabric = this.#fabrics.get(fabricIndex);
    if (fabric === void 0) {
      throw new import_general.MatterFlowError(`Fabric with index ${fabricIndex} does not exist to revoke.`);
    }
    await fabric.remove();
  }
}
//# sourceMappingURL=FabricManager.js.map
