/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { Construction, MaybePromise, Observable } from "#general";
import { EventNumber, EventPriority, FabricIndex, TlvEventFilter, TlvEventPath, TypeFromSchema } from "#types";
import { EventStore } from "./EventStore.js";
import { NumberedOccurrence, Occurrence } from "./Occurrence.js";
export interface OccurrenceManagerContext {
    store: EventStore;
    bufferConfig?: OccurrenceManager.BufferConfig;
}
/**
 * Manages event occurrences.
 *
 * Each time an event is triggered it is stored as an {@link Occurrence} in this manager.  Occurrences are persisted in
 * an {@link EventStore} and may be retrieved using Matter query semantics.
 *
 * Drops occurrences when the store becomes too full as configured by {@link OccurrenceManager.BufferConfig}.
 *
 * TODO - query is extremely inefficient.  For new code paths should build internal index and bypass EventServer to
 * deliver query in wire form directly here
 */
export declare class OccurrenceManager {
    #private;
    get construction(): Construction<OccurrenceManager>;
    static create(context: OccurrenceManagerContext): Promise<OccurrenceManager>;
    constructor({ store, bufferConfig }: OccurrenceManagerContext);
    get added(): Observable<[occurrence: NumberedOccurrence], void>;
    clear(): Promise<void>;
    /**
     * Query the event store for events matching the given path and filters.
     * @deprecated
     */
    query(eventPath: TypeFromSchema<typeof TlvEventPath>, filters?: TypeFromSchema<typeof TlvEventFilter>[], filterForFabricIndex?: FabricIndex): MaybePromise<NumberedOccurrence[]>;
    /**
     * Return an iterator over all occurrences in the store that are bigger or equal to the minimum eventNumber,
     * if provided.
     */
    get(eventMin?: EventNumber): AsyncGenerator<{
        number: EventNumber;
        endpointId: import("#types").EndpointNumber;
        clusterId: import("#types").ClusterId;
        eventId: import("#types").EventId;
        epochTimestamp: number;
        priority: EventPriority;
        payload: unknown;
    }, void, unknown>;
    close(): MaybePromise<void>;
    add(occurrence: Occurrence): MaybePromise<NumberedOccurrence>;
    remove(number: EventNumber): MaybePromise<void>;
}
export declare namespace OccurrenceManager {
    /**
     * Buffer management configuration.  Controls
     */
    interface BufferConfig {
        /**
         * The minimum number of events that will be buffered.
         */
        minEventAllowance: number;
        /**
         * The maximum number of events that will be buffered.
         *
         * When the buffer hits this size the manager discard events to reduce the buffer size to
         * {@link minimumEventAllowance}.
         */
        maxEventAllowance: number;
        /**
         * Minimum allowances by priority.  This ensures a minimum number of non-critical events avoid LRU
         * harvesting. Critical events take the rest of the entries up to the defined global minimum.
         */
        minPriorityEventAllowance: {
            info: number;
            debug: number;
        };
    }
    const DefaultBufferConfig: BufferConfig;
}
//# sourceMappingURL=OccurrenceManager.d.ts.map