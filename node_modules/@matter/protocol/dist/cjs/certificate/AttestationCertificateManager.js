"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var AttestationCertificateManager_exports = {};
__export(AttestationCertificateManager_exports, {
  AttestationCertificateManager: () => AttestationCertificateManager
});
module.exports = __toCommonJS(AttestationCertificateManager_exports);
var import_general = require("#general");
var import_ChipPAAuthorities = require("./ChipPAAuthorities.js");
var import_AttestationCertificates = require("./kinds/AttestationCertificates.js");
var import_asn = require("./kinds/definitions/asn.js");
/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
function getPaiCommonName(vendorId, productId) {
  return `node-matter Dev PAI 0x${vendorId.toString(16).toUpperCase()} ${productId === void 0 ? "no PID" : `0x${productId.toString(16).toUpperCase()}`}`;
}
function getDacCommonName(vendorId, productId) {
  return `node-matter Dev DAC 0x${vendorId.toString(16).toUpperCase()}/0x${productId.toString(16).toUpperCase()}`;
}
function getPaaCommonName() {
  return "Matter Test PAA";
}
class AttestationCertificateManager {
  paaCertId = BigInt(0);
  // We use the official PAA cert for now because else pairing with Chip tool do not work because
  // only this one is the Certificate store
  #paaKeyPair = (0, import_general.PrivateKey)(import_ChipPAAuthorities.TestCert_PAA_NoVID_PrivateKey, {
    publicKey: import_ChipPAAuthorities.TestCert_PAA_NoVID_PublicKey
  });
  #crypto;
  #vendorId;
  #paiKeyPair;
  #paiKeyIdentifier;
  #paaKeyIdentifier = import_ChipPAAuthorities.TestCert_PAA_NoVID_SKID;
  #paiCertId = BigInt(1);
  #paiCertBytes;
  #nextCertificateId = 2;
  constructor(crypto, vendorId, paiKeyPair, paiKeyIdentifier) {
    this.#crypto = crypto;
    this.#vendorId = vendorId;
    this.#paiKeyPair = paiKeyPair;
    this.#paiKeyIdentifier = paiKeyIdentifier;
    this.#paiCertBytes = this.generatePAICert(vendorId);
  }
  static async create(crypto, vendorId) {
    const key = await crypto.createKeyPair();
    const identifier = await crypto.computeSha256(key.publicKey);
    return new AttestationCertificateManager(crypto, vendorId, key, identifier.slice(0, 20));
  }
  getPAICert() {
    return this.#paiCertBytes;
  }
  async getDACert(productId) {
    const dacKeyPair = await this.#crypto.createKeyPair();
    return {
      keyPair: dacKeyPair,
      dac: await this.generateDaCert(dacKeyPair.publicKey, this.#vendorId, productId)
    };
  }
  // Method unused for now because we use the official Matter Test PAA, but is functional
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  async generatePAACert(vendorId) {
    const now = import_general.Time.get().now();
    const cert = new import_AttestationCertificates.Paa({
      serialNumber: import_general.Bytes.fromHex((0, import_general.toHex)(this.paaCertId)),
      signatureAlgorithm: 1,
      publicKeyAlgorithm: 1,
      ellipticCurveIdentifier: 1,
      issuer: {
        commonName: getPaaCommonName(),
        vendorId
      },
      notBefore: (0, import_asn.jsToMatterDate)(now, -1),
      notAfter: (0, import_asn.jsToMatterDate)(now, 10),
      subject: {
        commonName: getPaaCommonName(),
        vendorId
      },
      ellipticCurvePublicKey: this.#paaKeyPair.publicKey,
      extensions: {
        basicConstraints: {
          isCa: true,
          pathLen: 1
        },
        keyUsage: {
          keyCertSign: true,
          cRLSign: true
        },
        subjectKeyIdentifier: this.#paaKeyIdentifier,
        authorityKeyIdentifier: this.#paaKeyIdentifier
      }
    });
    await cert.sign(this.#crypto, this.#paaKeyPair);
    return cert.asSignedAsn1();
  }
  async generatePAICert(vendorId, productId) {
    const now = import_general.Time.get().now();
    const cert = new import_AttestationCertificates.Pai({
      serialNumber: import_general.Bytes.fromHex((0, import_general.toHex)(this.#paiCertId)),
      signatureAlgorithm: 1,
      publicKeyAlgorithm: 1,
      ellipticCurveIdentifier: 1,
      issuer: {
        commonName: getPaaCommonName()
      },
      notBefore: (0, import_asn.jsToMatterDate)(now, -1),
      notAfter: (0, import_asn.jsToMatterDate)(now, 10),
      subject: {
        commonName: getPaiCommonName(vendorId, productId),
        vendorId,
        productId
      },
      ellipticCurvePublicKey: this.#paiKeyPair.publicKey,
      extensions: {
        basicConstraints: {
          isCa: true,
          pathLen: 0
        },
        keyUsage: {
          keyCertSign: true,
          cRLSign: true
        },
        subjectKeyIdentifier: this.#paiKeyIdentifier,
        authorityKeyIdentifier: this.#paaKeyIdentifier
      }
    });
    await cert.sign(this.#crypto, this.#paaKeyPair);
    return cert.asSignedAsn1();
  }
  async generateDaCert(publicKey, vendorId, productId) {
    const now = import_general.Time.get().now();
    const certId = this.#nextCertificateId++;
    const cert = new import_AttestationCertificates.Dac({
      serialNumber: import_general.Bytes.fromHex((0, import_general.toHex)(certId)),
      signatureAlgorithm: 1,
      publicKeyAlgorithm: 1,
      ellipticCurveIdentifier: 1,
      notBefore: (0, import_asn.jsToMatterDate)(now, -1),
      notAfter: (0, import_asn.jsToMatterDate)(now, 10),
      issuer: {
        commonName: getPaiCommonName(vendorId),
        vendorId
      },
      subject: {
        commonName: getDacCommonName(vendorId, productId),
        vendorId,
        productId
      },
      ellipticCurvePublicKey: publicKey,
      extensions: {
        basicConstraints: {
          isCa: false
        },
        keyUsage: {
          digitalSignature: true
        },
        subjectKeyIdentifier: (await this.#crypto.computeSha256(publicKey)).slice(0, 20),
        authorityKeyIdentifier: this.#paiKeyIdentifier
      }
    });
    await cert.sign(this.#crypto, this.#paiKeyPair);
    return cert.asSignedAsn1();
  }
}
//# sourceMappingURL=AttestationCertificateManager.js.map
