"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var Noc_exports = {};
__export(Noc_exports, {
  Noc: () => Noc
});
module.exports = __toCommonJS(Noc_exports);
var import_general = require("#general");
var import_types = require("#types");
var import_common = require("./common.js");
var import_operational = require("./definitions/operational.js");
var import_OperationalBase = require("./OperationalBase.js");
/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
class Noc extends import_OperationalBase.OperationalBase {
  /** Construct the class from a Tlv version of the certificate */
  static fromTlv(tlv) {
    return new Noc(import_operational.OperationalCertificate.TlvNoc.decode(tlv));
  }
  /** Validates all basic certificate fields on construction. */
  validateFields() {
    const {
      issuer: { icacId, rcacId },
      extensions: {
        basicConstraints: { isCa }
      }
    } = this.cert;
    if (icacId === void 0 && rcacId === void 0) {
      throw new import_common.CertificateError("Issuer RCAC or ICAC ID must be defined for an operational certificate.");
    }
    if (isCa) {
      throw new import_common.CertificateError("Node operational certificate must not be a CA.");
    }
  }
  /**
   * Encodes the certificate with the signature as Matter Tlv.
   * If the certificate is not signed, it throws a CertificateError.
   */
  asSignedTlv() {
    return import_operational.OperationalCertificate.TlvNoc.encode({ ...this.cert, signature: this.signature });
  }
  /**
   * Verify requirements a Matter Node Operational certificate must fulfill.
   * Rules for this are listed in @see {@link MatterSpecification.v12.Core} ยง6.5.x
   */
  async verify(crypto, root, ica) {
    this.generalVerify();
    const {
      subject,
      extensions: { extendedKeyUsage, subjectKeyIdentifier, authorityKeyIdentifier }
    } = this.cert;
    const { nodeId, fabricId, caseAuthenticatedTags } = subject;
    const {
      subject: { fabricId: rootFabricId }
    } = root.cert;
    const {
      subject: { fabricId: icaFabricId }
    } = ica?.cert ?? { subject: {} };
    if (nodeId === void 0 || Array.isArray(nodeId)) {
      throw new import_common.CertificateError(`Invalid nodeId in NoC certificate: ${import_general.Diagnostic.json(nodeId)}`);
    }
    if (!import_types.NodeId.isOperationalNodeId(nodeId)) {
      throw new import_common.CertificateError(`Invalid nodeId in NoC certificate: ${import_general.Diagnostic.json(nodeId)}`);
    }
    if (fabricId === void 0 || Array.isArray(fabricId)) {
      throw new import_common.CertificateError(`Invalid fabricId in NoC certificate: ${import_general.Diagnostic.json(fabricId)}`);
    }
    if (fabricId === (0, import_types.FabricId)(0)) {
      throw new import_common.CertificateError(`Invalid fabricId in NoC certificate: ${import_general.Diagnostic.json(fabricId)}`);
    }
    if ("icacId" in subject) {
      throw new import_common.CertificateError(`Noc certificate must not contain an icacId.`);
    }
    if ("rcacId" in subject) {
      throw new import_common.CertificateError(`Noc certificate must not contain an rcacId.`);
    }
    if (caseAuthenticatedTags !== void 0) {
      import_types.CaseAuthenticatedTag.validateNocTagList(caseAuthenticatedTags);
    }
    if (rootFabricId !== void 0 && rootFabricId !== fabricId) {
      throw new import_common.CertificateError(
        `FabricId in NoC certificate does not match the fabricId in the parent certificate. ${import_general.Diagnostic.json(
          rootFabricId
        )} !== ${import_general.Diagnostic.json(fabricId)}`
      );
    }
    if (icaFabricId !== void 0 && icaFabricId !== fabricId) {
      throw new import_common.CertificateError(
        `FabricId in NoC certificate does not match the fabricId in the parent certificate. ${import_general.Diagnostic.json(
          icaFabricId
        )} !== ${import_general.Diagnostic.json(fabricId)}`
      );
    }
    if (this.cert.extensions.basicConstraints.isCa) {
      throw new import_common.CertificateError(`Noc certificate must not have isCa set to true.`);
    }
    if (!this.cert.extensions.keyUsage.digitalSignature) {
      throw new import_common.CertificateError(`Noc certificate must have keyUsage set to digitalSignature.`);
    }
    if (extendedKeyUsage === void 0 || !extendedKeyUsage.includes(1) && !extendedKeyUsage.includes(2)) {
      throw new import_common.CertificateError(
        `Noc certificate must have extendedKeyUsage with serverAuth and clientAuth: ${import_general.Diagnostic.json(extendedKeyUsage)}`
      );
    }
    if (subjectKeyIdentifier === void 0) {
      throw new import_common.CertificateError(`Noc certificate must have subjectKeyIdentifier set.`);
    }
    if (subjectKeyIdentifier.length !== 20) {
      throw new import_common.CertificateError(`Noc certificate subjectKeyIdentifier must be 160 bit.`);
    }
    if (authorityKeyIdentifier === void 0) {
      throw new import_common.CertificateError(`Noc certificate must have authorityKeyIdentifier set.`);
    }
    if (authorityKeyIdentifier.length !== 20) {
      throw new import_common.CertificateError(`Noc certificate authorityKeyIdentifier must be 160 bit.`);
    }
    if (!import_general.Bytes.areEqual(authorityKeyIdentifier, (ica?.cert ?? root.cert).extensions.subjectKeyIdentifier)) {
      throw new import_common.CertificateError(
        `Noc certificate authorityKeyIdentifier must be equal to Root/Ica subjectKeyIdentifier.`
      );
    }
    await crypto.verifyEcdsa(
      (0, import_general.PublicKey)((ica?.cert ?? root.cert).ellipticCurvePublicKey),
      this.asUnsignedAsn1(),
      this.signature
    );
  }
}
//# sourceMappingURL=Noc.js.map
