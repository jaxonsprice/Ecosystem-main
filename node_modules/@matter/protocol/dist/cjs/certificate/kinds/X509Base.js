"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var X509Base_exports = {};
__export(X509Base_exports, {
  X509Base: () => X509Base
});
module.exports = __toCommonJS(X509Base_exports);
var import_general = require("#general");
var import_types = require("#types");
var import_common = require("./common.js");
var import_asn = require("./definitions/asn.js");
var import_base = require("./definitions/base.js");
/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
class X509Base {
  #signature;
  #cert;
  constructor(cert) {
    this.#cert = cert;
    if ("signature" in cert) {
      this.#signature = cert.signature;
    }
  }
  get cert() {
    return this.#cert;
  }
  get isSigned() {
    return this.#signature !== void 0;
  }
  /**
   * Get the signature of the certificate.
   * If the certificate is not signed, it throws a CertificateError.
   */
  get signature() {
    if (this.#signature === void 0) {
      throw new import_common.CertificateError("Certificate is not signed");
    }
    return this.#signature;
  }
  /**
   * Set the signature of the certificate.
   * If the certificate is already signed, it throws a CertificateError.
   */
  set signature(signature) {
    if (this.isSigned) {
      throw new import_common.CertificateError("Certificate is already signed");
    }
    this.#signature = signature;
  }
  /**
   * Sign the certificate using the provided crypto and key.
   * It throws a CertificateError if the certificate is already signed.
   */
  async sign(crypto, key) {
    this.signature = await crypto.signEcdsa(key, this.asUnsignedAsn1());
  }
  /**
   * Convert the certificate to ASN.1 DER format without signature.
   */
  asUnsignedAsn1() {
    const certBytes = import_general.DerCodec.encode(this.genericBuildAsn1Structure(this.cert));
    (0, import_common.assertCertificateDerSize)(certBytes);
    return certBytes;
  }
  /**
   * Convert the subject or issuer field of the certificate to ASN.1 DER format.
   * Preserve order of keys from original subject and also copy potential custom elements
   */
  #subjectOrIssuerToAsn1(data) {
    const asn = {};
    Object.entries(data).forEach(([key, value]) => {
      if (value === void 0) {
        return;
      }
      switch (key) {
        case "commonName":
          asn.commonName = import_general.X520.CommonName(value);
          break;
        case "sureName":
          asn.sureName = import_general.X520.SurName(value);
          break;
        case "serialNum":
          asn.serialNum = import_general.X520.SerialNumber(value);
          break;
        case "countryName":
          asn.countryName = import_general.X520.CountryName(value);
          break;
        case "localityName":
          asn.localityName = import_general.X520.LocalityName(value);
          break;
        case "stateOrProvinceName":
          asn.stateOrProvinceName = import_general.X520.StateOrProvinceName(value);
          break;
        case "orgName":
          asn.orgName = import_general.X520.OrganisationName(value);
          break;
        case "orgUnitName":
          asn.orgUnitName = import_general.X520.OrganizationalUnitName(value);
          break;
        case "title":
          asn.title = import_general.X520.Title(value);
          break;
        case "name":
          asn.name = import_general.X520.Name(value);
          break;
        case "givenName":
          asn.givenName = import_general.X520.GivenName(value);
          break;
        case "initials":
          asn.initials = import_general.X520.Initials(value);
          break;
        case "genQualifier":
          asn.genQualifier = import_general.X520.GenerationQualifier(value);
          break;
        case "dnQualifier":
          asn.dnQualifier = import_general.X520.DnQualifier(value);
          break;
        case "pseudonym":
          asn.pseudonym = import_general.X520.Pseudonym(value);
          break;
        case "domainComponent":
          asn.domainComponent = import_general.X520.DomainComponent(value);
          break;
        case "nodeId":
          asn.nodeId = (0, import_asn.NodeId_Matter)(value);
          break;
        case "firmwareSigningId":
          asn.firmwareSigningId = (0, import_asn.FirmwareSigningId_Matter)(value);
          break;
        case "icacId":
          asn.icacId = (0, import_asn.IcacId_Matter)(value);
          break;
        case "rcacId":
          asn.rcacId = (0, import_asn.RcacId_Matter)(value);
          break;
        case "fabricId":
          asn.fabricId = (0, import_asn.FabricId_Matter)(value);
          break;
        case "caseAuthenticatedTags":
          const caseAuthenticatedTags = value;
          import_types.CaseAuthenticatedTag.validateNocTagList(caseAuthenticatedTags);
          const cat0 = caseAuthenticatedTags[0];
          const cat1 = caseAuthenticatedTags[1];
          const cat2 = caseAuthenticatedTags[2];
          if (cat0 !== void 0) {
            asn.caseAuthenticatedTag0 = (0, import_asn.NocCat_Matter)(cat0);
          }
          if (cat1 !== void 0) {
            asn.caseAuthenticatedTag1 = (0, import_asn.NocCat_Matter)(cat1);
          }
          if (cat2 !== void 0) {
            asn.caseAuthenticatedTag2 = (0, import_asn.NocCat_Matter)(cat2);
          }
          break;
        case "vendorId":
          asn.vendorId = (0, import_asn.VendorId_Matter)(value);
          break;
        case "productId":
          asn.productId = (0, import_asn.ProductId_Matter)(value);
          break;
        case "commonNamePs":
          asn.commonNamePs = import_general.X520.CommonName(value, true);
          break;
        case "sureNamePs":
          asn.sureNamePs = import_general.X520.SurName(value, true);
          break;
        case "serialNumPs":
          asn.serialNumPs = import_general.X520.SerialNumber(value, true);
          break;
        case "countryNamePs":
          asn.countryNamePs = import_general.X520.CountryName(value, true);
          break;
        case "localityNamePs":
          asn.localityNamePs = import_general.X520.LocalityName(value, true);
          break;
        case "stateOrProvinceNamePs":
          asn.stateOrProvinceNamePs = import_general.X520.StateOrProvinceName(value, true);
          break;
        case "orgNamePs":
          asn.orgNamePs = import_general.X520.OrganisationName(value, true);
          break;
        case "orgUnitNamePs":
          asn.orgUnitNamePs = import_general.X520.OrganizationalUnitName(value, true);
          break;
        case "titlePs":
          asn.titlePs = import_general.X520.Title(value, true);
          break;
        case "namePs":
          asn.namePs = import_general.X520.Name(value, true);
          break;
        case "givenNamePs":
          asn.givenNamePs = import_general.X520.GivenName(value, true);
          break;
        case "initialsPs":
          asn.initialsPs = import_general.X520.Initials(value, true);
          break;
        case "genQualifierPs":
          asn.genQualifierPs = import_general.X520.GenerationQualifier(value, true);
          break;
        case "dnQualifierPs":
          asn.dnQualifierPs = import_general.X520.DnQualifier(value, true);
          break;
        case "pseudonymPs":
          asn.pseudonymPs = import_general.X520.Pseudonym(value, true);
          break;
      }
    });
    return asn;
  }
  /**
   * Convert the extensions of the certificate to ASN.1 DER format.
   */
  #extensionsToAsn1(extensions) {
    const asn = {};
    Object.entries(extensions).forEach(([key, value]) => {
      if (value === void 0) {
        return;
      }
      switch (key) {
        case "basicConstraints":
          asn.basicConstraints = import_general.X509.BasicConstraints(value);
          break;
        case "keyUsage":
          asn.keyUsage = import_general.X509.KeyUsage(
            import_base.ExtensionKeyUsageSchema.encode(
              value
            )
          );
          break;
        case "extendedKeyUsage":
          asn.extendedKeyUsage = import_general.X509.ExtendedKeyUsage(value);
          break;
        case "subjectKeyIdentifier":
          asn.subjectKeyIdentifier = import_general.X509.SubjectKeyIdentifier(value);
          break;
        case "authorityKeyIdentifier":
          asn.authorityKeyIdentifier = import_general.X509.AuthorityKeyIdentifier(value);
          break;
        case "futureExtension":
          asn.futureExtension = (0, import_general.RawBytes)(import_general.Bytes.concat(...value ?? []));
          break;
      }
    });
    return asn;
  }
  /**
   * Build the ASN.1 DER structure for the certificate.
   */
  genericBuildAsn1Structure({
    serialNumber,
    notBefore,
    notAfter,
    issuer,
    subject,
    ellipticCurvePublicKey,
    extensions
  }) {
    const {
      basicConstraints: { isCa, pathLen }
    } = extensions;
    if (!isCa && pathLen !== void 0) {
      throw new import_common.CertificateError("Path length must be undefined for non-CA certificates.");
    }
    return {
      version: (0, import_general.ContextTagged)(0, 2),
      // v3
      serialNumber: (0, import_general.DatatypeOverride)(import_general.DerType.Integer, serialNumber),
      signatureAlgorithm: import_general.X962.EcdsaWithSHA256,
      issuer: this.#subjectOrIssuerToAsn1(issuer),
      validity: {
        notBefore: (0, import_asn.matterToJsDate)(notBefore),
        notAfter: (0, import_asn.matterToJsDate)(notAfter)
      },
      subject: this.#subjectOrIssuerToAsn1(subject),
      publicKey: import_general.X962.PublicKeyEcPrime256v1(ellipticCurvePublicKey),
      extensions: (0, import_general.ContextTagged)(3, this.#extensionsToAsn1(extensions))
    };
  }
  /**
   * Create a Certificate Signing Request (CSR) in ASN.1 DER format.
   */
  static async createCertificateSigningRequest(crypto, key) {
    const request = {
      version: 0,
      subject: { organization: import_general.X520.OrganisationName("CSR") },
      publicKey: import_general.X962.PublicKeyEcPrime256v1(key.publicKey),
      endSignedBytes: (0, import_general.ContextTagged)(0)
    };
    return import_general.DerCodec.encode({
      request,
      signAlgorithm: import_general.X962.EcdsaWithSHA256,
      signature: (0, import_general.DerBitString)(await crypto.signEcdsa(key, import_general.DerCodec.encode(request), "der"))
    });
  }
  /**
   * Extract the public key from a Certificate Signing Request (CSR) in ASN.1 DER format.
   */
  static async getPublicKeyFromCsr(crypto, encodedCsr) {
    const { [import_general.DerKey.Elements]: rootElements } = import_general.DerCodec.decode(encodedCsr);
    if (rootElements?.length !== 3) {
      throw new import_common.CertificateError("Invalid CSR data");
    }
    const [requestNode, signAlgorithmNode, signatureNode] = rootElements;
    const { [import_general.DerKey.Elements]: requestElements } = requestNode;
    if (requestElements?.length !== 4) {
      throw new import_common.CertificateError("Invalid CSR data");
    }
    const [versionNode, subjectNode, publicKeyNode] = requestElements;
    const requestVersionBytes = versionNode[import_general.DerKey.Bytes];
    if (requestVersionBytes.length !== 1 || requestVersionBytes[0] !== 0) {
      throw new import_common.CertificateError(`Unsupported CSR version ${requestVersionBytes[0]}`);
    }
    if (!subjectNode[import_general.DerKey.Elements]?.length) {
      throw new import_common.CertificateError("Missing subject in CSR data");
    }
    const { [import_general.DerKey.Elements]: publicKeyElements } = publicKeyNode;
    if (publicKeyElements?.length !== 2) {
      throw new import_common.CertificateError("Invalid CSR data");
    }
    const [publicKeyTypeNode, publicKeyBytesNode] = publicKeyElements;
    const { [import_general.DerKey.Elements]: publicKeyTypeNodeElements } = publicKeyTypeNode;
    if (publicKeyTypeNodeElements?.length !== 2) {
      throw new import_common.CertificateError("Invalid public key type in CSR");
    }
    if (!import_general.Bytes.areEqual(
      publicKeyTypeNodeElements[0][import_general.DerKey.Bytes],
      import_general.X962.PublicKeyAlgorithmEcPublicKey[import_general.DerKey.Bytes]
    )) {
      throw new import_common.CertificateError("Unsupported public key algorithm in CSR");
    }
    if (!import_general.Bytes.areEqual(
      publicKeyTypeNodeElements[1][import_general.DerKey.Bytes],
      import_general.X962.PublicKeyAlgorithmEcPublicKeyP256[import_general.DerKey.Bytes]
    )) {
      throw new import_common.CertificateError("Unsupported public key curve in CSR");
    }
    const publicKey = publicKeyBytesNode[import_general.DerKey.Bytes];
    const signatureAlgorithmBytes = signAlgorithmNode[import_general.DerKey.Elements]?.[0]?.[import_general.DerKey.Bytes];
    if (signatureAlgorithmBytes === void 0 || !import_general.Bytes.areEqual(import_general.X962.EcdsaWithSHA256[import_general.DerKey.ObjectId][import_general.DerKey.Bytes], signatureAlgorithmBytes)) {
      throw new import_common.CertificateError("Unsupported signature algorithm in CSR");
    }
    await crypto.verifyEcdsa(
      (0, import_general.PublicKey)(publicKey),
      import_general.DerCodec.encode(requestNode),
      signatureNode[import_general.DerKey.Bytes],
      "der"
    );
    return publicKey;
  }
}
//# sourceMappingURL=X509Base.js.map
