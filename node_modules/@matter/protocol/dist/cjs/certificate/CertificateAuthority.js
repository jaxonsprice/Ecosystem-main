"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var CertificateAuthority_exports = {};
__export(CertificateAuthority_exports, {
  CertificateAuthority: () => CertificateAuthority
});
module.exports = __toCommonJS(CertificateAuthority_exports);
var import_general = require("#general");
var import_asn = require("./kinds/definitions/asn.js");
var import_Noc = require("./kinds/Noc.js");
var import_Rcac = require("./kinds/Rcac.js");
/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
const logger = import_general.Logger.get("CertificateAuthority");
class CertificateAuthority {
  #crypto;
  #rootCertId = BigInt(0);
  #rootKeyPair;
  #rootKeyIdentifier;
  #rootCertBytes;
  #nextCertificateId = BigInt(1);
  #construction;
  get crypto() {
    return this.#crypto;
  }
  get construction() {
    return this.#construction;
  }
  static async create(crypto, options) {
    return (0, import_general.asyncNew)(CertificateAuthority, crypto, options);
  }
  constructor(crypto, options) {
    this.#crypto = crypto;
    this.#construction = (0, import_general.Construction)(this, async () => {
      const certValues = options instanceof import_general.StorageContext ? await options.values() : options ?? {};
      this.#rootKeyPair = await this.#crypto.createKeyPair();
      this.#rootKeyIdentifier = (await this.#crypto.computeSha256(this.#rootKeyPair.publicKey)).slice(0, 20);
      this.#rootCertBytes = await this.#generateRootCert();
      if ((typeof certValues.rootCertId === "number" || typeof certValues.rootCertId === "bigint") && (ArrayBuffer.isView(certValues.rootKeyPair) || typeof certValues.rootKeyPair === "object") && ArrayBuffer.isView(certValues.rootKeyIdentifier) && ArrayBuffer.isView(certValues.rootCertBytes) && (typeof certValues.nextCertificateId === "number" || typeof certValues.nextCertificateId === "bigint")) {
        this.#rootCertId = BigInt(certValues.rootCertId);
        this.#rootKeyPair = (0, import_general.PrivateKey)(certValues.rootKeyPair);
        this.#rootKeyIdentifier = certValues.rootKeyIdentifier;
        this.#rootCertBytes = certValues.rootCertBytes;
        this.#nextCertificateId = BigInt(certValues.nextCertificateId);
        logger.info(`Loaded stored credentials with ID ${this.#rootCertId}`);
        return;
      }
      logger.info(`Created new credentials with ID ${this.#rootCertId}`);
      if (options instanceof import_general.StorageContext) {
        await options.set({
          rootCertId: this.#rootCertId,
          rootKeyPair: this.#rootKeyPair.keyPair,
          rootKeyIdentifier: this.#rootKeyIdentifier,
          rootCertBytes: this.#rootCertBytes,
          nextCertificateId: this.#nextCertificateId
        });
      }
    });
  }
  static [import_general.Environmental.create](env) {
    const storage = env.get(import_general.StorageManager).createContext("certificates");
    const instance = new CertificateAuthority(env.get(import_general.Crypto), storage);
    env.set(CertificateAuthority, instance);
    return instance;
  }
  get rootCert() {
    return this.#construction.assert("root cert", this.#rootCertBytes);
  }
  get config() {
    return {
      rootCertId: this.#rootCertId,
      rootKeyPair: this.construction.assert("root key pair", this.#rootKeyPair).keyPair,
      rootKeyIdentifier: this.construction.assert("root key identifier", this.#rootKeyIdentifier),
      rootCertBytes: this.construction.assert("root cert bytes", this.#rootCertBytes),
      nextCertificateId: this.#nextCertificateId
    };
  }
  async #generateRootCert() {
    const now = import_general.Time.get().now();
    const cert = new import_Rcac.Rcac({
      serialNumber: import_general.Bytes.fromHex((0, import_general.toHex)(this.#rootCertId)),
      signatureAlgorithm: 1,
      publicKeyAlgorithm: 1,
      ellipticCurveIdentifier: 1,
      issuer: { rcacId: this.#rootCertId },
      notBefore: (0, import_asn.jsToMatterDate)(now, -1),
      notAfter: (0, import_asn.jsToMatterDate)(now, 10),
      subject: { rcacId: this.#rootCertId },
      ellipticCurvePublicKey: this.#initializedRootKeyPair.publicKey,
      extensions: {
        basicConstraints: { isCa: true },
        keyUsage: {
          keyCertSign: true,
          cRLSign: true
        },
        subjectKeyIdentifier: this.#initializedRootKeyIdentifier,
        authorityKeyIdentifier: this.#initializedRootKeyIdentifier
      }
    });
    await cert.sign(this.#crypto, this.#initializedRootKeyPair);
    return cert.asSignedTlv();
  }
  async generateNoc(publicKey, fabricId, nodeId, caseAuthenticatedTags) {
    const now = import_general.Time.get().now();
    const certId = this.#nextCertificateId++;
    const cert = new import_Noc.Noc({
      serialNumber: import_general.Bytes.fromHex((0, import_general.toHex)(certId)),
      signatureAlgorithm: 1,
      publicKeyAlgorithm: 1,
      ellipticCurveIdentifier: 1,
      issuer: { rcacId: this.#rootCertId },
      notBefore: (0, import_asn.jsToMatterDate)(now, -1),
      notAfter: (0, import_asn.jsToMatterDate)(now, 10),
      subject: { fabricId, nodeId, caseAuthenticatedTags },
      ellipticCurvePublicKey: publicKey,
      extensions: {
        basicConstraints: { isCa: false },
        keyUsage: {
          digitalSignature: true
        },
        extendedKeyUsage: [2, 1],
        subjectKeyIdentifier: (await this.#crypto.computeSha256(publicKey)).slice(0, 20),
        authorityKeyIdentifier: this.#initializedRootKeyIdentifier
      }
    });
    await cert.sign(this.#crypto, this.#initializedRootKeyPair);
    return cert.asSignedTlv();
  }
  get #initializedRootKeyPair() {
    if (this.#rootKeyPair === void 0) {
      throw new import_general.InternalError("CA private key is not installed");
    }
    return this.#rootKeyPair;
  }
  get #initializedRootKeyIdentifier() {
    if (this.#rootKeyIdentifier === void 0) {
      throw new import_general.InternalError("CA key identifier is not installed");
    }
    return this.#rootKeyIdentifier;
  }
}
//# sourceMappingURL=CertificateAuthority.js.map
