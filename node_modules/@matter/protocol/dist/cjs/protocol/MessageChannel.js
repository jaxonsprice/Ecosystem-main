"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var MessageChannel_exports = {};
__export(MessageChannel_exports, {
  ChannelNotConnectedError: () => ChannelNotConnectedError,
  DEFAULT_EXPECTED_PROCESSING_TIME_MS: () => DEFAULT_EXPECTED_PROCESSING_TIME_MS,
  MRP: () => MRP,
  MessageChannel: () => MessageChannel
});
module.exports = __toCommonJS(MessageChannel_exports);
var import_MessageCodec = require("#codec/MessageCodec.js");
var import_general = require("#general");
/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
const logger = new import_general.Logger("MessageChannel");
class ChannelNotConnectedError extends import_general.MatterError {
}
const DEFAULT_EXPECTED_PROCESSING_TIME_MS = 2e3;
const PEER_RESPONSE_TIME_BUFFER_MS = 5e3;
var MRP;
((MRP2) => {
  MRP2.MAX_TRANSMISSIONS = 5;
  MRP2.BACKOFF_BASE = 1.6;
  MRP2.BACKOFF_JITTER = 0.25;
  MRP2.BACKOFF_MARGIN = 1.1;
  MRP2.BACKOFF_THRESHOLD = 1;
  MRP2.STANDALONE_ACK_TIMEOUT_MS = 200;
})(MRP || (MRP = {}));
class MessageChannel {
  // When the session is supporting MRP and the channel is not reliable, use MRP handling
  constructor(channel, session, closeCallback) {
    this.channel = channel;
    this.session = session;
    this.#closeCallback = closeCallback;
  }
  closed = false;
  #closeCallback;
  set closeCallback(callback) {
    this.#closeCallback = callback;
  }
  get usesMrp() {
    return this.session.supportsMRP && !this.channel.isReliable;
  }
  /** Is the underlying transport reliable? */
  get isReliable() {
    return this.channel.isReliable;
  }
  get type() {
    return this.channel.type;
  }
  /**
   * Max Payload size of the exchange which bases on the maximum payload size of the channel. The full encoded matter
   * message payload sent here can be as huge as allowed by the channel.
   */
  get maxPayloadSize() {
    return this.channel.maxPayloadSize;
  }
  async send(message, logContext) {
    logger.debug("Message \xBB", import_MessageCodec.MessageCodec.messageDiagnostics(message, logContext));
    const packet = this.session.encode(message);
    const bytes = import_MessageCodec.MessageCodec.encodePacket(packet);
    if (bytes.length > this.maxPayloadSize) {
      logger.warn(
        `Matter message to send to ${this.name} is ${bytes.length}bytes long, which is larger than the maximum allowed size of ${this.maxPayloadSize}. This only works if both nodes support it.`
      );
    }
    return await this.channel.send(bytes);
  }
  get name() {
    return `${this.channel.name} on session ${this.session.name}`;
  }
  async close() {
    const wasAlreadyClosed = this.closed;
    this.closed = true;
    await this.channel.close();
    if (!wasAlreadyClosed) {
      await this.#closeCallback?.();
    }
  }
  calculateMaximumPeerResponseTimeMs(sessionParameters, expectedProcessingTimeMs = DEFAULT_EXPECTED_PROCESSING_TIME_MS) {
    switch (this.channel.type) {
      case "tcp":
        return 3e4 + PEER_RESPONSE_TIME_BUFFER_MS;
      case "udp":
        if (!this.usesMrp) {
          throw new import_general.MatterFlowError("No response expected for this message exchange because UDP and no MRP.");
        }
        return this.#calculateMrpMaximumPeerResponseTime(sessionParameters, expectedProcessingTimeMs) + PEER_RESPONSE_TIME_BUFFER_MS;
      case "ble":
        return 3e4 + PEER_RESPONSE_TIME_BUFFER_MS;
      default:
        throw new import_general.MatterFlowError(
          `Can not calculate expected timeout for unknown channel type: ${this.channel.type}`
        );
    }
  }
  /**
   * Calculates the backoff time for a resubmission based on the current retransmission count.
   * If no session parameters are provided, the parameters of the current session are used.
   * If session parameters are provided, the method can be used to calculate the maximum backoff time for the other
   * side of the exchange.
   *
   * @see {@link MatterSpecification.v10.Core}, section 4.11.2.1
   */
  getMrpResubmissionBackOffTime(retransmissionCount, sessionParameters) {
    const { activeIntervalMs, idleIntervalMs } = sessionParameters ?? this.session.parameters;
    const baseInterval = sessionParameters !== void 0 || this.session.isPeerActive() ? activeIntervalMs : idleIntervalMs;
    return Math.floor(
      MRP.BACKOFF_MARGIN * baseInterval * Math.pow(MRP.BACKOFF_BASE, Math.max(0, retransmissionCount - MRP.BACKOFF_THRESHOLD)) * (1 + (sessionParameters !== void 0 ? 1 : Math.random()) * MRP.BACKOFF_JITTER)
    );
  }
  #calculateMrpMaximumPeerResponseTime(sessionParameters, expectedProcessingTimeMs = DEFAULT_EXPECTED_PROCESSING_TIME_MS) {
    let finalWaitTime = expectedProcessingTimeMs;
    for (let i = 0; i < MRP.MAX_TRANSMISSIONS; i++) {
      finalWaitTime += this.getMrpResubmissionBackOffTime(i, sessionParameters);
    }
    return finalWaitTime;
  }
}
//# sourceMappingURL=MessageChannel.js.map
