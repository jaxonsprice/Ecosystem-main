/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { ReadResult } from "#action/response/ReadResult.js";
import { DecodedAttributeReportValue } from "#interaction/AttributeDataDecoder.js";
import { DecodedDataReport } from "#interaction/DecodedDataReport.js";
import { AttributeId, ClusterId, EndpointNumber, Status, StatusCode, TlvDataReport, TlvDataReportForSend, TlvInvokeRequest, TlvInvokeResponse, TlvReadRequest, TlvStream, TlvSubscribeRequest, TlvSubscribeResponse, TlvTimedRequest, TlvWriteRequest, TlvWriteResponse, TypeFromSchema } from "#types";
import { Message } from "../codec/MessageCodec.js";
import { ExchangeProvider } from "../protocol/ExchangeProvider.js";
import { ExchangeSendOptions, MessageExchange } from "../protocol/MessageExchange.js";
import { AttributeReportPayload, BaseDataReport, DataReportPayloadIterator, EventReportPayload } from "./AttributeDataEncoder.js";
export declare enum MessageType {
    StatusResponse = 1,
    ReadRequest = 2,
    SubscribeRequest = 3,
    SubscribeResponse = 4,
    ReportData = 5,
    WriteRequest = 6,
    WriteResponse = 7,
    InvokeRequest = 8,
    InvokeResponse = 9,
    TimedRequest = 10
}
export type ReadRequest = TypeFromSchema<typeof TlvReadRequest>;
export type DataReport = TypeFromSchema<typeof TlvDataReport>;
export type SubscribeRequest = TypeFromSchema<typeof TlvSubscribeRequest>;
export type SubscribeResponse = TypeFromSchema<typeof TlvSubscribeResponse>;
export type InvokeRequest = TypeFromSchema<typeof TlvInvokeRequest>;
export type InvokeResponse = TypeFromSchema<typeof TlvInvokeResponse>;
export type TimedRequest = TypeFromSchema<typeof TlvTimedRequest>;
export type WriteRequest = TypeFromSchema<typeof TlvWriteRequest>;
export type WriteResponse = TypeFromSchema<typeof TlvWriteResponse>;
declare class InteractionMessenger {
    #private;
    protected exchange: MessageExchange;
    constructor(exchange: MessageExchange);
    send(messageType: number, payload: Uint8Array, options?: ExchangeSendOptions): Promise<void>;
    sendStatus(status: StatusCode, options?: ExchangeSendOptions): Promise<void>;
    waitForSuccess(expectedMessageInfo: string, options?: {
        expectedProcessingTimeMs?: number;
        timeoutMs?: number;
    }): Promise<void>;
    nextMessage(expectedMessageType: number, options?: {
        expectedProcessingTimeMs?: number;
        timeoutMs?: number;
    }, expectedMessageInfo?: string): Promise<Message>;
    anyNextMessage(expectedMessageInfo: string, options?: {
        expectedProcessingTimeMs?: number;
        timeoutMs?: number;
    }): Promise<Message>;
    close(): Promise<void>;
    protected throwIfErrorStatusMessage(message: Message, logHint?: string): void;
    getExchangeChannelName(): string;
}
export interface InteractionRecipient {
    handleReadRequest(exchange: MessageExchange, request: ReadRequest, message: Message): Promise<{
        dataReport: DataReport;
        payload?: DataReportPayloadIterator;
    }>;
    handleWriteRequest(exchange: MessageExchange, request: WriteRequest, message: Message): Promise<WriteResponse>;
    handleSubscribeRequest(exchange: MessageExchange, request: SubscribeRequest, messenger: InteractionServerMessenger, message: Message): Promise<void>;
    handleInvokeRequest(exchange: MessageExchange, request: InvokeRequest, messenger: InteractionServerMessenger, message: Message): Promise<void>;
    handleTimedRequest(exchange: MessageExchange, request: TimedRequest, message: Message): void;
}
export declare class InteractionServerMessenger extends InteractionMessenger {
    handleRequest(recipient: InteractionRecipient): Promise<void>;
    /**
     * Handle a DataReport with a Payload Iterator for a DataReport to send, split them into multiple DataReport
     * messages and send them out based on the size.
     */
    sendDataReport(options: {
        baseDataReport: BaseDataReport;
        forFabricFilteredRead: boolean;
        payload?: DataReportPayloadIterator;
        waitForAck?: boolean;
        suppressEmptyReport?: boolean;
    }): Promise<void>;
    sendDataReportMessage(dataReport: TypeFromSchema<typeof TlvDataReportForSend>, waitForAck?: boolean): Promise<void>;
    /**
     * Convert a server interaction report to a DataReport entry
     * TODO remove when anything is migrated completely
     */
    static convertServerInteractionReport(report: ReadResult.Report): AttributeReportPayload | EventReportPayload;
}
export declare class IncomingInteractionClientMessenger extends InteractionMessenger {
    #private;
    waitFor(expectedMessageInfo: string, messageType: number, timeoutMs?: number): Promise<Message>;
    /**
     * Reads data report stream and aggregates them into a single report.
     * Additionally, a callback can be provided that is called for each cluster chunk received.
     */
    readAggregateDataReport(chunkListener?: (chunk: DecodedAttributeReportValue<any>[]) => Promise<void>, expectedSubscriptionIds?: number[]): Promise<DecodedDataReport>;
    /**
     * Read a single data report.
     */
    readDataReport(): Promise<import("#types").TypeFromFields<{
        subscriptionId: import("#types").OptionalFieldType<number>;
        attributeReports: import("#types").OptionalFieldType<import("#types").TypeFromFields<{
            attributeStatus: import("#types").OptionalFieldType<import("#types").TypeFromFields<{
                path: import("#types").FieldType<import("#types").TypeFromFields<{
                    enableTagCompression: import("#types").OptionalFieldType<boolean>;
                    nodeId: import("#types").OptionalFieldType<import("#types").NodeId>;
                    endpointId: import("#types").OptionalFieldType<import("#types").EndpointNumber>;
                    clusterId: import("#types").OptionalFieldType<import("#types").ClusterId>;
                    attributeId: import("#types").OptionalFieldType<import("#types").AttributeId>;
                    listIndex: import("#types").OptionalFieldType<number | null>;
                    wildcardPathFlags: import("#types").OptionalFieldType<import("#types").TypeFromPartialBitSchema<{
                        skipRootNode: import("#types").BitFlag;
                        skipGlobalAttributes: import("#types").BitFlag;
                        skipAttributeList: import("#types").BitFlag;
                        reserved1: import("#types").BitFlag;
                        skipCommandLists: import("#types").BitFlag;
                        skipCustomElements: import("#types").BitFlag;
                        skipFixedAttributes: import("#types").BitFlag;
                        skipChangesOmittedAttributes: import("#types").BitFlag;
                        skipDiagnosticsClusters: import("#types").BitFlag;
                    }>>;
                }>>;
                status: import("#types").FieldType<import("#types").TypeFromFields<{
                    status: import("#types").FieldType<import("#types").Status>;
                    clusterStatus: import("#types").OptionalFieldType<import("#types").Status>;
                }>>;
            }>>;
            attributeData: import("#types").OptionalFieldType<import("#types").TypeFromFields<{
                dataVersion: import("#types").OptionalFieldType<number>;
                path: import("#types").FieldType<import("#types").TypeFromFields<{
                    enableTagCompression: import("#types").OptionalFieldType<boolean>;
                    nodeId: import("#types").OptionalFieldType<import("#types").NodeId>;
                    endpointId: import("#types").OptionalFieldType<import("#types").EndpointNumber>;
                    clusterId: import("#types").OptionalFieldType<import("#types").ClusterId>;
                    attributeId: import("#types").OptionalFieldType<import("#types").AttributeId>;
                    listIndex: import("#types").OptionalFieldType<number | null>;
                    wildcardPathFlags: import("#types").OptionalFieldType<import("#types").TypeFromPartialBitSchema<{
                        skipRootNode: import("#types").BitFlag;
                        skipGlobalAttributes: import("#types").BitFlag;
                        skipAttributeList: import("#types").BitFlag;
                        reserved1: import("#types").BitFlag;
                        skipCommandLists: import("#types").BitFlag;
                        skipCustomElements: import("#types").BitFlag;
                        skipFixedAttributes: import("#types").BitFlag;
                        skipChangesOmittedAttributes: import("#types").BitFlag;
                        skipDiagnosticsClusters: import("#types").BitFlag;
                    }>>;
                }>>;
                data: import("#types").FieldType<TlvStream>;
            }>>;
        }>[]>;
        eventReports: import("#types").OptionalFieldType<import("#types").TypeFromFields<{
            eventStatus: import("#types").OptionalFieldType<import("#types").TypeFromFields<{
                path: import("#types").FieldType<import("#types").TypeFromFields<{
                    nodeId: import("#types").OptionalFieldType<import("#types").NodeId>;
                    endpointId: import("#types").OptionalFieldType<import("#types").EndpointNumber>;
                    clusterId: import("#types").OptionalFieldType<import("#types").ClusterId>;
                    eventId: import("#types").OptionalFieldType<import("#types").EventId>;
                    isUrgent: import("#types").OptionalFieldType<boolean>;
                }>>;
                status: import("#types").FieldType<import("#types").TypeFromFields<{
                    status: import("#types").FieldType<import("#types").Status>;
                    clusterStatus: import("#types").OptionalFieldType<import("#types").Status>;
                }>>;
            }>>;
            eventData: import("#types").OptionalFieldType<import("#types").TypeFromFields<{
                path: import("#types").FieldType<import("#types").TypeFromFields<{
                    nodeId: import("#types").OptionalFieldType<import("#types").NodeId>;
                    endpointId: import("#types").OptionalFieldType<import("#types").EndpointNumber>;
                    clusterId: import("#types").OptionalFieldType<import("#types").ClusterId>;
                    eventId: import("#types").OptionalFieldType<import("#types").EventId>;
                    isUrgent: import("#types").OptionalFieldType<boolean>;
                }>>;
                eventNumber: import("#types").FieldType<import("#types").EventNumber>;
                priority: import("#types").FieldType<import("#types").EventPriority>;
                epochTimestamp: import("#types").OptionalFieldType<number | bigint>;
                systemTimestamp: import("#types").OptionalFieldType<number | bigint>;
                deltaEpochTimestamp: import("#types").OptionalFieldType<number | bigint>;
                deltaSystemTimestamp: import("#types").OptionalFieldType<number | bigint>;
                data: import("#types").OptionalFieldType<TlvStream>;
            }>>;
        }>[]>;
        moreChunkedMessages: import("#types").OptionalFieldType<boolean>;
        suppressResponse: import("#types").OptionalFieldType<boolean>;
        interactionModelRevision: import("#types").FieldType<number>;
    }>>;
    /**
     * Read data reports as they come in on the wire.
     *
     * Data reports payloads are decoded but list attributes may be split across messages; these will require reassembly.
     */
    readDataReports(): AsyncGenerator<import("#types").TypeFromFields<{
        subscriptionId: import("#types").OptionalFieldType<number>;
        attributeReports: import("#types").OptionalFieldType<import("#types").TypeFromFields<{
            attributeStatus: import("#types").OptionalFieldType<import("#types").TypeFromFields<{
                path: import("#types").FieldType<import("#types").TypeFromFields<{
                    enableTagCompression: import("#types").OptionalFieldType<boolean>;
                    nodeId: import("#types").OptionalFieldType<import("#types").NodeId>;
                    endpointId: import("#types").OptionalFieldType<import("#types").EndpointNumber>;
                    clusterId: import("#types").OptionalFieldType<import("#types").ClusterId>;
                    attributeId: import("#types").OptionalFieldType<import("#types").AttributeId>;
                    listIndex: import("#types").OptionalFieldType<number | null>;
                    wildcardPathFlags: import("#types").OptionalFieldType<import("#types").TypeFromPartialBitSchema<{
                        skipRootNode: import("#types").BitFlag;
                        skipGlobalAttributes: import("#types").BitFlag;
                        skipAttributeList: import("#types").BitFlag;
                        reserved1: import("#types").BitFlag;
                        skipCommandLists: import("#types").BitFlag;
                        skipCustomElements: import("#types").BitFlag;
                        skipFixedAttributes: import("#types").BitFlag;
                        skipChangesOmittedAttributes: import("#types").BitFlag;
                        skipDiagnosticsClusters: import("#types").BitFlag;
                    }>>;
                }>>;
                status: import("#types").FieldType<import("#types").TypeFromFields<{
                    status: import("#types").FieldType<import("#types").Status>;
                    clusterStatus: import("#types").OptionalFieldType<import("#types").Status>;
                }>>;
            }>>;
            attributeData: import("#types").OptionalFieldType<import("#types").TypeFromFields<{
                dataVersion: import("#types").OptionalFieldType<number>;
                path: import("#types").FieldType<import("#types").TypeFromFields<{
                    enableTagCompression: import("#types").OptionalFieldType<boolean>;
                    nodeId: import("#types").OptionalFieldType<import("#types").NodeId>;
                    endpointId: import("#types").OptionalFieldType<import("#types").EndpointNumber>;
                    clusterId: import("#types").OptionalFieldType<import("#types").ClusterId>;
                    attributeId: import("#types").OptionalFieldType<import("#types").AttributeId>;
                    listIndex: import("#types").OptionalFieldType<number | null>;
                    wildcardPathFlags: import("#types").OptionalFieldType<import("#types").TypeFromPartialBitSchema<{
                        skipRootNode: import("#types").BitFlag;
                        skipGlobalAttributes: import("#types").BitFlag;
                        skipAttributeList: import("#types").BitFlag;
                        reserved1: import("#types").BitFlag;
                        skipCommandLists: import("#types").BitFlag;
                        skipCustomElements: import("#types").BitFlag;
                        skipFixedAttributes: import("#types").BitFlag;
                        skipChangesOmittedAttributes: import("#types").BitFlag;
                        skipDiagnosticsClusters: import("#types").BitFlag;
                    }>>;
                }>>;
                data: import("#types").FieldType<TlvStream>;
            }>>;
        }>[]>;
        eventReports: import("#types").OptionalFieldType<import("#types").TypeFromFields<{
            eventStatus: import("#types").OptionalFieldType<import("#types").TypeFromFields<{
                path: import("#types").FieldType<import("#types").TypeFromFields<{
                    nodeId: import("#types").OptionalFieldType<import("#types").NodeId>;
                    endpointId: import("#types").OptionalFieldType<import("#types").EndpointNumber>;
                    clusterId: import("#types").OptionalFieldType<import("#types").ClusterId>;
                    eventId: import("#types").OptionalFieldType<import("#types").EventId>;
                    isUrgent: import("#types").OptionalFieldType<boolean>;
                }>>;
                status: import("#types").FieldType<import("#types").TypeFromFields<{
                    status: import("#types").FieldType<import("#types").Status>;
                    clusterStatus: import("#types").OptionalFieldType<import("#types").Status>;
                }>>;
            }>>;
            eventData: import("#types").OptionalFieldType<import("#types").TypeFromFields<{
                path: import("#types").FieldType<import("#types").TypeFromFields<{
                    nodeId: import("#types").OptionalFieldType<import("#types").NodeId>;
                    endpointId: import("#types").OptionalFieldType<import("#types").EndpointNumber>;
                    clusterId: import("#types").OptionalFieldType<import("#types").ClusterId>;
                    eventId: import("#types").OptionalFieldType<import("#types").EventId>;
                    isUrgent: import("#types").OptionalFieldType<boolean>;
                }>>;
                eventNumber: import("#types").FieldType<import("#types").EventNumber>;
                priority: import("#types").FieldType<import("#types").EventPriority>;
                epochTimestamp: import("#types").OptionalFieldType<number | bigint>;
                systemTimestamp: import("#types").OptionalFieldType<number | bigint>;
                deltaEpochTimestamp: import("#types").OptionalFieldType<number | bigint>;
                deltaSystemTimestamp: import("#types").OptionalFieldType<number | bigint>;
                data: import("#types").OptionalFieldType<TlvStream>;
            }>>;
        }>[]>;
        moreChunkedMessages: import("#types").OptionalFieldType<boolean>;
        suppressResponse: import("#types").OptionalFieldType<boolean>;
        interactionModelRevision: import("#types").FieldType<number>;
    }>, void, unknown>;
}
export declare class InteractionClientMessenger extends IncomingInteractionClientMessenger {
    #private;
    static create(exchangeProvider: ExchangeProvider): Promise<InteractionClientMessenger>;
    constructor(exchange: MessageExchange, exchangeProvider: ExchangeProvider);
    /** Implements a send method with an automatic reconnection mechanism */
    send(messageType: number, payload: Uint8Array, options?: ExchangeSendOptions): Promise<void>;
    sendReadRequest(readRequest: ReadRequest): Promise<void>;
    sendSubscribeRequest(subscribeRequest: SubscribeRequest): Promise<void>;
    readAggregateSubscribeResponse(chunkListener?: (chunk: DecodedAttributeReportValue<any>[]) => Promise<void>): Promise<{
        subscribeResponse: import("#types").TypeFromFields<{
            subscriptionId: import("#types").FieldType<number>;
            maxInterval: import("#types").FieldType<number>;
            interactionModelRevision: import("#types").FieldType<number>;
        }>;
        report: DecodedDataReport;
    }>;
    sendInvokeCommand(invokeRequest: InvokeRequest, expectedProcessingTimeMs?: number): Promise<import("#types").TypeFromFields<{
        suppressResponse: import("#types").FieldType<boolean>;
        invokeResponses: import("#types").FieldType<import("#types").TypeFromFields<{
            command: import("#types").OptionalFieldType<import("#types").TypeFromFields<{
                commandPath: import("#types").FieldType<import("#types").TypeFromFields<{
                    endpointId: import("#types").OptionalFieldType<import("#types").EndpointNumber>;
                    clusterId: import("#types").FieldType<import("#types").ClusterId>;
                    commandId: import("#types").FieldType<import("#types").CommandId>;
                }>>;
                commandFields: import("#types").OptionalFieldType<TlvStream>;
                commandRef: import("#types").OptionalFieldType<number>;
            }>>;
            status: import("#types").OptionalFieldType<import("#types").TypeFromFields<{
                commandPath: import("#types").FieldType<import("#types").TypeFromFields<{
                    endpointId: import("#types").OptionalFieldType<import("#types").EndpointNumber>;
                    clusterId: import("#types").FieldType<import("#types").ClusterId>;
                    commandId: import("#types").FieldType<import("#types").CommandId>;
                }>>;
                status: import("#types").FieldType<import("#types").TypeFromFields<{
                    status: import("#types").FieldType<import("#types").Status>;
                    clusterStatus: import("#types").OptionalFieldType<import("#types").Status>;
                }>>;
                commandRef: import("#types").OptionalFieldType<number>;
            }>>;
        }>[]>;
        moreChunkedMessages: import("#types").OptionalFieldType<boolean>;
        interactionModelRevision: import("#types").FieldType<number>;
    }> | undefined>;
    sendWriteCommand(writeRequest: WriteRequest): Promise<import("#types").TypeFromFields<{
        writeResponses: import("#types").FieldType<import("#types").TypeFromFields<{
            path: import("#types").FieldType<import("#types").TypeFromFields<{
                enableTagCompression: import("#types").OptionalFieldType<boolean>;
                nodeId: import("#types").OptionalFieldType<import("#types").NodeId>;
                endpointId: import("#types").OptionalFieldType<import("#types").EndpointNumber>;
                clusterId: import("#types").OptionalFieldType<import("#types").ClusterId>;
                attributeId: import("#types").OptionalFieldType<import("#types").AttributeId>;
                listIndex: import("#types").OptionalFieldType<number | null>;
                wildcardPathFlags: import("#types").OptionalFieldType<import("#types").TypeFromPartialBitSchema<{
                    skipRootNode: import("#types").BitFlag;
                    skipGlobalAttributes: import("#types").BitFlag;
                    skipAttributeList: import("#types").BitFlag;
                    reserved1: import("#types").BitFlag;
                    skipCommandLists: import("#types").BitFlag;
                    skipCustomElements: import("#types").BitFlag;
                    skipFixedAttributes: import("#types").BitFlag;
                    skipChangesOmittedAttributes: import("#types").BitFlag;
                    skipDiagnosticsClusters: import("#types").BitFlag;
                }>>;
            }>>;
            status: import("#types").FieldType<import("#types").TypeFromFields<{
                status: import("#types").FieldType<import("#types").Status>;
                clusterStatus: import("#types").OptionalFieldType<import("#types").Status>;
            }>>;
        }>[]>;
        interactionModelRevision: import("#types").FieldType<number>;
    }> | undefined>;
    sendTimedRequest(timeoutSeconds: number): Promise<import("#types").TypeFromFields<{
        status: import("#types").FieldType<import("#types").Status>;
        interactionModelRevision: import("#types").FieldType<number>;
    }>>;
    private requestWithSuppressedResponse;
    private request;
}
export {};
//# sourceMappingURL=InteractionMessenger.d.ts.map