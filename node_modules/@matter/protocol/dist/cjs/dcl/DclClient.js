"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var DclClient_exports = {};
__export(DclClient_exports, {
  DclClient: () => DclClient,
  MatterDclError: () => MatterDclError,
  MatterDclResponseError: () => MatterDclResponseError
});
module.exports = __toCommonJS(DclClient_exports);
var import_general = require("#general");
/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
const DCL_PRODUCTION_URL = "https://on.dcl.csa-iot.org";
const DCL_TEST_URL = "https://on.test-net.dcl.csa-iot.org";
class MatterDclError extends import_general.MatterError {
}
class MatterDclResponseError extends MatterDclError {
  constructor(path, error) {
    super(`Error fetching ${path} from DCL: ${error.code} - ${error.message}`);
  }
}
class DclClient {
  constructor(production = true) {
    this.production = production;
    this.#baseUrl = this.production ? DCL_PRODUCTION_URL : DCL_TEST_URL;
  }
  #baseUrl;
  async #fetchJson(path) {
    const url = new URL(path, this.#baseUrl);
    try {
      const response = await fetch(url.toString(), {
        method: "GET",
        headers: {
          "Content-Type": "application/json"
        },
        signal: AbortSignal.timeout(5e3)
        // 5 seconds timeout
      });
      if (!response.ok) {
        throw new MatterDclResponseError(path, await response.json());
      }
      return await response.json();
    } catch (error) {
      if (error instanceof MatterDclResponseError) {
        throw error;
      }
      throw new MatterDclResponseError(path, {
        code: 500,
        message: error instanceof Error ? error.message : "Unknown Error",
        details: []
      });
    }
  }
  async fetchRootCertificateList() {
    const certList = await this.#fetchJson("/certificates/approved");
    if (certList?.approvedRootCertificates?.schemaVersion !== 0) {
      throw new MatterDclError(
        `Unsupported DCL Root Certificate schema version: ${certList.approvedRootCertificates.schemaVersion}`
      );
    }
    return certList.approvedRootCertificates.certs;
  }
  async fetchRootCertificateBySubject(subject) {
    const path = `/certificates/${encodeURIComponent(subject.subject)}/${encodeURIComponent(subject.subjectKeyId)}`;
    const response = await this.#fetchJson(path);
    if (!response || !response.approvedRootCertificates || response.approvedRootCertificates.subject !== subject.subject || response.approvedRootCertificates.subjectKeyId !== subject.subjectKeyId || response.approvedRootCertificates.schemaVersion !== 0) {
      throw new MatterDclError(
        `Root certificate not found for subject: ${subject.subject}, subjectKeyId: ${subject.subjectKeyId}`
      );
    }
    return response.approvedRootCertificates.certs;
  }
  async fetchModelByVidPid(vid, pid) {
    const path = `/models/model/${encodeURIComponent(vid)}/${encodeURIComponent(pid)}`;
    const response = await this.#fetchJson(path);
    if (!response || !response.model || response.model.vid !== vid || response.model.pid !== pid || response.model.schemaVersion !== 0) {
      throw new MatterDclError(`Model not found for VID: ${vid}, PID: ${pid}`);
    }
    return response.model;
  }
  async fetchModelVersionsByVidPid(vid, pid) {
    const path = `/models/versions/${encodeURIComponent(vid)}/${encodeURIComponent(pid)}`;
    const response = await this.#fetchJson(path);
    if (!response || !response.modelVersions || response.modelVersions.vid !== vid || response.modelVersions.pid !== pid || response.modelVersions.schemaVersion !== 0) {
      throw new MatterDclError(`Model versions not found for VID: ${vid}, PID: ${pid}`);
    }
    return response.modelVersions.softwareVersions;
  }
  async fetchModelVersionByVidPidSoftwareVersion(vid, pid, softwareVersion) {
    const path = `/models/versions/${encodeURIComponent(vid)}/${encodeURIComponent(pid)}/${encodeURIComponent(softwareVersion)}`;
    const response = await this.#fetchJson(path);
    if (!response || !response.modelVersion || response.modelVersion.vid !== vid || response.modelVersion.pid !== pid || response.modelVersion.softwareVersion !== softwareVersion || response.modelVersion.schemaVersion !== 0) {
      throw new MatterDclError(
        `Model version not found for VID: ${vid}, PID: ${pid}, Software Version: ${softwareVersion}`
      );
    }
    return response.modelVersion;
  }
}
//# sourceMappingURL=DclClient.js.map
