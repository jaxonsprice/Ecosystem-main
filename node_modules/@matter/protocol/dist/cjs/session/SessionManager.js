"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var SessionManager_exports = {};
__export(SessionManager_exports, {
  SessionManager: () => SessionManager
});
module.exports = __toCommonJS(SessionManager_exports);
var import_FabricManager = require("#fabric/FabricManager.js");
var import_general = require("#general");
var import_model = require("#model");
var import_PeerAddress = require("#peer/PeerAddress.js");
var import_GroupSession = require("#session/GroupSession.js");
var import_types = require("#types");
var import_general2 = require("@matter/general");
var import_Scanner = require("../common/Scanner.js");
var import_MessageCounter = require("../protocol/MessageCounter.js");
var import_InsecureSession = require("./InsecureSession.js");
var import_NodeSession = require("./NodeSession.js");
var import_SecureSession = require("./SecureSession.js");
var import_Session = require("./Session.js");
/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
const logger = import_general.Logger.get("SessionManager");
const DEFAULT_SESSION_PARAMETERS = {
  idleIntervalMs: import_Session.SESSION_IDLE_INTERVAL_MS,
  activeIntervalMs: import_Session.SESSION_ACTIVE_INTERVAL_MS,
  activeThresholdMs: import_Session.SESSION_ACTIVE_THRESHOLD_MS,
  dataModelRevision: import_model.Specification.DATA_MODEL_REVISION,
  interactionModelRevision: import_model.Specification.INTERACTION_MODEL_REVISION,
  specificationVersion: import_model.Specification.SPECIFICATION_VERSION,
  maxPathsPerInvoke: import_types.DEFAULT_MAX_PATHS_PER_INVOKE,
  supportedTransports: {},
  maxTcpMessageSize: import_Session.FALLBACK_MAX_TCP_MESSAGE_SIZE
};
const ID_SPACE_UPPER_BOUND = 65535;
class SessionManager {
  #context;
  #insecureSessions = /* @__PURE__ */ new Map();
  #sessions = new import_general.BasicSet();
  #groupSessions = /* @__PURE__ */ new Map();
  #nextSessionId;
  #resumptionRecords = new import_PeerAddress.PeerAddressMap();
  #globalUnencryptedMessageCounter;
  #subscriptionsChanged = (0, import_general.Observable)();
  #sessionParameters;
  #resubmissionStarted = (0, import_general.Observable)();
  #construction;
  #observers = new import_general.ObserverGroup();
  #subscriptionUpdateMutex = new import_general.Mutex(this);
  #idUpperBound = ID_SPACE_UPPER_BOUND;
  constructor(context) {
    this.#context = context;
    const {
      fabrics: { crypto }
    } = context;
    this.#sessionParameters = { ...DEFAULT_SESSION_PARAMETERS, ...context.parameters };
    this.#nextSessionId = crypto.randomUint16;
    this.#globalUnencryptedMessageCounter = new import_MessageCounter.MessageCounter(crypto);
    this.#observers.on(context.fabrics.events.deleted, async (fabric) => {
      await this.deleteResumptionRecordsForFabric(fabric);
    });
    this.#construction = (0, import_general.Construction)(this, () => this.#initialize());
  }
  static [import_general.Environmental.create](env) {
    const instance = new SessionManager({
      storage: env.get(import_general.StorageManager).createContext("sessions"),
      fabrics: env.get(import_FabricManager.FabricManager)
    });
    env.set(SessionManager, instance);
    return instance;
  }
  get construction() {
    return this.#construction;
  }
  get context() {
    return this.#context;
  }
  get crypto() {
    return this.#context.fabrics.crypto;
  }
  /**
   * Active secure sessions.
   */
  get sessions() {
    return this.#sessions;
  }
  /**
   * Active insecure sessions.
   */
  get insecureSessions() {
    return this.#insecureSessions;
  }
  /**
   * Our session parameters.  These are the parameters we provide during session negotiation.  The peer may specify
   * different parameters.
   */
  get sessionParameters() {
    return this.#sessionParameters;
  }
  /**
   * Change session parameters.
   *
   * Parameters values you omit in {@link parameters} will retain their current values.  This only affects new
   * sessions.
   */
  set sessionParameters(parameters) {
    this.#sessionParameters = {
      ...this.#sessionParameters,
      ...parameters
    };
  }
  /**
   * Emits when there is a change to the subscription set.
   */
  get subscriptionsChanged() {
    return this.#subscriptionsChanged;
  }
  /**
   * Emits when resubmission is necessary due to timeout or network error.
   */
  get resubmissionStarted() {
    return this.#resubmissionStarted;
  }
  /**
   * Convenience function for accessing a fabric by address.
   */
  fabricFor(address) {
    return this.#context.fabrics.for(address);
  }
  /**
   * @deprecated
   */
  get owner() {
    return this.#context.owner;
  }
  createInsecureSession(options) {
    this.#construction.assert();
    const { initiatorNodeId, sessionParameters, isInitiator } = options;
    if (initiatorNodeId !== void 0) {
      if (this.#insecureSessions.has(initiatorNodeId)) {
        throw new import_general.MatterFlowError(`UnsecureSession with NodeId ${initiatorNodeId} already exists.`);
      }
    }
    while (true) {
      const session = new import_InsecureSession.InsecureSession({
        crypto: this.#context.fabrics.crypto,
        manager: this,
        messageCounter: this.#globalUnencryptedMessageCounter,
        initiatorNodeId,
        sessionParameters,
        isInitiator: isInitiator ?? false
      });
      const ephemeralNodeId = session.nodeId;
      if (this.#insecureSessions.has(ephemeralNodeId)) continue;
      this.#insecureSessions.set(ephemeralNodeId, session);
      return session;
    }
  }
  async createSecureSession(args) {
    await this.construction;
    const {
      sessionId,
      fabric,
      peerNodeId,
      peerSessionId,
      sharedSecret,
      salt,
      isInitiator,
      isResumption,
      peerSessionParameters,
      caseAuthenticatedTags
    } = args;
    const session = await import_NodeSession.NodeSession.create({
      crypto: this.crypto,
      manager: this,
      id: sessionId,
      fabric,
      peerNodeId,
      peerSessionId,
      sharedSecret,
      salt,
      isInitiator,
      isResumption,
      peerSessionParameters,
      caseAuthenticatedTags
    });
    const subscriptionsChanged = (subscription) => {
      if (session.isClosing) {
        return;
      }
      this.#subscriptionsChanged.emit(session, subscription);
    };
    session.subscriptions.added.on(subscriptionsChanged);
    session.subscriptions.deleted.on(subscriptionsChanged);
    this.#sessions.add(session);
    return session;
  }
  /**
   * Deletes a resumption record for a given address.  Returns true if the record was deleted, false if it did not
   * exist.
   */
  async deleteResumptionRecord(address) {
    await this.#construction;
    const result = this.#resumptionRecords.delete(address);
    if (result) {
      await this.#storeResumptionRecords();
    }
    return result;
  }
  /**
   * Deletes all resumption records for a given fabric.  Returns true if any records were deleted, false if none
   * existed.
   */
  async deleteResumptionRecordsForFabric(fabric) {
    await this.#construction;
    let deletedCount = 0;
    for (const address of this.#resumptionRecords.keys()) {
      if (address.fabricIndex === fabric.fabricIndex) {
        if (this.#resumptionRecords.delete(address)) {
          deletedCount++;
        }
      }
    }
    if (deletedCount > 0) {
      await this.#storeResumptionRecords();
    }
    return deletedCount > 0;
  }
  findOldestInactiveSession() {
    this.#construction.assert();
    let oldestSession = void 0;
    for (const session of this.#sessions) {
      if (!oldestSession || session.activeTimestamp < oldestSession.activeTimestamp) {
        oldestSession = session;
      }
    }
    if (oldestSession === void 0) {
      throw new import_general.MatterFlowError("No session found to close and all session ids are taken.");
    }
    return oldestSession;
  }
  async getNextAvailableSessionId() {
    await this.#construction;
    for (let i = 0; i < this.#idUpperBound; i++) {
      const id = this.#nextSessionId;
      this.#nextSessionId = this.#nextSessionId + 1 & this.#idUpperBound;
      if (this.#nextSessionId === 0) this.#nextSessionId++;
      if (this.getSession(id) === void 0) {
        return id;
      }
    }
    const oldestSession = this.findOldestInactiveSession();
    await oldestSession.end(true, false);
    this.#nextSessionId = oldestSession.id;
    return this.#nextSessionId++;
  }
  getSession(sessionId) {
    this.#construction.assert();
    return this.#sessions.get("id", sessionId);
  }
  getPaseSession() {
    this.#construction.assert();
    return [...this.#sessions].find(
      (session) => import_NodeSession.NodeSession.is(session) && session.isPase && !session.closingAfterExchangeFinished
    );
  }
  getSessionForNode(address) {
    this.#construction.assert();
    return [...this.#sessions].find((session) => {
      if (!session.isSecure) return false;
      const secureSession = session;
      return secureSession.peerIs(address);
    });
  }
  async removeAllSessionsForNode(address, sendClose = false, closeBeforeCreatedTimestamp) {
    await this.#construction;
    for (const session of this.#sessions) {
      if (!session.isSecure) continue;
      if (closeBeforeCreatedTimestamp !== void 0 && session.createdAt >= closeBeforeCreatedTimestamp) continue;
      const secureSession = session;
      if (secureSession.peerIs(address)) {
        await secureSession.destroy(sendClose, false);
        this.#sessions.delete(session);
      }
    }
  }
  getUnsecureSession(sourceNodeId) {
    this.#construction.assert();
    if (sourceNodeId === void 0) {
      return this.#insecureSessions.get(import_types.NodeId.UNSPECIFIED_NODE_ID);
    }
    return this.#insecureSessions.get(sourceNodeId);
  }
  /**
   * Creates or Returns a Group Session for a Group Peer Address.
   * This is used for sending group messages because it returns the session for the current
   * Group Epoch key. The Source Node Id is the own Node.
   */
  groupSessionForAddress(address) {
    const groupId = import_types.GroupId.fromNodeId(address.nodeId);
    import_types.GroupId.assertGroupId(groupId);
    const fabric = this.fabricFor(address);
    const { key, keySetId, sessionId } = fabric.groups.currentKeyForGroup(groupId);
    if (sessionId === void 0 || key === void 0) {
      throw new import_general2.UnexpectedDataError(
        `No group session data found for group ${groupId} in fabric ${fabric.fabricId}.`
      );
    }
    let session = this.#groupSessions.get(fabric.nodeId)?.get("id", sessionId);
    if (session === void 0) {
      session = new import_GroupSession.GroupSession({
        manager: this,
        id: sessionId,
        fabric,
        keySetId,
        operationalGroupKey: key,
        peerNodeId: address.nodeId
        // The peer node ID is the group node ID
      });
    }
    return session;
  }
  /**
   * Creates or Returns the Group session based on an incoming packet.
   * The Session ID is determined by trying to decrypt te packet with possible keys.
   */
  groupSessionFromPacket(packet, aad) {
    const groupId = packet.header.destGroupId;
    if (groupId === void 0) {
      throw new import_general2.UnexpectedDataError("Group ID is required for GroupSession fromPacket.");
    }
    import_types.GroupId.assertGroupId((0, import_types.GroupId)(groupId));
    const { message, key, sessionId, sourceNodeId, keySetId, fabric } = import_GroupSession.GroupSession.decode(
      this.#context.fabrics,
      packet,
      aad
    );
    let session = this.#groupSessions.get(sourceNodeId)?.get("id", sessionId);
    if (session === void 0) {
      session = new import_GroupSession.GroupSession({
        manager: this,
        id: sessionId,
        fabric,
        keySetId,
        operationalGroupKey: key,
        peerNodeId: sourceNodeId
      });
    }
    return { session, message, key };
  }
  registerGroupSession(session) {
    const sourceNodeId = session.peerNodeId;
    const peerSessions = this.#groupSessions.get(sourceNodeId) ?? new import_general.BasicSet();
    peerSessions.add(session);
    this.#groupSessions.set(sourceNodeId, peerSessions);
  }
  removeGroupSession(session) {
    const sourceNodeId = session.peerNodeId;
    const peerSessions = this.#groupSessions.get(sourceNodeId);
    if (peerSessions) {
      peerSessions.delete(session);
      if (peerSessions.size === 0) {
        this.#groupSessions.delete(sourceNodeId);
      }
    }
  }
  findResumptionRecordById(resumptionId) {
    this.#construction.assert();
    return [...this.#resumptionRecords.values()].find((record) => import_general.Bytes.areEqual(record.resumptionId, resumptionId));
  }
  findResumptionRecordByAddress(address) {
    this.#construction.assert();
    return this.#resumptionRecords.get(address);
  }
  async saveResumptionRecord(resumptionRecord) {
    await this.#construction;
    this.#resumptionRecords.set(resumptionRecord.fabric.addressOf(resumptionRecord.peerNodeId), resumptionRecord);
    await this.#storeResumptionRecords();
  }
  async #storeResumptionRecords() {
    await this.#construction;
    await this.#context.storage.set(
      "resumptionRecords",
      [...this.#resumptionRecords].map(
        ([
          address,
          { sharedSecret, resumptionId, peerNodeId, fabric, sessionParameters, caseAuthenticatedTags }
        ]) => ({
          nodeId: address.nodeId,
          sharedSecret,
          resumptionId,
          fabricId: fabric.fabricId,
          fabricIndex: fabric.fabricIndex,
          peerNodeId,
          sessionParameters: {
            ...sessionParameters,
            supportedTransports: sessionParameters.supportedTransports ? import_Scanner.SupportedTransportsSchema.encode(sessionParameters.supportedTransports) : void 0
          },
          caseAuthenticatedTags
        })
      )
    );
  }
  async #initialize() {
    await this.#context.fabrics.construction;
    const storedResumptionRecords = await this.#context.storage.get(
      "resumptionRecords",
      []
    );
    storedResumptionRecords.forEach(
      ({
        nodeId,
        sharedSecret,
        resumptionId,
        fabricId,
        fabricIndex,
        peerNodeId,
        sessionParameters: {
          idleIntervalMs,
          activeIntervalMs,
          activeThresholdMs,
          dataModelRevision,
          interactionModelRevision,
          specificationVersion,
          maxPathsPerInvoke,
          supportedTransports,
          maxTcpMessageSize
        } = {},
        caseAuthenticatedTags
      }) => {
        const fabric = this.#context.fabrics.find(
          (fabric2) => fabric2.fabricId === fabricId && // Backward compatibility logic: fabricIndex was added later (0.15.5), so it might be undefined in older records
          (fabricIndex === void 0 || fabric2.fabricIndex === fabricIndex)
        );
        if (!fabric) {
          logger.warn(
            `Ignoring resumption record for fabric 0x${(0, import_general.toHex)(fabricId)} and index ${fabricIndex} because we cannot find a matching fabric`
          );
          return;
        }
        logger.info(
          "restoring resumption record for node",
          fabric.addressOf(nodeId).toString(),
          "and peer node",
          fabric.addressOf(peerNodeId).toString(),
          "for fabric id",
          `0x${(0, import_general.toHex)(fabric.fabricId)}`,
          `(0x${(0, import_general.toHex)(fabric.rootVendorId)}, "${fabric?.label}")`
        );
        this.#resumptionRecords.set(fabric.addressOf(nodeId), {
          sharedSecret,
          resumptionId,
          fabric,
          peerNodeId,
          sessionParameters: {
            // Make sure to initialize default values when restoring an older resumption record
            idleIntervalMs: idleIntervalMs ?? import_Session.SESSION_IDLE_INTERVAL_MS,
            activeIntervalMs: activeIntervalMs ?? import_Session.SESSION_ACTIVE_INTERVAL_MS,
            activeThresholdMs: activeThresholdMs ?? import_Session.SESSION_ACTIVE_THRESHOLD_MS,
            dataModelRevision: dataModelRevision ?? import_Session.FALLBACK_DATAMODEL_REVISION,
            interactionModelRevision: interactionModelRevision ?? import_Session.FALLBACK_INTERACTIONMODEL_REVISION,
            specificationVersion: specificationVersion ?? import_Session.FALLBACK_SPECIFICATION_VERSION,
            maxPathsPerInvoke: maxPathsPerInvoke ?? import_Session.FALLBACK_MAX_PATHS_PER_INVOKE,
            supportedTransports: supportedTransports !== void 0 ? import_Scanner.SupportedTransportsSchema.decode(supportedTransports) : {},
            maxTcpMessageSize: maxTcpMessageSize ?? import_Session.FALLBACK_MAX_TCP_MESSAGE_SIZE
          },
          caseAuthenticatedTags
        });
      }
    );
  }
  getActiveSessionInformation() {
    this.#construction.assert();
    return [...this.#sessions].filter((session) => session.isSecure && !session.isPase).map((session) => ({
      name: session.name,
      nodeId: session.nodeId,
      peerNodeId: session.peerNodeId,
      fabric: session instanceof import_SecureSession.SecureSession ? session.fabric?.externalInformation : void 0,
      isPeerActive: session.isPeerActive(),
      secure: session.isSecure,
      lastInteractionTimestamp: session instanceof import_SecureSession.SecureSession ? session.timestamp : void 0,
      lastActiveTimestamp: session instanceof import_SecureSession.SecureSession ? session.activeTimestamp : void 0,
      numberOfActiveSubscriptions: session instanceof import_SecureSession.SecureSession ? session.subscriptions.size : 0
    }));
  }
  async close() {
    if (this.#construction.status === import_general.Lifecycle.Status.Initializing) {
      await this.#construction;
    }
    await this.#subscriptionUpdateMutex;
    this.#observers.close();
    await this.#storeResumptionRecords();
    const closePromises = this.#sessions.map(async (session) => {
      await session?.end(false);
      this.#sessions.delete(session);
    });
    for (const session of this.#insecureSessions.values()) {
      closePromises.push(session?.end());
    }
    for (const sessions of this.#groupSessions.values()) {
      for (const session of sessions) {
        closePromises.push(session?.end());
      }
    }
    await import_general.MatterAggregateError.allSettled(closePromises, "Error closing sessions").catch(
      (error) => logger.error(error)
    );
  }
  async clear() {
    await this.close();
    await this.#context.storage.clear();
    this.#resumptionRecords.clear();
  }
  updateAllSubscriptions() {
    this.#subscriptionUpdateMutex.run(async () => {
      for (const session of this.#sessions) {
        for (const subscription of session.subscriptions) {
          await subscription.update();
        }
      }
    });
  }
  /** Clears all subscriptions for a given node and returns how many were cleared. */
  async clearSubscriptionsForNode(peerAddress, flushSubscriptions) {
    let clearedCount = 0;
    for (const session of this.#sessions) {
      if (import_PeerAddress.PeerAddress.is(session.peerAddress, peerAddress)) {
        clearedCount += await session.clearSubscriptions(flushSubscriptions, true);
      }
    }
    return clearedCount;
  }
  /**
   * Compress range of IDs.  This is intended for testing.
   */
  compressIdRange(upperBound) {
    this.#idUpperBound = upperBound;
    this.#nextSessionId = this.#context.fabrics.crypto.randomUint32 % upperBound;
    if (this.#nextSessionId === 0) this.#nextSessionId++;
  }
}
//# sourceMappingURL=SessionManager.js.map
