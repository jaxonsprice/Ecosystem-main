"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var CaseServer_exports = {};
__export(CaseServer_exports, {
  CaseServer: () => CaseServer
});
module.exports = __toCommonJS(CaseServer_exports);
var import_Noc = require("#certificate/kinds/Noc.js");
var import_general = require("#general");
var import_types = require("#types");
var import_FabricManager = require("../../fabric/FabricManager.js");
var import_SecureChannelMessenger = require("../../securechannel/SecureChannelMessenger.js");
var import_CaseMessages = require("./CaseMessages.js");
var import_CaseMessenger = require("./CaseMessenger.js");
/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
const logger = import_general.Logger.get("CaseServer");
class CaseServer {
  id = import_types.SECURE_CHANNEL_PROTOCOL_ID;
  requiresSecureSession = false;
  #sessions;
  #fabrics;
  constructor(sessions, fabrics) {
    this.#sessions = sessions;
    this.#fabrics = fabrics;
  }
  async onNewExchange(exchange) {
    const messenger = new import_CaseMessenger.CaseServerMessenger(exchange);
    try {
      await this.#handleSigma1(messenger);
    } catch (error) {
      logger.error("An error occurred during the commissioning", error);
      if (error instanceof import_FabricManager.FabricNotFoundError) {
        await messenger.sendError(import_types.SecureChannelStatusCode.NoSharedTrustRoots);
      } else if (!(error instanceof import_SecureChannelMessenger.ChannelStatusResponseError)) {
        await messenger.sendError(import_types.SecureChannelStatusCode.InvalidParam);
      }
    } finally {
      await exchange.session.destroy();
    }
  }
  async #handleSigma1(messenger) {
    logger.info(`Received pairing request from ${messenger.getChannelName()}`);
    const { sigma1Bytes, sigma1 } = await messenger.readSigma1();
    const resumptionRecord = sigma1.resumptionId !== void 0 && sigma1.initiatorResumeMic !== void 0 ? this.#sessions.findResumptionRecordById(sigma1.resumptionId) : void 0;
    const context = new Sigma1Context(this.#fabrics.crypto, messenger, sigma1Bytes, sigma1, resumptionRecord);
    if (await this.#resume(context)) {
      return;
    }
    if (await this.#generateSigma2(context)) {
      return;
    }
    logger.info(
      `Invalid resumption ID or resume MIC received from ${messenger.getChannelName()}`,
      context.peerResumptionId,
      context.peerResumeMic
    );
    throw new import_general.UnexpectedDataError("Invalid resumption ID or resume MIC.");
  }
  async #resume(cx) {
    if (cx.peerResumptionId === void 0 || cx.peerResumeMic === void 0 || cx.resumptionRecord === void 0) {
      return false;
    }
    const { sharedSecret, fabric, peerNodeId, caseAuthenticatedTags } = cx.resumptionRecord;
    const { crypto } = this.#fabrics;
    const peerResumeKey = await crypto.createHkdfKey(
      sharedSecret,
      import_general.Bytes.concat(cx.peerRandom, cx.peerResumptionId),
      import_CaseMessages.KDFSR1_KEY_INFO
    );
    try {
      crypto.decrypt(peerResumeKey, cx.peerResumeMic, import_CaseMessages.RESUME1_MIC_NONCE);
    } catch (e) {
      import_general.CryptoDecryptError.accept(e);
      cx.peerResumptionId = cx.peerResumeMic = void 0;
      return false;
    }
    const responderSessionId = await this.#sessions.getNextAvailableSessionId();
    const secureSessionSalt = import_general.Bytes.concat(cx.peerRandom, cx.peerResumptionId);
    const secureSession = await this.#sessions.createSecureSession({
      sessionId: responderSessionId,
      fabric,
      peerNodeId,
      peerSessionId: cx.peerSessionId,
      sharedSecret,
      salt: secureSessionSalt,
      isInitiator: false,
      isResumption: true,
      peerSessionParameters: cx.peerSessionParams,
      caseAuthenticatedTags
    });
    const resumeSalt = import_general.Bytes.concat(cx.peerRandom, cx.localResumptionId);
    const resumeKey = await crypto.createHkdfKey(sharedSecret, resumeSalt, import_CaseMessages.KDFSR2_KEY_INFO);
    const resumeMic = crypto.encrypt(resumeKey, new Uint8Array(0), import_CaseMessages.RESUME2_MIC_NONCE);
    try {
      await cx.messenger.sendSigma2Resume({
        resumptionId: cx.localResumptionId,
        resumeMic,
        responderSessionId,
        responderSessionParams: this.#sessions.sessionParameters
        // responder session parameters
      });
    } catch (error) {
      await secureSession.destroy(false);
      throw error;
    }
    logger.info(
      `Session ${secureSession.id} resumed with ${cx.messenger.getChannelName()} for Fabric ${import_types.NodeId.toHexString(
        fabric.nodeId
      )} (index ${fabric.fabricIndex}) and PeerNode ${import_types.NodeId.toHexString(peerNodeId)}`,
      "with CATs",
      caseAuthenticatedTags
    );
    cx.resumptionRecord.resumptionId = cx.localResumptionId;
    await cx.messenger.waitForSuccess("Sigma2Resume-Success");
    await cx.messenger.close();
    await this.#sessions.saveResumptionRecord(cx.resumptionRecord);
    return true;
  }
  async #generateSigma2(cx) {
    if (
      // No resumption attempted is OK
      !(cx.peerResumptionId === void 0 && cx.peerResumeMic === void 0) && // Resumption attempted with no record on our side is OK
      !(cx.peerResumptionId !== void 0 && cx.peerResumeMic !== void 0 && cx.resumptionRecord === void 0)
    ) {
      return false;
    }
    const { crypto } = this.#fabrics;
    const responderRandom = crypto.randomBytes(32);
    const fabric = await this.#fabrics.findFabricFromDestinationId(cx.destinationId, cx.peerRandom);
    const { operationalCert: nodeOpCert, intermediateCACert, operationalIdentityProtectionKey } = fabric;
    const key = await crypto.createKeyPair();
    const responderEcdhPublicKey = key.publicBits;
    const sharedSecret = await crypto.generateDhSecret(key, (0, import_general.PublicKey)(cx.peerEcdhPublicKey));
    const sigma2Salt = import_general.Bytes.concat(
      operationalIdentityProtectionKey,
      responderRandom,
      responderEcdhPublicKey,
      await crypto.computeSha256(cx.bytes)
    );
    const sigma2Key = await crypto.createHkdfKey(sharedSecret, sigma2Salt, import_CaseMessages.KDFSR2_INFO);
    const signatureData = import_CaseMessages.TlvSignedData.encode({
      responderNoc: nodeOpCert,
      responderIcac: intermediateCACert,
      responderPublicKey: responderEcdhPublicKey,
      initiatorPublicKey: cx.peerEcdhPublicKey
    });
    const signature = await fabric.sign(signatureData);
    const encryptedData = import_CaseMessages.TlvEncryptedDataSigma2.encode({
      responderNoc: nodeOpCert,
      responderIcac: intermediateCACert,
      signature,
      resumptionId: cx.localResumptionId
    });
    const encrypted = crypto.encrypt(sigma2Key, encryptedData, import_CaseMessages.TBE_DATA2_NONCE);
    const responderSessionId = await this.#sessions.getNextAvailableSessionId();
    const sigma2Bytes = await cx.messenger.sendSigma2({
      responderRandom,
      responderSessionId,
      responderEcdhPublicKey,
      encrypted,
      responderSessionParams: this.#sessions.sessionParameters
      // responder session parameters
    });
    const {
      sigma3Bytes,
      sigma3: { encrypted: peerEncrypted }
    } = await cx.messenger.readSigma3();
    const sigma3Salt = import_general.Bytes.concat(
      operationalIdentityProtectionKey,
      await crypto.computeSha256([cx.bytes, sigma2Bytes])
    );
    const sigma3Key = await crypto.createHkdfKey(sharedSecret, sigma3Salt, import_CaseMessages.KDFSR3_INFO);
    const peerDecryptedData = crypto.decrypt(sigma3Key, peerEncrypted, import_CaseMessages.TBE_DATA3_NONCE);
    const {
      responderNoc: peerNewOpCert,
      responderIcac: peerIntermediateCACert,
      signature: peerSignature
    } = import_CaseMessages.TlvEncryptedDataSigma3.decode(peerDecryptedData);
    await fabric.verifyCredentials(peerNewOpCert, peerIntermediateCACert);
    const peerSignatureData = import_CaseMessages.TlvSignedData.encode({
      responderNoc: peerNewOpCert,
      responderIcac: peerIntermediateCACert,
      responderPublicKey: cx.peerEcdhPublicKey,
      initiatorPublicKey: responderEcdhPublicKey
    });
    const {
      ellipticCurvePublicKey: peerPublicKey,
      subject: { fabricId: peerFabricId, nodeId: peerNodeId, caseAuthenticatedTags }
    } = import_Noc.Noc.fromTlv(peerNewOpCert).cert;
    if (fabric.fabricId !== peerFabricId) {
      throw new import_general.UnexpectedDataError(`Fabric ID mismatch: ${fabric.fabricId} !== ${peerFabricId}`);
    }
    await crypto.verifyEcdsa((0, import_general.PublicKey)(peerPublicKey), peerSignatureData, peerSignature);
    const secureSessionSalt = import_general.Bytes.concat(
      operationalIdentityProtectionKey,
      await crypto.computeSha256([cx.bytes, sigma2Bytes, sigma3Bytes])
    );
    const secureSession = await this.#sessions.createSecureSession({
      sessionId: responderSessionId,
      fabric,
      peerNodeId,
      peerSessionId: cx.peerSessionId,
      sharedSecret,
      salt: secureSessionSalt,
      isInitiator: false,
      isResumption: false,
      peerSessionParameters: cx.peerSessionParams,
      caseAuthenticatedTags
    });
    logger.info(
      `Session ${secureSession.id} created with ${cx.messenger.getChannelName()} for Fabric ${import_types.NodeId.toHexString(
        fabric.nodeId
      )} (index ${fabric.fabricIndex}) and PeerNode ${import_types.NodeId.toHexString(peerNodeId)}`,
      "with CATs",
      caseAuthenticatedTags
    );
    await cx.messenger.sendSuccess();
    const resumptionRecord = {
      peerNodeId,
      fabric,
      sharedSecret,
      resumptionId: cx.localResumptionId,
      sessionParameters: secureSession.parameters,
      caseAuthenticatedTags
    };
    await cx.messenger.close();
    await this.#sessions.saveResumptionRecord(resumptionRecord);
    return true;
  }
  async close() {
  }
}
class Sigma1Context {
  crypto;
  messenger;
  bytes;
  peerSessionId;
  peerResumptionId;
  peerResumeMic;
  destinationId;
  peerRandom;
  peerEcdhPublicKey;
  peerSessionParams;
  resumptionRecord;
  #localResumptionId;
  constructor(crypto, messenger, bytes, sigma1, resumptionRecord) {
    this.crypto = crypto;
    this.messenger = messenger;
    this.bytes = bytes;
    this.peerSessionId = sigma1.initiatorSessionId;
    this.peerResumptionId = sigma1.resumptionId;
    this.peerResumeMic = sigma1.initiatorResumeMic;
    this.destinationId = sigma1.destinationId;
    this.peerRandom = sigma1.initiatorRandom;
    this.peerEcdhPublicKey = sigma1.initiatorEcdhPublicKey;
    this.peerSessionParams = sigma1.initiatorSessionParams;
    this.resumptionRecord = resumptionRecord;
  }
  get localResumptionId() {
    return this.#localResumptionId ??= this.crypto.randomBytes(16);
  }
}
//# sourceMappingURL=CaseServer.js.map
