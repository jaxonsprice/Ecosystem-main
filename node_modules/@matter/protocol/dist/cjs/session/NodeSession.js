"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var NodeSession_exports = {};
__export(NodeSession_exports, {
  NoAssociatedFabricError: () => NoAssociatedFabricError,
  NoChannelError: () => NoChannelError,
  NodeSession: () => NodeSession
});
module.exports = __toCommonJS(NodeSession_exports);
var import_Subject = require("#action/server/Subject.js");
var import_MessageCodec = require("#codec/MessageCodec.js");
var import_general = require("#general");
var import_PeerAddress = require("#peer/PeerAddress.js");
var import_MessageCounter = require("#protocol/MessageCounter.js");
var import_MessageReceptionState = require("#protocol/MessageReceptionState.js");
var import_types = require("#types");
var import_SecureSession = require("./SecureSession.js");
var import_Session = require("./Session.js");
/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
const logger = import_general.Logger.get("SecureSession");
const SESSION_KEYS_INFO = import_general.Bytes.fromString("SessionKeys");
const SESSION_RESUMPTION_KEYS_INFO = import_general.Bytes.fromString("SessionResumptionKeys");
class NoChannelError extends import_general.MatterError {
}
class NoAssociatedFabricError extends import_types.StatusResponseError {
  constructor(message) {
    super(message, import_types.StatusCode.UnsupportedAccess);
  }
}
class NodeSession extends import_SecureSession.SecureSession {
  #crypto;
  #subscriptions = new import_general.BasicSet();
  #closingAfterExchangeFinished = false;
  #sendCloseMessageWhenClosing = true;
  #id;
  #isInitiator;
  #fabric;
  #peerNodeId;
  #peerSessionId;
  #decryptKey;
  #encryptKey;
  #attestationKey;
  #caseAuthenticatedTags;
  #isClosing = false;
  supportsMRP = true;
  type = import_MessageCodec.SessionType.Unicast;
  static async create(args) {
    const {
      crypto,
      manager,
      id,
      fabric,
      peerNodeId,
      peerSessionId,
      sharedSecret,
      salt,
      isInitiator,
      isResumption,
      peerSessionParameters,
      caseAuthenticatedTags
    } = args;
    const keys = await args.crypto.createHkdfKey(
      sharedSecret,
      salt,
      isResumption ? SESSION_RESUMPTION_KEYS_INFO : SESSION_KEYS_INFO,
      import_general.CRYPTO_SYMMETRIC_KEY_LENGTH * 3
    );
    const decryptKey = isInitiator ? keys.slice(16, 32) : keys.slice(0, 16);
    const encryptKey = isInitiator ? keys.slice(0, 16) : keys.slice(16, 32);
    const attestationKey = keys.slice(32, 48);
    return new NodeSession({
      crypto,
      manager,
      id,
      fabric,
      peerNodeId,
      peerSessionId,
      decryptKey,
      encryptKey,
      attestationKey,
      sessionParameters: peerSessionParameters,
      isInitiator,
      caseAuthenticatedTags
    });
  }
  constructor(args) {
    const {
      crypto,
      manager,
      id,
      fabric,
      peerNodeId,
      peerSessionId,
      decryptKey,
      encryptKey,
      attestationKey,
      caseAuthenticatedTags,
      isInitiator
    } = args;
    super({
      ...args,
      setActiveTimestamp: true,
      // We always set the active timestamp for Secure sessions
      // Can be changed to a PersistedMessageCounter if we implement session storage
      messageCounter: new import_MessageCounter.MessageCounter(crypto, () => {
        this.end(true, true).catch((error) => logger.error(`Error while closing session: ${error}`));
      }),
      messageReceptionState: new import_MessageReceptionState.MessageReceptionStateEncryptedWithoutRollover()
    });
    this.#crypto = crypto;
    this.#id = id;
    this.#fabric = fabric;
    this.#peerNodeId = peerNodeId;
    this.#peerSessionId = peerSessionId;
    this.#decryptKey = decryptKey;
    this.#encryptKey = encryptKey;
    this.#attestationKey = attestationKey;
    this.#caseAuthenticatedTags = caseAuthenticatedTags ?? [];
    this.#isInitiator = isInitiator;
    manager?.sessions.add(this);
    fabric?.addSession(this);
    logger.debug(
      `Created secure ${this.isPase ? "PASE" : "CASE"} session for fabric index ${fabric?.fabricIndex}`,
      this.name,
      this.parameterDiagnostics()
    );
  }
  parameterDiagnostics() {
    return import_general.Diagnostic.dict(
      {
        SII: this.idleIntervalMs,
        SAI: this.activeIntervalMs,
        SAT: this.activeThresholdMs,
        DMRev: this.dataModelRevision,
        IMRev: this.interactionModelRevision,
        spec: import_general.Diagnostic.hex(this.specificationVersion),
        maxPaths: this.maxPathsPerInvoke,
        CATs: this.#caseAuthenticatedTags
      },
      true
    );
  }
  get caseAuthenticatedTags() {
    return this.#caseAuthenticatedTags;
  }
  get closingAfterExchangeFinished() {
    return this.#closingAfterExchangeFinished;
  }
  get sendCloseMessageWhenClosing() {
    return this.#sendCloseMessageWhenClosing;
  }
  get isPase() {
    return this.#peerNodeId === import_types.NodeId.UNSPECIFIED_NODE_ID;
  }
  get subscriptions() {
    return this.#subscriptions;
  }
  get isInitiator() {
    return this.#isInitiator;
  }
  get isClosing() {
    return this.#isClosing;
  }
  subjectFor(_message) {
    return import_Subject.Subject.Node({
      id: this.peerNodeId,
      catSubjects: this.#caseAuthenticatedTags.map((cat) => import_types.NodeId.fromCaseAuthenticatedTag(cat))
    });
  }
  async close(closeAfterExchangeFinished) {
    if (closeAfterExchangeFinished === void 0) {
      closeAfterExchangeFinished = this.isPeerActive();
    }
    await this.end(true, closeAfterExchangeFinished);
  }
  decode({ header, applicationPayload, messageExtension }, aad) {
    if (header.hasMessageExtensions) {
      logger.info(
        `Message extensions are not supported. Ignoring ${messageExtension ? import_general.Bytes.toHex(messageExtension) : void 0}`
      );
    }
    const nonce = import_Session.Session.generateNonce(header.securityFlags, header.messageId, this.#peerNodeId);
    const message = import_MessageCodec.MessageCodec.decodePayload({
      header,
      applicationPayload: this.#crypto.decrypt(this.#decryptKey, applicationPayload, nonce, aad)
    });
    if (message.payloadHeader.hasSecuredExtension) {
      logger.info(
        `Secured extensions are not supported. Ignoring ${message.securityExtension ? import_general.Bytes.toHex(message.securityExtension) : void 0}`
      );
    }
    return message;
  }
  encode(message) {
    message.packetHeader.sessionId = this.#peerSessionId;
    const { header, applicationPayload } = import_MessageCodec.MessageCodec.encodePayload(message);
    const headerBytes = import_MessageCodec.MessageCodec.encodePacketHeader(message.packetHeader);
    const securityFlags = headerBytes[3];
    const sessionNodeId = this.isPase ? import_types.NodeId.UNSPECIFIED_NODE_ID : this.#fabric?.nodeId ?? import_types.NodeId.UNSPECIFIED_NODE_ID;
    const nonce = import_Session.Session.generateNonce(securityFlags, header.messageId, sessionNodeId);
    return {
      header,
      applicationPayload: this.#crypto.encrypt(this.#encryptKey, applicationPayload, nonce, headerBytes)
    };
  }
  get attestationChallengeKey() {
    return this.#attestationKey;
  }
  get fabric() {
    return this.#fabric;
  }
  addAssociatedFabric(fabric) {
    if (this.#fabric !== void 0) {
      throw new import_general.MatterFlowError("Session already has an associated Fabric. Cannot change this.");
    }
    this.#fabric = fabric;
  }
  get id() {
    return this.#id;
  }
  get name() {
    return `secure/${this.#id}`;
  }
  get peerSessionId() {
    return this.#peerSessionId;
  }
  get nodeId() {
    return this.#fabric?.nodeId ?? import_types.NodeId.UNSPECIFIED_NODE_ID;
  }
  get peerNodeId() {
    return this.#peerNodeId;
  }
  get associatedFabric() {
    if (this.#fabric === void 0) {
      throw new NoAssociatedFabricError(
        `${this.isPase ? "PASE " : ""}Session needs to have an associated Fabric for fabric sensitive data handling.`
      );
    }
    return this.#fabric;
  }
  async clearSubscriptions(flushSubscriptions = false, cancelledByPeer = false) {
    const subscriptions = [...this.#subscriptions];
    for (const subscription of subscriptions) {
      await subscription.close(flushSubscriptions, cancelledByPeer);
    }
    return subscriptions.length;
  }
  /** Ends a session. Outstanding subscription data will be flushed before the session is destroyed. */
  async end(sendClose, closeAfterExchangeFinished = false) {
    await this.clearSubscriptions(true);
    await this.destroy(sendClose, closeAfterExchangeFinished);
  }
  /** Destroys a session. Outstanding subscription data will be discarded. */
  async destroy(sendClose = false, closeAfterExchangeFinished = true) {
    await this.clearSubscriptions(false);
    this.#fabric?.removeSession(this);
    if (!sendClose) {
      this.#sendCloseMessageWhenClosing = false;
    }
    if (closeAfterExchangeFinished) {
      logger.info(`Register Session ${this.name} to close when exchange is ended.`);
      this.#closingAfterExchangeFinished = true;
    } else {
      this.#isClosing = true;
      logger.info(`End ${this.isPase ? "PASE" : "CASE"} session ${this.name}`);
      this.manager?.sessions.delete(this);
      if (this.closer) {
        try {
          await this.closer;
        } catch (error) {
          NoChannelError.accept(error);
        } finally {
          await this.destroyed.emit();
        }
        return;
      }
      await this.destroyed.emit();
    }
  }
  /**
   * The peer node's address.
   */
  get peerAddress() {
    return (0, import_PeerAddress.PeerAddress)({
      fabricIndex: this.#fabric?.fabricIndex ?? import_types.FabricIndex.NO_FABRIC,
      nodeId: this.#peerNodeId
    });
  }
  /**
   * Indicates whether a peer matches a specific address.
   */
  peerIs(address) {
    return (this.#fabric?.fabricIndex ?? import_types.FabricIndex.NO_FABRIC) === address.fabricIndex && this.#peerNodeId === address.nodeId;
  }
}
((NodeSession2) => {
  function assert(session, errorText) {
    if (!is(session)) {
      throw new import_general.MatterFlowError(errorText ?? "Insecure session in secure context");
    }
  }
  NodeSession2.assert = assert;
  function is(session) {
    return session?.type === import_MessageCodec.SessionType.Unicast;
  }
  NodeSession2.is = is;
})(NodeSession || (NodeSession = {}));
//# sourceMappingURL=NodeSession.js.map
