/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { DecodedPacket } from "#codec/MessageCodec.js";
import { FabricManager } from "#fabric/FabricManager.js";
import { BasicSet, Construction, Environment, Environmental, Observable, StorageContext } from "#general";
import { Subscription } from "#interaction/Subscription.js";
import { PeerAddress } from "#peer/PeerAddress.js";
import { GroupSession } from "#session/GroupSession.js";
import { CaseAuthenticatedTag, FabricIndex, NodeId } from "#types";
import { Fabric } from "../fabric/Fabric.js";
import { InsecureSession } from "./InsecureSession.js";
import { NodeSession } from "./NodeSession.js";
import { Session, SessionParameterOptions, SessionParameters } from "./Session.js";
export interface ResumptionRecord {
    sharedSecret: Uint8Array;
    resumptionId: Uint8Array;
    fabric: Fabric;
    peerNodeId: NodeId;
    sessionParameters: SessionParameters;
    caseAuthenticatedTags?: CaseAuthenticatedTag[];
}
/**
 * Interfaces {@link SessionManager} with other components.
 */
export interface SessionManagerContext {
    fabrics: FabricManager;
    storage: StorageContext;
    /**
     * Parameter overrides.
     */
    parameters?: Partial<SessionParameters>;
    /**
     * This is an arbitrary contextual object attached to sessions used for compatibility with legacy APIs.
     *
     * @deprecated
     */
    owner?: unknown;
}
/**
 * Manages Matter sessions associated with peer connections.
 */
export declare class SessionManager {
    #private;
    constructor(context: SessionManagerContext);
    static [Environmental.create](env: Environment): SessionManager;
    get construction(): Construction<SessionManager>;
    get context(): SessionManagerContext;
    get crypto(): import("#general").Crypto;
    /**
     * Active secure sessions.
     */
    get sessions(): BasicSet<NodeSession, NodeSession>;
    /**
     * Active insecure sessions.
     */
    get insecureSessions(): Map<NodeId, InsecureSession>;
    /**
     * Our session parameters.  These are the parameters we provide during session negotiation.  The peer may specify
     * different parameters.
     */
    get sessionParameters(): SessionParameters;
    /**
     * Change session parameters.
     *
     * Parameters values you omit in {@link parameters} will retain their current values.  This only affects new
     * sessions.
     */
    set sessionParameters(parameters: Partial<SessionParameters>);
    /**
     * Emits when there is a change to the subscription set.
     */
    get subscriptionsChanged(): Observable<[session: NodeSession, subscription: Subscription], void>;
    /**
     * Emits when resubmission is necessary due to timeout or network error.
     */
    get resubmissionStarted(): Observable<[session: Session], void>;
    /**
     * Convenience function for accessing a fabric by address.
     */
    fabricFor(address: FabricIndex | PeerAddress): Fabric;
    /**
     * @deprecated
     */
    get owner(): unknown;
    createInsecureSession(options: {
        initiatorNodeId?: NodeId;
        sessionParameters?: SessionParameterOptions;
        isInitiator?: boolean;
    }): InsecureSession;
    createSecureSession(args: {
        sessionId: number;
        fabric: Fabric | undefined;
        peerNodeId: NodeId;
        peerSessionId: number;
        sharedSecret: Uint8Array;
        salt: Uint8Array;
        isInitiator: boolean;
        isResumption: boolean;
        peerSessionParameters?: SessionParameterOptions;
        caseAuthenticatedTags?: CaseAuthenticatedTag[];
    }): Promise<NodeSession>;
    /**
     * Deletes a resumption record for a given address.  Returns true if the record was deleted, false if it did not
     * exist.
     */
    deleteResumptionRecord(address: PeerAddress): Promise<boolean>;
    /**
     * Deletes all resumption records for a given fabric.  Returns true if any records were deleted, false if none
     * existed.
     */
    deleteResumptionRecordsForFabric(fabric: Fabric): Promise<boolean>;
    findOldestInactiveSession(): NodeSession;
    getNextAvailableSessionId(): Promise<number>;
    getSession(sessionId: number): NodeSession | undefined;
    getPaseSession(): NodeSession;
    getSessionForNode(address: PeerAddress): NodeSession | undefined;
    removeAllSessionsForNode(address: PeerAddress, sendClose?: boolean, closeBeforeCreatedTimestamp?: number): Promise<void>;
    getUnsecureSession(sourceNodeId?: NodeId): InsecureSession | undefined;
    /**
     * Creates or Returns a Group Session for a Group Peer Address.
     * This is used for sending group messages because it returns the session for the current
     * Group Epoch key. The Source Node Id is the own Node.
     */
    groupSessionForAddress(address: PeerAddress): GroupSession;
    /**
     * Creates or Returns the Group session based on an incoming packet.
     * The Session ID is determined by trying to decrypt te packet with possible keys.
     */
    groupSessionFromPacket(packet: DecodedPacket, aad: Uint8Array): {
        session: GroupSession;
        message: import("#codec/MessageCodec.js").DecodedMessage;
        key: Uint8Array<ArrayBufferLike>;
    };
    registerGroupSession(session: GroupSession): void;
    removeGroupSession(session: GroupSession): void;
    findResumptionRecordById(resumptionId: Uint8Array): ResumptionRecord | undefined;
    findResumptionRecordByAddress(address: PeerAddress): ResumptionRecord | undefined;
    saveResumptionRecord(resumptionRecord: ResumptionRecord): Promise<void>;
    getActiveSessionInformation(): {
        name: string;
        nodeId: NodeId;
        peerNodeId: NodeId;
        fabric: import("../fabric/Fabric.js").ExposedFabricInformation | undefined;
        isPeerActive: boolean;
        secure: boolean;
        lastInteractionTimestamp: number | undefined;
        lastActiveTimestamp: number | undefined;
        numberOfActiveSubscriptions: number;
    }[];
    close(): Promise<void>;
    clear(): Promise<void>;
    updateAllSubscriptions(): void;
    /** Clears all subscriptions for a given node and returns how many were cleared. */
    clearSubscriptionsForNode(peerAddress: PeerAddress, flushSubscriptions?: boolean): Promise<number>;
    /**
     * Compress range of IDs.  This is intended for testing.
     */
    compressIdRange(upperBound: number): void;
}
//# sourceMappingURL=SessionManager.d.ts.map