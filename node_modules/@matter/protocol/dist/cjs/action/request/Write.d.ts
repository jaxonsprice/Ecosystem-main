/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { AttributeData, ClusterType, WriteRequest } from "#types";
import { Specifier } from "./Specifier.js";
export interface Write extends WriteRequest {
    /** Timeout only relevant for Client Interactions */
    timeout?: number;
}
/**
 * Formulate a write-request using Matter numeric IDs.
 */
export declare function Write(options: Write.Options): Write;
/**
 * Formulate a write-request with extended options and name-based IDs.
 */
export declare function Write(options: Write.Options, ...data: Write.Attribute[]): Write;
/**
 * Formulate a write-request with name-based IDs.
 */
export declare function Write(...data: Write.Attribute[]): Write;
export declare namespace Write {
    interface Options {
        writes?: AttributeData[];
        timed?: boolean;
        timeout?: number;
        interactionModelRevision?: number;
    }
    /**
     * Selects attributes to Write.  Limits fields to legal permutations per the Matter specification.
     */
    type Attribute<C extends Specifier.Cluster = Specifier.Cluster> = (Attribute.Concrete<C> | Attribute.WildcardEndpoint<C>) & {
        kind: "attribute";
        value: any;
        version?: number;
    };
    function Attribute<const C extends ClusterType>(data: Omit<Attribute<C>, "kind">): Attribute<C>;
    namespace Attribute {
        interface Concrete<C extends Specifier.Cluster> {
            endpoint: Specifier.Endpoint;
            cluster: C;
            attributes: Specifier.Attribute<Specifier.ClusterFor<C>> | Specifier.Attribute<Specifier.ClusterFor<C>>[];
        }
        interface WildcardEndpoint<C extends Specifier.Cluster> {
            endpoint?: undefined;
            cluster: C;
            attributes: Specifier.Attribute<Specifier.ClusterFor<C>> | Specifier.Attribute<Specifier.ClusterFor<C>>[];
        }
    }
}
//# sourceMappingURL=Write.d.ts.map