"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var ClientInteraction_exports = {};
__export(ClientInteraction_exports, {
  ClientInteraction: () => ClientInteraction,
  DEFAULT_MIN_INTERVAL_FLOOR_SECONDS: () => DEFAULT_MIN_INTERVAL_FLOOR_SECONDS
});
module.exports = __toCommonJS(ClientInteraction_exports);
var import_general = require("#general");
var import_InteractionMessenger = require("#interaction/InteractionMessenger.js");
var import_InteractionQueue = require("#peer/InteractionQueue.js");
var import_ExchangeProvider = require("#protocol/ExchangeProvider.js");
var import_types = require("#types");
var import_ClientSubscriptions = require("./ClientSubscriptions.js");
var import_InputChunk = require("./InputChunk.js");
/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
const DEFAULT_MIN_INTERVAL_FLOOR_SECONDS = 1;
class ClientInteraction {
  #exchanges;
  #subscriptions;
  #queue;
  #interactions = new import_general.BasicSet();
  #closed = false;
  constructor(context) {
    this.#exchanges = context.exchanges;
    this.#subscriptions = context.subscriptions;
    this.#queue = context.queue;
  }
  async close() {
    this.#closed = true;
    while (this.#interactions.size) {
      await this.#interactions.deleted;
    }
  }
  get subscriptions() {
    return this.#subscriptions;
  }
  get queue() {
    return this.#queue;
  }
  static [import_general.Environmental.create](env) {
    const instance = new ClientInteraction({
      exchanges: env.get(import_ExchangeProvider.ExchangeProvider),
      subscriptions: env.get(import_ClientSubscriptions.ClientSubscriptions),
      queue: env.get(import_InteractionQueue.InteractionQueue)
    });
    env.set(ClientInteraction, instance);
    return instance;
  }
  async *read(request, _session) {
    try {
      this.#begin(request);
      const messenger = await import_InteractionMessenger.InteractionClientMessenger.create(this.#exchanges);
      await messenger.sendReadRequest(request);
      for await (const report of messenger.readDataReports()) {
        yield (0, import_InputChunk.InputChunk)(report);
      }
    } finally {
      this.#end(request);
    }
  }
  async write(request, _session) {
    let messenger;
    try {
      this.#begin(request);
      messenger = await import_InteractionMessenger.InteractionClientMessenger.create(this.#exchanges);
      const response = await messenger.sendWriteCommand(request);
      if (request.suppressResponse) {
        return void 0;
      }
      if (!response || !response.writeResponses?.length) {
        return new Array();
      } else {
        return response.writeResponses.map(
          ({
            path: { nodeId, endpointId, clusterId, attributeId, listIndex },
            status: { status, clusterStatus }
          }) => ({
            kind: "attr-status",
            path: {
              nodeId,
              endpointId,
              clusterId,
              attributeId,
              listIndex
            },
            status,
            clusterStatus
          })
        );
      }
    } finally {
      await messenger?.close();
      this.#end(request);
    }
  }
  async *invoke(request, _session) {
    let messenger;
    try {
      this.#begin(request);
      messenger = await import_InteractionMessenger.InteractionClientMessenger.create(this.#exchanges);
      const result = await messenger.sendInvokeCommand(request);
      if (!request.suppressResponse) {
        if (result && result.invokeResponses?.length) {
          const chunk = result.invokeResponses.map((response) => {
            if (response.command !== void 0) {
              const {
                commandPath: { endpointId, clusterId, commandId },
                commandRef,
                commandFields
              } = response.command;
              const res = {
                kind: "cmd-response",
                path: {
                  endpointId,
                  clusterId,
                  commandId
                },
                commandRef,
                data: commandFields
                // TODO add decoding
              };
              return res;
            } else if (response.status !== void 0) {
              const {
                commandPath: { endpointId, clusterId, commandId },
                commandRef,
                status: { status, clusterStatus }
              } = response.status;
              const res = {
                kind: "cmd-status",
                path: {
                  endpointId,
                  clusterId,
                  commandId
                },
                commandRef,
                status,
                clusterStatus
              };
              return res;
            } else {
              return void 0;
            }
          }).filter((r) => r !== void 0);
          yield chunk;
        } else {
          yield [];
        }
      }
    } finally {
      await messenger?.close();
      this.#end(request);
    }
  }
  async subscribe(request, _session) {
    let messenger;
    try {
      this.#begin(request);
      messenger = await import_InteractionMessenger.InteractionClientMessenger.create(this.#exchanges);
      await messenger.sendSubscribeRequest({
        ...request,
        minIntervalFloorSeconds: DEFAULT_MIN_INTERVAL_FLOOR_SECONDS,
        maxIntervalCeilingSeconds: DEFAULT_MIN_INTERVAL_FLOOR_SECONDS
      });
      await this.#handleSubscriptionResponse(request, readChunks(messenger));
      const responseMessage = await messenger.nextMessage(import_InteractionMessenger.MessageType.SubscribeResponse);
      const response = import_types.TlvSubscribeResponse.decode(responseMessage.payload);
      return this.#subscriptions.add(request, response);
    } finally {
      await messenger?.close();
      this.#end(request);
    }
  }
  async #handleSubscriptionResponse(request, result) {
    if (request.updated) {
      await request.updated(result);
    } else {
      for await (const _chunk of result) ;
    }
  }
  #begin(request) {
    if (this.#closed) {
      throw new import_general.ImplementationError("Client interaction unavailable after close");
    }
    this.#interactions.add(request);
  }
  #end(request) {
    this.#interactions.delete(request);
  }
}
async function* readChunks(messenger) {
  for await (const report of messenger.readDataReports()) {
    yield (0, import_InputChunk.InputChunk)(report);
  }
}
//# sourceMappingURL=ClientInteraction.js.map
