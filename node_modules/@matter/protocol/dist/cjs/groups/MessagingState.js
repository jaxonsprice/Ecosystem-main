"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var MessagingState_exports = {};
__export(MessagingState_exports, {
  MessagingState: () => MessagingState
});
module.exports = __toCommonJS(MessagingState_exports);
var import_general = require("#general");
var import_MessageCounter = require("#protocol/MessageCounter.js");
var import_MessageReceptionState = require("#protocol/MessageReceptionState.js");
/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
class MessagingState {
  /**
   * Message counter for sending data messages to a group per Operational key. No need to scope to a source node
   * because we are the sending node
   * TODO: For management: Make sure to start rotating the key early enough that a former counter-value is not used
   *  again for the same key.
   */
  #groupDataCounters = /* @__PURE__ */ new Map();
  /** Message reception state for data messages per Operational key and source node. */
  #messageDataReceptionState = /* @__PURE__ */ new Map();
  #crypto;
  #storage;
  constructor(crypto, storage) {
    this.#crypto = crypto;
    if (storage !== void 0) {
      this.#storage = storage;
    }
  }
  set storage(storage) {
    if (this.#storage !== void 0) {
      throw new import_general.InternalError("Storage context can only be set once.");
    }
    this.#storage = storage;
  }
  /**
   * Return the message counter for sending messages to a group with the given operational key.
   */
  counterFor(operationalKey) {
    if (!this.#storage) {
      throw new import_general.ImplementationError("Group session cannot be created without storage context.");
    }
    const operationalKeyHex = import_general.Bytes.toHex(operationalKey);
    let counter = this.#groupDataCounters.get(operationalKeyHex);
    if (counter === void 0) {
      counter = new import_MessageCounter.PersistedMessageCounter(this.#crypto, this.#storage, `${operationalKeyHex}-data`);
      this.#groupDataCounters.set(operationalKeyHex, counter);
    }
    return counter;
  }
  async removeCounter(key, forDelete = false) {
    const operationalKeyHex = import_general.Bytes.toHex(key);
    this.#groupDataCounters.delete(operationalKeyHex);
    if (forDelete) {
      await this.#storage?.delete(`${operationalKeyHex}-data`);
    }
  }
  /**
   * Returns the message reception state for a given source node id and operational key.
   */
  receptionStateFor(sourceNodeId, operationalKey) {
    const operationalKeyHex = import_general.Bytes.toHex(operationalKey);
    let receptionState = this.#messageDataReceptionState.get(operationalKeyHex)?.get(sourceNodeId);
    if (receptionState === void 0) {
      receptionState = new import_MessageReceptionState.MessageReceptionStateEncryptedWithRollover();
      const keyMap = this.#messageDataReceptionState.get(operationalKeyHex) ?? /* @__PURE__ */ new Map();
      keyMap.set(sourceNodeId, receptionState);
      this.#messageDataReceptionState.set(operationalKeyHex, keyMap);
    }
    return receptionState;
  }
}
//# sourceMappingURL=MessagingState.js.map
