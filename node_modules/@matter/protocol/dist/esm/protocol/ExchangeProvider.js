/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { Observable } from "#general";
import {
  ChannelNotConnectedError,
  DEFAULT_EXPECTED_PROCESSING_TIME_MS
} from "#protocol/MessageChannel.js";
import { INTERACTION_PROTOCOL_ID } from "#types";
class ExchangeProvider {
  constructor(exchangeManager) {
    this.exchangeManager = exchangeManager;
  }
  hasProtocolHandler(protocolId) {
    return this.exchangeManager.hasProtocolHandler(protocolId);
  }
  getProtocolHandler(protocolId) {
    return this.exchangeManager.getProtocolHandler(protocolId);
  }
  addProtocolHandler(handler) {
    this.exchangeManager.addProtocolHandler(handler);
  }
}
class DedicatedChannelExchangeProvider extends ExchangeProvider {
  #channel;
  supportsReconnect = false;
  constructor(exchangeManager, channel) {
    super(exchangeManager);
    this.#channel = channel;
  }
  async initiateExchange() {
    return this.exchangeManager.initiateExchangeWithChannel(this.#channel, INTERACTION_PROTOCOL_ID);
  }
  async reconnectChannel() {
    return false;
  }
  get session() {
    return this.#channel.session;
  }
  get channelType() {
    return this.#channel.type;
  }
  maximumPeerResponseTimeMs(expectedProcessingTimeMs = DEFAULT_EXPECTED_PROCESSING_TIME_MS) {
    return this.exchangeManager.calculateMaximumPeerResponseTimeMsFor(this.#channel, expectedProcessingTimeMs);
  }
}
class ReconnectableExchangeProvider extends ExchangeProvider {
  constructor(exchangeManager, channelManager, address, reconnectChannelFunc) {
    super(exchangeManager);
    this.channelManager = channelManager;
    this.#address = address;
    this.#reconnectChannelFunc = reconnectChannelFunc;
    channelManager.added.on((address2) => {
      if (address2 === this.#address) {
        this.#channelUpdated.emit();
      }
    });
  }
  supportsReconnect = true;
  #address;
  #reconnectChannelFunc;
  #channelUpdated = Observable();
  get channelUpdated() {
    return this.#channelUpdated;
  }
  async initiateExchange() {
    if (!this.channelManager.hasChannel(this.#address)) {
      await this.reconnectChannel();
    }
    if (!this.channelManager.hasChannel(this.#address)) {
      throw new ChannelNotConnectedError("Channel not connected");
    }
    return this.exchangeManager.initiateExchange(this.#address, INTERACTION_PROTOCOL_ID);
  }
  async reconnectChannel() {
    if (this.#reconnectChannelFunc === void 0) return false;
    await this.#reconnectChannelFunc();
    return true;
  }
  get session() {
    if (!this.channelManager.hasChannel(this.#address)) {
      throw new ChannelNotConnectedError("Channel not connected");
    }
    return this.channelManager.getChannel(this.#address).session;
  }
  get channelType() {
    if (!this.channelManager.hasChannel(this.#address)) {
      throw new ChannelNotConnectedError("Channel not connected");
    }
    return this.channelManager.getChannel(this.#address).type;
  }
  maximumPeerResponseTimeMs(expectedProcessingTimeMs = DEFAULT_EXPECTED_PROCESSING_TIME_MS) {
    const channel = this.channelManager.getChannel(this.#address);
    if (!channel) {
      throw new ChannelNotConnectedError("Channel not connected");
    }
    return this.exchangeManager.calculateMaximumPeerResponseTimeMsFor(channel, expectedProcessingTimeMs);
  }
}
export {
  DedicatedChannelExchangeProvider,
  ExchangeProvider,
  ReconnectableExchangeProvider
};
//# sourceMappingURL=ExchangeProvider.js.map
