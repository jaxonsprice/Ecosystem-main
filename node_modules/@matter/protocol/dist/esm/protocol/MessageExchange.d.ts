/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { Message } from "#codec/MessageCodec.js";
import { AsyncObservable, MatterError, NoResponseTimeoutError } from "#general";
import { MessageChannel } from "#protocol/MessageChannel.js";
import { SessionParameters } from "#session/Session.js";
import { NodeId } from "#types";
export declare class RetransmissionLimitReachedError extends NoResponseTimeoutError {
}
export declare class UnexpectedMessageError extends MatterError {
    readonly receivedMessage: Message;
    constructor(message: string, receivedMessage: Message);
}
export type ExchangeLogContext = Record<string, unknown>;
export type ExchangeSendOptions = {
    /**
     * The response to this send should be an ack only and no StatusResponse or such. If a StatusResponse is returned
     * then this is handled as error.
     */
    expectAckOnly?: boolean;
    /**
     * If the message is part of a multiple message interaction, this flag indicates that it is not allowed
     * to establish a new exchange
     */
    multipleMessageInteraction?: boolean;
    /**
     * Defined an expected processing time by the responder for the message. This is used to calculate the final
     * timeout for responses together with the normal retransmission logic when MRP is used.
     */
    expectedProcessingTimeMs?: number;
    /** Allows to specify if the send message requires to be acknowledged by the receiver or not. */
    requiresAck?: boolean;
    /** Use the provided acknowledge MessageId instead checking the latest to send one */
    includeAcknowledgeMessageId?: number;
    /**
     * Disables the MRP logic which means that no retransmissions are done and receiving an ack is not awaited.
     */
    disableMrpLogic?: boolean;
    /** Additional context information for logging to be included at the beginning of the Message log. */
    logContext?: ExchangeLogContext;
};
/**
 * Message size overhead of a Matter message:
 * 26 (Matter Message Header) + 12 (Matter Payload Header) taken from https://github.com/project-chip/connectedhomeip/blob/2d97cda23024e72f36216900ca667bf1a0d9499f/src/system/SystemConfig.h#L327
 * 16 byte MIC is then also needed to be excluded from the max payload size
 * Secure Extensions and Message Extensions need to be handled by exchange additionally!
 */
export declare const MATTER_MESSAGE_OVERHEAD: number;
/**
 * Interfaces {@link MessageExchange} with other components.
 */
export interface MessageExchangeContext {
    channel: MessageChannel;
    resubmissionStarted(): void;
    localSessionParameters: SessionParameters;
}
export declare class MessageExchange {
    #private;
    readonly context: MessageExchangeContext;
    readonly isInitiator: boolean;
    readonly requiresSecureSession: boolean;
    static fromInitialMessage(context: MessageExchangeContext, initialMessage: Message): MessageExchange;
    static initiate(context: MessageExchangeContext, exchangeId: number, protocolId: number): MessageExchange;
    constructor(context: MessageExchangeContext, isInitiator: boolean, peerSessionId: number, nodeId: NodeId | undefined, peerNodeId: NodeId | undefined, exchangeId: number, protocolId: number, requiresSecureSession: boolean);
    /** Emits when the exchange is actually closed. This happens after all Retries and Communication are done. */
    get closed(): AsyncObservable<[], void>;
    /**
     * Emit when the exchange is closing, but not yet closed. We only wait for acks and retries to happen, but the
     * actual interaction logic is already done.
     */
    get closing(): AsyncObservable<[], void>;
    get isClosing(): boolean;
    get id(): number;
    get channel(): MessageChannel;
    get session(): import("#session/Session.js").Session;
    /**
     * Max Payload size of the exchange which bases on the maximum payload size of the channel reduced by Matter
     * protocol overhead.
     */
    get maxPayloadSize(): number;
    sendStandaloneAckForMessage(message: Message): Promise<void>;
    onMessageReceived(message: Message, duplicate?: boolean): Promise<void>;
    send(messageType: number, payload: Uint8Array, options?: ExchangeSendOptions): Promise<void>;
    nextMessage(options?: {
        expectedProcessingTimeMs?: number;
        timeoutMs?: number;
    }): Promise<Message>;
    calculateMaximumPeerResponseTimeMs(expectedProcessingTimeMs?: number): number;
    destroy(): Promise<void>;
    startTimedInteraction(timeoutMs: number): void;
    clearTimedInteraction(): void;
    hasTimedInteraction(): boolean;
    hasActiveTimedInteraction(): boolean;
    hasExpiredTimedInteraction(): boolean;
    close(force?: boolean): Promise<void>;
}
//# sourceMappingURL=MessageExchange.d.ts.map