/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { MessageCodec, SessionType } from "#codec/MessageCodec.js";
import {
  AsyncObservable,
  createPromise,
  CRYPTO_AEAD_MIC_LENGTH_BYTES,
  DataReadQueue,
  Diagnostic,
  InternalError,
  Logger,
  MatterError,
  MatterFlowError,
  NoResponseTimeoutError,
  Time
} from "#general";
import {
  ChannelNotConnectedError,
  DEFAULT_EXPECTED_PROCESSING_TIME_MS,
  MRP
} from "#protocol/MessageChannel.js";
import { GroupSession } from "#session/GroupSession.js";
import {
  SESSION_ACTIVE_INTERVAL_MS,
  SESSION_ACTIVE_THRESHOLD_MS,
  SESSION_IDLE_INTERVAL_MS
} from "#session/Session.js";
import {
  GroupId,
  SECURE_CHANNEL_PROTOCOL_ID,
  SecureMessageType,
  StatusCode,
  StatusResponseError
} from "#types";
const logger = Logger.get("MessageExchange");
class RetransmissionLimitReachedError extends NoResponseTimeoutError {
}
class UnexpectedMessageError extends MatterError {
  constructor(message, receivedMessage) {
    super(`(${MessageCodec.messageDiagnostics(receivedMessage)}) ${message}`);
    this.receivedMessage = receivedMessage;
  }
}
const MATTER_MESSAGE_OVERHEAD = 26 + 12 + CRYPTO_AEAD_MIC_LENGTH_BYTES;
class MessageExchange {
  constructor(context, isInitiator, peerSessionId, nodeId, peerNodeId, exchangeId, protocolId, requiresSecureSession) {
    this.context = context;
    this.isInitiator = isInitiator;
    this.requiresSecureSession = requiresSecureSession;
    const { channel } = context;
    const { session } = channel;
    this.#peerSessionId = peerSessionId;
    this.#nodeId = nodeId;
    this.#peerNodeId = peerNodeId;
    this.#exchangeId = exchangeId;
    this.#protocolId = protocolId;
    const { activeIntervalMs, idleIntervalMs, activeThresholdMs } = session.parameters;
    this.#activeIntervalMs = activeIntervalMs ?? SESSION_ACTIVE_INTERVAL_MS;
    this.#idleIntervalMs = idleIntervalMs ?? SESSION_IDLE_INTERVAL_MS;
    this.#activeThresholdMs = activeThresholdMs ?? SESSION_ACTIVE_THRESHOLD_MS;
    this.#used = !isInitiator;
    logger.debug(
      "New exchange",
      isInitiator ? "\xBB" : "\xAB",
      Diagnostic.dict({
        channel: channel.name,
        protocol: this.#protocolId,
        exId: this.#exchangeId,
        sess: session.name,
        peerSess: this.#peerSessionId,
        SAT: this.#activeThresholdMs,
        SAI: this.#activeIntervalMs,
        SII: this.#idleIntervalMs,
        maxTrans: MRP.MAX_TRANSMISSIONS,
        exchangeFlags: Diagnostic.asFlags({
          MRP: this.channel.usesMrp,
          I: this.isInitiator
        })
      })
    );
  }
  static fromInitialMessage(context, initialMessage) {
    const {
      channel: { session }
    } = context;
    return new MessageExchange(
      context,
      false,
      session.id,
      initialMessage.packetHeader.destNodeId,
      initialMessage.packetHeader.sourceNodeId,
      initialMessage.payloadHeader.exchangeId,
      initialMessage.payloadHeader.protocolId,
      session.isSecure
    );
  }
  static initiate(context, exchangeId, protocolId) {
    const {
      channel: { session }
    } = context;
    return new MessageExchange(
      context,
      true,
      session.peerSessionId,
      session.nodeId,
      session.peerNodeId,
      exchangeId,
      protocolId,
      session.isSecure
    );
  }
  #activeIntervalMs;
  #idleIntervalMs;
  #activeThresholdMs;
  #messagesQueue = new DataReadQueue();
  #receivedMessageToAck;
  #receivedMessageAckTimer = Time.getTimer("Ack receipt timeout", MRP.STANDALONE_ACK_TIMEOUT_MS, () => {
    if (this.#receivedMessageToAck !== void 0) {
      const messageToAck = this.#receivedMessageToAck;
      this.#receivedMessageToAck = void 0;
      this.sendStandaloneAckForMessage(messageToAck).catch(
        (error) => logger.error("An error happened when sending a standalone ack", error)
      );
    }
  });
  #sentMessageToAck;
  #sentMessageAckSuccess;
  #sentMessageAckFailure;
  #retransmissionTimer;
  #retransmissionCounter = 0;
  #closeTimer;
  #isClosing = false;
  #timedInteractionTimer;
  #used;
  #peerSessionId;
  #nodeId;
  #peerNodeId;
  #exchangeId;
  #protocolId;
  #closed = AsyncObservable();
  #closing = AsyncObservable();
  /** Emits when the exchange is actually closed. This happens after all Retries and Communication are done. */
  get closed() {
    return this.#closed;
  }
  /**
   * Emit when the exchange is closing, but not yet closed. We only wait for acks and retries to happen, but the
   * actual interaction logic is already done.
   */
  get closing() {
    return this.#closing;
  }
  get isClosing() {
    return this.#isClosing;
  }
  get id() {
    return this.#exchangeId;
  }
  get channel() {
    return this.context.channel;
  }
  get session() {
    return this.channel.session;
  }
  /**
   * Max Payload size of the exchange which bases on the maximum payload size of the channel reduced by Matter
   * protocol overhead.
   */
  get maxPayloadSize() {
    return this.channel.maxPayloadSize - MATTER_MESSAGE_OVERHEAD;
  }
  async sendStandaloneAckForMessage(message) {
    const {
      packetHeader: { messageId },
      payloadHeader: { requiresAck }
    } = message;
    if (!requiresAck || !this.channel.usesMrp) return;
    await this.send(SecureMessageType.StandaloneAck, new Uint8Array(0), { includeAcknowledgeMessageId: messageId });
  }
  async onMessageReceived(message, duplicate = false) {
    logger.debug("Message \xAB", MessageCodec.messageDiagnostics(message, { duplicate }));
    if (message.payloadHeader.requiresAck && !this.channel.usesMrp) {
      logger.debug("Ignoring ack-required flag because MRP is not used for this exchange");
      message.payloadHeader.requiresAck = false;
    }
    const {
      packetHeader: { messageId },
      payloadHeader: { requiresAck, ackedMessageId, protocolId, messageType }
    } = message;
    const isStandaloneAck = SecureMessageType.isStandaloneAck(protocolId, messageType);
    if (protocolId !== this.#protocolId && !isStandaloneAck) {
      throw new MatterFlowError(
        `Drop received a message for an unexpected protocol. Expected: ${this.#protocolId}, received: ${protocolId}`
      );
    }
    this.session.notifyActivity(true);
    if (duplicate) {
      if (requiresAck) {
        await this.sendStandaloneAckForMessage(message);
      }
      return;
    }
    if (messageId === this.#sentMessageToAck?.payloadHeader.ackedMessageId) {
      await this.channel.send(this.#sentMessageToAck);
      return;
    }
    const sentMessageIdToAck = this.#sentMessageToAck?.packetHeader.messageId;
    if (sentMessageIdToAck !== void 0) {
      if (ackedMessageId === void 0) {
        throw new MatterFlowError("Previous message ack is missing");
      } else if (ackedMessageId !== sentMessageIdToAck) {
        if (isStandaloneAck) {
        } else {
          throw new MatterFlowError(
            `Incorrect ack received. Expected ${sentMessageIdToAck}, received: ${ackedMessageId}`
          );
        }
      } else {
        this.#retransmissionTimer?.stop();
        this.#retransmissionCounter = 0;
        this.#sentMessageAckSuccess?.(message);
        this.#sentMessageAckSuccess = void 0;
        this.#sentMessageAckFailure = void 0;
        this.#sentMessageToAck = void 0;
        if (isStandaloneAck && this.#closeTimer !== void 0) {
          return this.#close();
        }
      }
    }
    if (isStandaloneAck) {
      return;
    }
    if (requiresAck) {
      if (this.#receivedMessageToAck !== void 0) {
        this.#receivedMessageAckTimer.stop();
        await this.sendStandaloneAckForMessage(this.#receivedMessageToAck);
        return;
      }
      this.#receivedMessageToAck = message;
      this.#receivedMessageAckTimer.start();
    }
    await this.#messagesQueue.write(message);
  }
  async send(messageType, payload, options) {
    if (options?.requiresAck && !this.channel.usesMrp) {
      options.requiresAck = false;
    }
    const {
      expectAckOnly = false,
      disableMrpLogic,
      expectedProcessingTimeMs = DEFAULT_EXPECTED_PROCESSING_TIME_MS,
      requiresAck,
      includeAcknowledgeMessageId,
      logContext
    } = options ?? {};
    if (!this.channel.usesMrp && includeAcknowledgeMessageId !== void 0) {
      throw new InternalError("Cannot include an acknowledge message ID when MRP is not used");
    }
    if (messageType === SecureMessageType.StandaloneAck) {
      if (!this.channel.usesMrp) {
        return;
      }
      if (requiresAck) {
        throw new MatterFlowError("A standalone ack may not require acknowledgement.");
      }
    }
    if (this.#sentMessageToAck !== void 0 && messageType !== SecureMessageType.StandaloneAck)
      throw new MatterFlowError("The previous message has not been acked yet, cannot send a new message.");
    this.#used = true;
    this.session.notifyActivity(false);
    let ackedMessageId = includeAcknowledgeMessageId;
    if (ackedMessageId === void 0 && this.channel.usesMrp) {
      ackedMessageId = this.#receivedMessageToAck?.packetHeader.messageId;
      if (ackedMessageId !== void 0) {
        this.#receivedMessageAckTimer.stop();
        this.#receivedMessageToAck = void 0;
      }
    }
    let packetHeader;
    if (this.session.type === SessionType.Unicast) {
      packetHeader = {
        sessionId: this.#peerSessionId,
        sessionType: SessionType.Unicast,
        messageId: await this.session.getIncrementedMessageCounter(),
        destNodeId: this.#peerNodeId,
        sourceNodeId: this.#nodeId,
        hasPrivacyEnhancements: false,
        isControlMessage: false,
        hasMessageExtensions: false
      };
    } else if (this.session.type === SessionType.Group) {
      const session = this.session;
      if (!GroupSession.is(session)) {
        throw new InternalError("Session is not a GroupSession, but session type is Group.");
      }
      const destGroupId = GroupId.fromNodeId(this.#peerNodeId);
      if (destGroupId === 0) {
        throw new InternalError(`Invalid GroupId extracted from NodeId ${this.#peerNodeId}`);
      }
      packetHeader = {
        sessionId: this.#peerSessionId,
        sessionType: SessionType.Group,
        messageId: await session.getIncrementedMessageCounter(),
        destGroupId,
        sourceNodeId: this.#nodeId,
        // We are the source node, so use our NodeId
        hasPrivacyEnhancements: false,
        isControlMessage: false,
        hasMessageExtensions: false
      };
    } else {
      throw new InternalError(`Unknown session type: ${this.session.type}`);
    }
    const message = {
      packetHeader,
      payloadHeader: {
        exchangeId: this.#exchangeId,
        protocolId: messageType === SecureMessageType.StandaloneAck ? SECURE_CHANNEL_PROTOCOL_ID : this.#protocolId,
        messageType,
        isInitiatorMessage: this.isInitiator,
        requiresAck: requiresAck ?? (this.channel.usesMrp && messageType !== SecureMessageType.StandaloneAck),
        ackedMessageId,
        hasSecuredExtension: false
      },
      payload
    };
    let ackPromise;
    if (this.channel.usesMrp && message.payloadHeader.requiresAck && !disableMrpLogic) {
      this.#sentMessageToAck = message;
      this.#retransmissionTimer = Time.getTimer(
        `Message retransmission ${message.packetHeader.messageId}`,
        this.channel.getMrpResubmissionBackOffTime(0),
        () => this.#retransmitMessage(message, expectedProcessingTimeMs)
      );
      const { promise, resolver, rejecter } = createPromise();
      ackPromise = promise;
      this.#sentMessageAckSuccess = resolver;
      this.#sentMessageAckFailure = rejecter;
    }
    await this.channel.send(message, logContext);
    if (ackPromise !== void 0) {
      this.#retransmissionCounter = 0;
      this.#retransmissionTimer?.start();
      const responseMessage = await ackPromise;
      this.#sentMessageAckSuccess = void 0;
      this.#sentMessageAckFailure = void 0;
      const {
        payloadHeader: { protocolId, messageType: messageType2 }
      } = responseMessage;
      if (expectAckOnly && !SecureMessageType.isStandaloneAck(protocolId, messageType2)) {
        throw new UnexpectedMessageError("Expected ack only", responseMessage);
      }
    }
  }
  nextMessage(options) {
    let timeout;
    if (options?.timeoutMs !== void 0) {
      timeout = options.timeoutMs;
    } else if (this.#messagesQueue.size > 0) {
      timeout = 0;
    } else {
      timeout = this.channel.calculateMaximumPeerResponseTimeMs(
        this.context.localSessionParameters,
        options?.expectedProcessingTimeMs
      );
    }
    return this.#messagesQueue.read(timeout);
  }
  calculateMaximumPeerResponseTimeMs(expectedProcessingTimeMs = DEFAULT_EXPECTED_PROCESSING_TIME_MS) {
    return this.channel.calculateMaximumPeerResponseTimeMs(
      this.context.localSessionParameters,
      expectedProcessingTimeMs
    );
  }
  #retransmitMessage(message, expectedProcessingTimeMs) {
    this.#retransmissionCounter++;
    if (this.#retransmissionCounter >= MRP.MAX_TRANSMISSIONS) {
      if (expectedProcessingTimeMs !== void 0) {
        const finalWaitTime = this.channel.calculateMaximumPeerResponseTimeMs(
          this.context.localSessionParameters,
          expectedProcessingTimeMs
        ) - (this.#retransmissionTimer?.intervalMs ?? 0);
        if (finalWaitTime > 0) {
          this.#retransmissionCounter--;
          logger.debug(
            `Message ${message.packetHeader.messageId}: Wait additional ${finalWaitTime}ms for processing time and peer resubmissions after all our resubmissions`
          );
          this.#retransmissionTimer = Time.getTimer(
            `Message wait time after resubmissions ${message.packetHeader.messageId}`,
            finalWaitTime,
            () => this.#retransmitMessage(message)
          ).start();
          return;
        }
      }
      if (this.#sentMessageToAck !== void 0 && this.#sentMessageAckFailure !== void 0) {
        this.#receivedMessageToAck = void 0;
        this.#sentMessageAckFailure(new RetransmissionLimitReachedError());
        this.#sentMessageAckFailure = void 0;
        this.#sentMessageAckSuccess = void 0;
      }
      if (this.#closeTimer !== void 0) {
        this.#close().catch((error) => logger.error("An error happened when closing the exchange", error));
      }
      return;
    }
    this.session.notifyActivity(false);
    if (this.#retransmissionCounter === 1) {
      this.context.resubmissionStarted();
    }
    const resubmissionBackoffTime = this.channel.getMrpResubmissionBackOffTime(this.#retransmissionCounter);
    logger.debug(
      `Resubmit message ${message.packetHeader.messageId} (retransmission attempt ${this.#retransmissionCounter}, backoff time ${resubmissionBackoffTime}ms))`
    );
    this.channel.send(message).then(() => this.#initializeResubmission(message, resubmissionBackoffTime, expectedProcessingTimeMs)).catch((error) => {
      logger.error("An error happened when retransmitting a message", error);
      if (error instanceof ChannelNotConnectedError) {
        this.#close().catch((error2) => logger.error("An error happened when closing the exchange", error2));
      } else {
        this.#initializeResubmission(message, resubmissionBackoffTime, expectedProcessingTimeMs);
      }
    });
  }
  #initializeResubmission(message, resubmissionBackoffTime, expectedProcessingTimeMs) {
    this.#retransmissionTimer = Time.getTimer(
      "Message retransmission",
      resubmissionBackoffTime,
      () => this.#retransmitMessage(message, expectedProcessingTimeMs)
    ).start();
  }
  async destroy() {
    if (this.#closeTimer === void 0 && this.#receivedMessageToAck !== void 0) {
      this.#receivedMessageAckTimer.stop();
      const messageToAck = this.#receivedMessageToAck;
      this.#receivedMessageToAck = void 0;
      try {
        await this.sendStandaloneAckForMessage(messageToAck);
      } catch (error) {
        logger.error("An error happened when closing the exchange", error);
      }
    }
    await this.#close();
  }
  startTimedInteraction(timeoutMs) {
    if (this.#timedInteractionTimer !== void 0 && this.#timedInteractionTimer.isRunning) {
      this.#timedInteractionTimer.stop();
      throw new StatusResponseError(
        "Timed interaction already running for this exchange",
        StatusCode.InvalidAction
      );
    }
    logger.debug(
      `Starting timed interaction with Transaction ID ${this.#exchangeId} for ${timeoutMs}ms from ${this.channel.name}`
    );
    this.#timedInteractionTimer = Time.getTimer("Timed interaction", timeoutMs, () => {
      logger.debug(
        `Timed interaction with Transaction ID ${this.#exchangeId} from ${this.channel.name} timed out`
      );
    }).start();
  }
  clearTimedInteraction() {
    if (this.#timedInteractionTimer !== void 0) {
      logger.debug(
        `Clearing timed interaction with Transaction ID ${this.#exchangeId} from ${this.channel.name}`
      );
      this.#timedInteractionTimer.stop();
      this.#timedInteractionTimer = void 0;
    }
  }
  hasTimedInteraction() {
    return this.#timedInteractionTimer !== void 0;
  }
  hasActiveTimedInteraction() {
    return this.#timedInteractionTimer !== void 0 && this.#timedInteractionTimer.isRunning;
  }
  hasExpiredTimedInteraction() {
    return this.#timedInteractionTimer !== void 0 && !this.#timedInteractionTimer.isRunning;
  }
  async close(force = false) {
    if (this.#closeTimer !== void 0) {
      if (force) {
        this.#closeTimer.stop();
        return this.#close();
      }
      return;
    }
    if (!this.#used) {
      logger.info(`Exchange ${this.session.name} / ${this.#exchangeId} was never used, closing directly`);
      return this.#close();
    }
    this.#isClosing = true;
    this.#closing.emit();
    if (this.#receivedMessageToAck !== void 0) {
      this.#receivedMessageAckTimer.stop();
      const messageToAck = this.#receivedMessageToAck;
      this.#receivedMessageToAck = void 0;
      try {
        await this.sendStandaloneAckForMessage(messageToAck);
      } catch (error) {
        logger.error(
          `An error happened when closing the exchange ${this.session.name} / ${this.#exchangeId}`,
          error
        );
      }
      if (force) {
        return this.#close();
      }
    } else if (this.#sentMessageToAck === void 0 || force) {
      return this.#close();
    }
    let maxResubmissionTime = 0;
    for (let i = this.#retransmissionCounter; i <= MRP.MAX_TRANSMISSIONS; i++) {
      maxResubmissionTime += this.channel.getMrpResubmissionBackOffTime(i);
    }
    this.#closeTimer = Time.getTimer(
      `Message exchange cleanup ${this.session.name} / ${this.#exchangeId}`,
      maxResubmissionTime,
      async () => await this.#close()
    ).start();
  }
  async #close() {
    if (!this.#isClosing) {
      this.#closing.emit();
    }
    this.#isClosing = true;
    this.#retransmissionTimer?.stop();
    this.#closeTimer?.stop();
    this.#timedInteractionTimer?.stop();
    this.#messagesQueue.close();
    await this.#closed.emit();
  }
}
export {
  MATTER_MESSAGE_OVERHEAD,
  MessageExchange,
  RetransmissionLimitReachedError,
  UnexpectedMessageError
};
//# sourceMappingURL=MessageExchange.js.map
