/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { BasicSet, Bytes, DataReader, ImplementationError, MatterFlowError, Time } from "#general";
const GROUP_KEY_INFO = Bytes.fromString("GroupKeyHash");
class KeySets extends BasicSet {
  /** Operational enhanced structure for fast access based on the group session id. */
  #sessions = /* @__PURE__ */ new Map();
  get sessions() {
    return this.#sessions;
  }
  add(item) {
    this.delete("groupKeySetId", item.groupKeySetId);
    super.add(item);
    this.#updateSessions();
  }
  delete(itemOrField, value) {
    const deleted = super.delete(itemOrField, value);
    if (deleted) {
      this.#updateSessions();
    }
    return deleted;
  }
  forId(groupKeySetId) {
    return this.get("groupKeySetId", groupKeySetId);
  }
  /**
   * Return an operative list of operational keys, start time and their session IDs for a specified
   * group key set id. This is mainly used for receiving messages.
   */
  allKeysForId(keySetId) {
    const groupKeySet = this.forId(keySetId);
    if (groupKeySet === void 0) {
      throw new MatterFlowError(`GroupKeySet for groupKeySet ${keySetId} not found.`);
    }
    const operationalKeys = Array();
    const {
      operationalEpochKey0,
      groupSessionId0,
      epochStartTime0,
      operationalEpochKey1,
      groupSessionId1,
      epochStartTime1,
      operationalEpochKey2,
      groupSessionId2,
      epochStartTime2
    } = groupKeySet;
    if (operationalEpochKey0 === null || epochStartTime0 === null || keySetId !== 0 && groupSessionId0 === null) {
      throw new MatterFlowError(`EpochKey0 for groupKeySet ${keySetId} not found.`);
    }
    operationalKeys.push({
      key: operationalEpochKey0,
      sessionId: groupSessionId0 !== null ? groupSessionId0 : void 0,
      startTime: epochStartTime0
    });
    if (operationalEpochKey1 !== null && groupSessionId1 !== null && epochStartTime1 !== null) {
      operationalKeys.push({ key: operationalEpochKey1, sessionId: groupSessionId1, startTime: epochStartTime1 });
    }
    if (operationalEpochKey2 !== null && groupSessionId2 !== null && epochStartTime2 !== null) {
      operationalKeys.push({ key: operationalEpochKey2, sessionId: groupSessionId2, startTime: epochStartTime2 });
    }
    return operationalKeys;
  }
  /**
   * Returns the current operational group key for a given group KeySet Id and returns the keys, start time and
   * their session IDs. This is mainly used for sending messages.
   */
  currentKeyForId(keySetId) {
    const operationalKeys = this.allKeysForId(keySetId);
    if (operationalKeys.length === 0) {
      throw new MatterFlowError(`No operational keys found for groupKeySet ${keySetId}.`);
    }
    if (keySetId === 0) {
      if (operationalKeys.length > 2) {
        return operationalKeys[1];
      }
      return operationalKeys[0];
    } else {
      const now = Time.nowUs();
      const relevantKeys = operationalKeys.filter(({ startTime }) => startTime <= now);
      if (relevantKeys.length === 0) {
        throw new ImplementationError(
          `No operational keys found for groupKeySet ${keySetId} that are not in the future.`
        );
      }
      return relevantKeys[operationalKeys.length - 1];
    }
  }
  /**
   * Returns the group key set for a given group key set id in the official data format from the Group key Management
   * cluster.
   */
  asGroupKeySet(groupKeySetId) {
    const groupKeySet = this.forId(groupKeySetId);
    if (groupKeySet === void 0) {
      return void 0;
    }
    const {
      epochKey0,
      epochStartTime0,
      epochKey1,
      epochStartTime1,
      epochKey2,
      epochStartTime2,
      groupKeySecurityPolicy,
      groupKeyMulticastPolicy
    } = groupKeySet;
    return {
      groupKeySetId,
      epochKey0,
      epochStartTime0,
      epochKey1,
      epochStartTime1,
      epochKey2,
      epochStartTime2,
      groupKeySecurityPolicy,
      groupKeyMulticastPolicy
    };
  }
  /** Calculates a group session id based on the operational group key. */
  async sessionIdFromKey(crypto, operationalGroupKey) {
    const groupKeyHash = await crypto.createHkdfKey(operationalGroupKey, new Uint8Array(), GROUP_KEY_INFO, 2);
    return new DataReader(groupKeyHash).readUInt16();
  }
  /**
   * Updates the group session map based on the current group key sets.
   * This is used to quickly find the operational keys by their group session id.
   */
  #updateSessions() {
    this.#sessions.clear();
    for (const [id, keySet] of this.mapOf("groupKeySetId").entries()) {
      if (id === 0) {
        continue;
      }
      if (keySet.groupSessionId0 !== null) {
        const list = this.#sessions.get(keySet.groupSessionId0) ?? [];
        list.push({ key: keySet.operationalEpochKey0, keySetId: id });
        this.#sessions.set(keySet.groupSessionId0, list);
      }
      if (keySet.groupSessionId1 !== null && keySet.operationalEpochKey1 !== null) {
        const list = this.#sessions.get(keySet.groupSessionId1) ?? [];
        list.push({ key: keySet.operationalEpochKey1, keySetId: id });
        this.#sessions.set(keySet.groupSessionId1, list);
      }
      if (keySet.groupSessionId2 !== null && keySet.operationalEpochKey2 !== null) {
        const list = this.#sessions.get(keySet.groupSessionId2) ?? [];
        list.push({ key: keySet.operationalEpochKey2, keySetId: id });
        this.#sessions.set(keySet.groupSessionId2, list);
      }
    }
  }
}
export {
  GROUP_KEY_INFO,
  KeySets
};
//# sourceMappingURL=KeySets.js.map
