/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { BasicSet, Environmental, ImplementationError } from "#general";
import { InteractionClientMessenger, MessageType } from "#interaction/InteractionMessenger.js";
import { InteractionQueue } from "#peer/InteractionQueue.js";
import { ExchangeProvider } from "#protocol/ExchangeProvider.js";
import { TlvSubscribeResponse } from "#types";
import { ClientSubscriptions } from "./ClientSubscriptions.js";
import { InputChunk } from "./InputChunk.js";
const DEFAULT_MIN_INTERVAL_FLOOR_SECONDS = 1;
class ClientInteraction {
  #exchanges;
  #subscriptions;
  #queue;
  #interactions = new BasicSet();
  #closed = false;
  constructor(context) {
    this.#exchanges = context.exchanges;
    this.#subscriptions = context.subscriptions;
    this.#queue = context.queue;
  }
  async close() {
    this.#closed = true;
    while (this.#interactions.size) {
      await this.#interactions.deleted;
    }
  }
  get subscriptions() {
    return this.#subscriptions;
  }
  get queue() {
    return this.#queue;
  }
  static [Environmental.create](env) {
    const instance = new ClientInteraction({
      exchanges: env.get(ExchangeProvider),
      subscriptions: env.get(ClientSubscriptions),
      queue: env.get(InteractionQueue)
    });
    env.set(ClientInteraction, instance);
    return instance;
  }
  async *read(request, _session) {
    try {
      this.#begin(request);
      const messenger = await InteractionClientMessenger.create(this.#exchanges);
      await messenger.sendReadRequest(request);
      for await (const report of messenger.readDataReports()) {
        yield InputChunk(report);
      }
    } finally {
      this.#end(request);
    }
  }
  async write(request, _session) {
    let messenger;
    try {
      this.#begin(request);
      messenger = await InteractionClientMessenger.create(this.#exchanges);
      const response = await messenger.sendWriteCommand(request);
      if (request.suppressResponse) {
        return void 0;
      }
      if (!response || !response.writeResponses?.length) {
        return new Array();
      } else {
        return response.writeResponses.map(
          ({
            path: { nodeId, endpointId, clusterId, attributeId, listIndex },
            status: { status, clusterStatus }
          }) => ({
            kind: "attr-status",
            path: {
              nodeId,
              endpointId,
              clusterId,
              attributeId,
              listIndex
            },
            status,
            clusterStatus
          })
        );
      }
    } finally {
      await messenger?.close();
      this.#end(request);
    }
  }
  async *invoke(request, _session) {
    let messenger;
    try {
      this.#begin(request);
      messenger = await InteractionClientMessenger.create(this.#exchanges);
      const result = await messenger.sendInvokeCommand(request);
      if (!request.suppressResponse) {
        if (result && result.invokeResponses?.length) {
          const chunk = result.invokeResponses.map((response) => {
            if (response.command !== void 0) {
              const {
                commandPath: { endpointId, clusterId, commandId },
                commandRef,
                commandFields
              } = response.command;
              const res = {
                kind: "cmd-response",
                path: {
                  endpointId,
                  clusterId,
                  commandId
                },
                commandRef,
                data: commandFields
                // TODO add decoding
              };
              return res;
            } else if (response.status !== void 0) {
              const {
                commandPath: { endpointId, clusterId, commandId },
                commandRef,
                status: { status, clusterStatus }
              } = response.status;
              const res = {
                kind: "cmd-status",
                path: {
                  endpointId,
                  clusterId,
                  commandId
                },
                commandRef,
                status,
                clusterStatus
              };
              return res;
            } else {
              return void 0;
            }
          }).filter((r) => r !== void 0);
          yield chunk;
        } else {
          yield [];
        }
      }
    } finally {
      await messenger?.close();
      this.#end(request);
    }
  }
  async subscribe(request, _session) {
    let messenger;
    try {
      this.#begin(request);
      messenger = await InteractionClientMessenger.create(this.#exchanges);
      await messenger.sendSubscribeRequest({
        ...request,
        minIntervalFloorSeconds: DEFAULT_MIN_INTERVAL_FLOOR_SECONDS,
        maxIntervalCeilingSeconds: DEFAULT_MIN_INTERVAL_FLOOR_SECONDS
      });
      await this.#handleSubscriptionResponse(request, readChunks(messenger));
      const responseMessage = await messenger.nextMessage(MessageType.SubscribeResponse);
      const response = TlvSubscribeResponse.decode(responseMessage.payload);
      return this.#subscriptions.add(request, response);
    } finally {
      await messenger?.close();
      this.#end(request);
    }
  }
  async #handleSubscriptionResponse(request, result) {
    if (request.updated) {
      await request.updated(result);
    } else {
      for await (const _chunk of result) ;
    }
  }
  #begin(request) {
    if (this.#closed) {
      throw new ImplementationError("Client interaction unavailable after close");
    }
    this.#interactions.add(request);
  }
  #end(request) {
    this.#interactions.delete(request);
  }
}
async function* readChunks(messenger) {
  for await (const report of messenger.readDataReports()) {
    yield InputChunk(report);
  }
}
export {
  ClientInteraction,
  DEFAULT_MIN_INTERVAL_FLOOR_SECONDS
};
//# sourceMappingURL=ClientInteraction.js.map
