/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { InteractionSession } from "#action/Interactable.js";
import { AttributeTypeProtocol, ClusterProtocol, EndpointProtocol, NodeProtocol } from "#action/protocols.js";
import { ReadResult } from "#action/response/ReadResult.js";
import { AttributeId, AttributePath, ClusterId, EndpointNumber } from "#types";
import { AttributeReadResponse } from "./AttributeReadResponse.js";
type ClusterFilter = {
    [clusterId: ClusterId]: Set<AttributeId>;
};
export type AttributeResponseFilter = {
    [endpointId: EndpointNumber]: ClusterFilter;
};
/**
 * AttributeSubscriptionResponse is a specialized version of AttributeReadResponse that processes a read/subscribe request
 * with a filter applied to the attributes. Only the attributes that match the filter will be processed.
 */
export declare class AttributeSubscriptionResponse<SessionT extends InteractionSession = InteractionSession> extends AttributeReadResponse<SessionT> {
    #private;
    constructor(node: NodeProtocol, session: SessionT, filter: AttributeResponseFilter);
    get filter(): AttributeResponseFilter;
    /** Guarded accessor for this.#currentEndpointFilter.  This should never be undefined */
    protected get currentEndpointFilter(): ClusterFilter;
    /** Guarded accessor for this.#currentCLusterFilter.  This should never be undefined */
    protected get currentClusterFilter(): Set<number>;
    protected addConcrete(path: ReadResult.ConcreteAttributePath): void;
    protected readEndpointForWildcard(endpoint: EndpointProtocol, path: AttributePath): Generator<ReadResult.Report[], void, unknown>;
    protected readClusterForWildcard(cluster: ClusterProtocol, path: AttributePath): void;
    protected readAttributeForWildcard(attribute: AttributeTypeProtocol, path: AttributePath): void;
    protected addStatus(): void;
}
export {};
//# sourceMappingURL=AttributeSubscriptionResponse.d.ts.map