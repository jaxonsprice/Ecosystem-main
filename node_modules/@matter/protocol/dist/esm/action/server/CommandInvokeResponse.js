/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { AccessControl } from "#action/server/AccessControl.js";
import { DataResponse, FallbackLimits } from "#action/server/DataResponse.js";
import { Diagnostic, InternalError, Logger } from "#general";
import { DataModelPath, ElementTag, FabricIndex as FabricIndexField } from "#model";
import {
  FabricIndex,
  Status,
  StatusCode,
  StatusResponseError,
  ValidationError
} from "#types";
import { Subject } from "./Subject.js";
const logger = Logger.get("CommandInvokeResponse");
class CommandInvokeResponse extends DataResponse {
  #fabricIndex;
  // The initial "chunk" may be a list of errors.  As producers execute it is a set of records associated with the
  // most recently touched endpoint.  When the endpoint changes the previous chunk emits
  #chunk;
  // Each input CommandDataIB that does not have an error installs a producer.  Producers run after validation and
  // generate actual command data
  #invokers;
  // The following state updates as data producers execute.  This serves both to convey state between functions and as
  // a cache between producers that touch the same endpoint and/or cluster
  #currentEndpoint;
  #registeredPaths = /* @__PURE__ */ new Set();
  #registeredCommandRefs = /* @__PURE__ */ new Set();
  // Count how many command status (on error) and command invokes (success) we have emitted
  #statusCount = 0;
  #successCount = 0;
  #errorCount = 0;
  constructor(node, session) {
    super(node, session);
    this.#fabricIndex = session.fabric ?? FabricIndex.NO_FABRIC;
  }
  async *process({ invokeRequests, suppressResponse }) {
    const multipleInvokes = invokeRequests.length > 1;
    for (const command of invokeRequests) {
      const { commandPath: path, commandFields, commandRef } = command;
      if (path.endpointId === void 0 || path.clusterId === void 0 || path.commandId === void 0) {
        if (multipleInvokes) {
          throw new StatusResponseError(
            "Wildcard path must not be used with multiple invokes",
            StatusCode.InvalidAction
          );
        }
        this.#processWildcard(path, commandRef, commandFields);
      } else {
        if (Subject.isGroup(this.session.subject)) {
          throw new StatusResponseError("Group commands connot be concrete paths", StatusCode.InvalidAction);
        }
        if (multipleInvokes && commandRef === void 0) {
          throw new StatusResponseError(
            "The CommandRef field must be specified for all commands in a batch invoke",
            StatusCode.InvalidAction
          );
        }
        this.#processConcrete(path, commandRef, commandFields);
      }
    }
    if (this.#invokers) {
      for (const invoker of this.#invokers) {
        for await (const chunk of invoker.apply(this)) {
          if (!suppressResponse) {
            yield chunk;
          }
        }
      }
    }
    if (!suppressResponse && this.#chunk !== void 0) {
      yield this.#chunk;
    }
  }
  get counts() {
    return {
      status: this.#statusCount,
      success: this.#successCount,
      existent: this.#successCount + this.#errorCount
    };
  }
  /**
   * Process a wildcard path and invoke commands on all endpoints that match the path.
   */
  #processWildcard(path, commandRef, commandFields) {
    const { clusterId, endpointId, commandId } = path;
    const isGroupPath = Subject.isGroup(this.session.subject);
    if (isGroupPath && endpointId !== void 0) {
      throw new StatusResponseError(
        "Illegal command invoke with group ID and endpoint ID",
        StatusCode.InvalidAction
      );
    }
    if (clusterId === void 0 || commandId === void 0) {
      throw new StatusResponseError(
        "Wildcard path write must specify a clusterId and commandId",
        StatusCode.InvalidAction
      );
    }
    let groupEndpoints;
    if (isGroupPath) {
      if (this.session.subject.endpoints.length) {
        groupEndpoints = this.session.subject.endpoints;
      } else {
        logger.debug(`No endpoints mapped to group ${this.session.subject.id}, skipping wildcard invoke`);
        return;
      }
    }
    this.#addInvoker(async function* invokeWildcardEndpoints() {
      for (const endpoint of this.node) {
        if (groupEndpoints !== void 0 && !groupEndpoints.includes(endpoint.id)) {
          continue;
        }
        yield* this.#processEndpointForWildcard(endpoint, path, commandRef, commandFields);
      }
    });
  }
  /**
   * Invoke a command specified by a concrete path
   */
  #processConcrete(path, commandRef, commandFields) {
    const { endpointId, clusterId, commandId } = path;
    const pathKey = `${endpointId}-${clusterId}-${commandId}`;
    if (this.#registeredPaths.has(pathKey)) {
      throw new StatusResponseError(
        `Duplicate concrete command path ${this.node.inspectPath(path)} on batch invoke`,
        StatusCode.InvalidAction
      );
    }
    this.#registeredPaths.add(pathKey);
    if (commandRef !== void 0) {
      if (this.#registeredCommandRefs.has(commandRef)) {
        throw new StatusResponseError(
          `Duplicate commandRef ${commandRef} on batch invoke`,
          StatusCode.InvalidAction
        );
      }
      this.#registeredCommandRefs.add(commandRef);
    }
    const endpoint = this.node[endpointId];
    const cluster = endpoint?.[clusterId];
    const command = cluster?.type.commands[commandId];
    let limits;
    if (command === void 0) {
      const modelAttr = this.node.matter.member(path.clusterId, [ElementTag.Cluster])?.member(path.commandId, [ElementTag.Command]);
      if (modelAttr) {
        limits = AccessControl(modelAttr).limits;
      } else {
        limits = FallbackLimits;
      }
    } else {
      limits = command.limits;
    }
    const location = {
      ...cluster?.location ?? {
        path: DataModelPath.none,
        endpoint: endpointId,
        cluster: clusterId
      },
      owningFabric: this.session.fabric
    };
    const permission = this.session.authorityAt(limits.writeLevel, location);
    switch (permission) {
      case AccessControl.Authority.Granted:
        break;
      case AccessControl.Authority.Unauthorized:
        return this.#addStatus(path, commandRef, Status.UnsupportedAccess);
      case AccessControl.Authority.Restricted:
        return this.#addStatus(path, commandRef, Status.AccessRestricted);
      default:
        throw new InternalError(`Unsupported authorization state ${permission}`);
    }
    if (endpoint === void 0) {
      return this.#addStatus(path, commandRef, Status.UnsupportedEndpoint);
    }
    if (cluster === void 0) {
      return this.#addStatus(path, commandRef, Status.UnsupportedCluster);
    }
    if (command === void 0 || !cluster.type.commands[command.id]) {
      return this.#addStatus(path, commandRef, Status.UnsupportedCommand);
    }
    if (limits.fabricScoped && this.session.fabric === void 0) {
      this.#errorCount++;
      return this.#addStatus(path, commandRef, Status.UnsupportedAccess);
    }
    if (limits.timed && !this.session.timed) {
      this.#errorCount++;
      return this.#addStatus(path, commandRef, Status.NeedsTimedInteraction);
    }
    this.#addInvoker(async function* invokeConcretePath() {
      if (this.#currentEndpoint !== endpoint) {
        if (this.#chunk) {
          yield this.#chunk;
          this.#chunk = void 0;
        }
        this.#currentEndpoint = endpoint;
      }
      await this.#invokeCommand(command, path, commandRef, commandFields, cluster.commands[command.id]);
    });
  }
  /**
   * Starts new chunk or adds to current chunk all values from {@link endpoint} selected by {@link path}.
   *
   * Emits previous chunk if it exists and was not for this endpoint.  This means that our chunk size is one endpoint
   * worth of data, except for the initial error chunk if there are path errors.
   **
   * TODO - skip endpoints for which subject is unauthorized as optimization
   */
  async *#processEndpointForWildcard(endpoint, path, commandRef, commandFields) {
    const { clusterId } = path;
    if (this.#currentEndpoint !== endpoint) {
      if (this.#chunk) {
        yield this.#chunk;
        this.#chunk = void 0;
      }
      this.#currentEndpoint = endpoint;
    }
    const cluster = endpoint[clusterId];
    if (cluster !== void 0) {
      const { commandId } = path;
      const command = cluster.type.commands[commandId];
      if (command !== void 0) {
        if (this.session.authorityAt(command.limits.writeLevel, cluster.location) !== AccessControl.Authority.Granted || command.limits.timed && !this.session.timed) {
          return;
        }
        await this.#invokeCommand(
          command,
          {
            ...path,
            endpointId: endpoint.id
          },
          commandRef,
          commandFields,
          cluster.commands[command.id]
        );
      }
    }
  }
  /**
   * Add a function that invokes commands and produces data.  These functions are run after validation of input paths.
   */
  #addInvoker(producer) {
    if (this.#invokers) {
      this.#invokers.push(producer);
    } else {
      this.#invokers = [producer];
    }
  }
  #addResponse(chunk) {
    if (this.#chunk) {
      this.#chunk.push(chunk);
    } else {
      this.#chunk = [chunk];
    }
  }
  /**
   * Add a status value.
   */
  #addStatus(path, commandRef, status, clusterStatus) {
    if (status !== StatusCode.Success) {
      logger.info(
        () => `Invoke error ${this.node.inspectPath(path)}: Status=${StatusCode[status]}(${status}), ClusterStatus=${clusterStatus}`
      );
    }
    const response = {
      kind: "cmd-status",
      path,
      status,
      clusterStatus,
      commandRef
    };
    if (status !== StatusCode.Success) {
      this.#statusCount++;
    }
    this.#addResponse(response);
  }
  async #invokeCommand(command, path, commandRef, commandFields, invoker) {
    try {
      const { requestTlv, responseTlv } = command;
      const request = this.#decodeWithSchema(requestTlv, commandFields);
      requestTlv.validate(request);
      const response = await invoker(request, this.session);
      await this.session.transaction?.commit();
      this.#successCount++;
      const encodedResponse = responseTlv.encodeTlv(response);
      if (encodedResponse.length === 0) {
        this.#addStatus(path, commandRef, StatusCode.Success);
      } else {
        this.#addResponse({
          kind: "cmd-response",
          path: {
            ...path,
            commandId: command.responseId
          },
          data: encodedResponse,
          commandRef
        });
      }
    } catch (error) {
      await this.session.transaction?.rollback();
      if (StatusResponseError.is(error)) {
        this.#errorCount++;
        let errorCode = error.code;
        const errorLogText = `Error ${Diagnostic.hex(errorCode)}${error.clusterCode !== void 0 ? `/${Diagnostic.hex(error.clusterCode)}` : ""} while invoking command: ${error.message}`;
        if (error instanceof ValidationError) {
          logger.info(
            `Validation-${errorLogText}${error.fieldName !== void 0 ? ` in field ${error.fieldName}` : ""}`
          );
          if (errorCode === StatusCode.InvalidAction) {
            errorCode = StatusCode.InvalidCommand;
          }
        } else {
          logger.info(errorLogText);
        }
        this.#addStatus(path, commandRef, errorCode, error.clusterCode);
        return;
      }
      throw error;
    }
  }
  #decodeWithSchema(tlv, value) {
    if (value === void 0) {
      return void 0;
    }
    return tlv.injectField(
      tlv.decodeTlv(value),
      FabricIndexField.id,
      this.#fabricIndex,
      () => true
      // We always inject the current fabricIndex for invokes
    );
  }
}
export {
  CommandInvokeResponse
};
//# sourceMappingURL=CommandInvokeResponse.js.map
