/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { CertificationDeclaration } from "#certificate/kinds/CertificationDeclaration.js";
import { Construction, ImplementationError, InternalError, PrivateKey } from "#general";
import { AttestationCertificateManager } from "./AttestationCertificateManager.js";
class DeviceCertification {
  #crypto;
  #privateKey;
  #certificate;
  #intermediateCertificate;
  #declaration;
  #construction;
  get construction() {
    return this.#construction;
  }
  get certificate() {
    return this.#assertInitialized().certificate;
  }
  get intermediateCertificate() {
    return this.#assertInitialized().intermediateCertificate;
  }
  get declaration() {
    return this.#assertInitialized().declaration;
  }
  constructor(crypto, config, product) {
    this.#crypto = crypto;
    let configProvider;
    if (typeof config === "function") {
      configProvider = config;
    } else if (config) {
      configProvider = () => config;
    } else {
      configProvider = async () => {
        if (product === void 0) {
          throw new ImplementationError(`Cannot generate device certification without product information`);
        }
        const paa = await AttestationCertificateManager.create(crypto, product.vendorId);
        const { keyPair: dacKeyPair, dac } = await paa.getDACert(product.productId);
        return {
          privateKey: PrivateKey(dacKeyPair.privateKey),
          certificate: dac,
          intermediateCertificate: await paa.getPAICert(),
          declaration: await CertificationDeclaration.generate(crypto, product.vendorId, product.productId)
        };
      };
    }
    this.#construction = Construction(this, async () => {
      const config2 = await configProvider();
      this.#privateKey = config2.privateKey instanceof Uint8Array ? PrivateKey(config2.privateKey) : config2.privateKey;
      this.#certificate = config2.certificate;
      this.#intermediateCertificate = config2.intermediateCertificate;
      this.#declaration = config2.declaration;
    });
  }
  async sign(session, data) {
    const { privateKey } = this.#assertInitialized();
    const signature = await this.#crypto.signEcdsa(privateKey, [data, session.attestationChallengeKey]);
    return signature;
  }
  /**
   * Makes sure that the device certification is initialized and construction is completed and returns "Non-undefined"
   * values
   */
  #assertInitialized() {
    this.#construction.assert();
    if (this.#certificate === void 0 || this.#intermediateCertificate === void 0 || this.#declaration === void 0 || this.#privateKey === void 0) {
      throw new InternalError(
        `Device certification not initialized while trying to access it. This should never happen.`
      );
    }
    return {
      certificate: this.#certificate,
      intermediateCertificate: this.#intermediateCertificate,
      declaration: this.#declaration,
      privateKey: this.#privateKey
    };
  }
}
export {
  DeviceCertification
};
//# sourceMappingURL=DeviceCertification.js.map
