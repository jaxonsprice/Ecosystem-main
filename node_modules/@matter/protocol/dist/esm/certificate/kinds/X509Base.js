/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import {
  Bytes,
  ContextTagged,
  DatatypeOverride,
  DerBitString,
  DerCodec,
  DerKey,
  DerType,
  PublicKey,
  RawBytes,
  X509,
  X520,
  X962
} from "#general";
import { CaseAuthenticatedTag } from "#types";
import { assertCertificateDerSize, CertificateError } from "./common.js";
import {
  FabricId_Matter,
  FirmwareSigningId_Matter,
  IcacId_Matter,
  matterToJsDate,
  NocCat_Matter,
  NodeId_Matter,
  ProductId_Matter,
  RcacId_Matter,
  VendorId_Matter
} from "./definitions/asn.js";
import { ExtensionKeyUsageSchema } from "./definitions/base.js";
class X509Base {
  #signature;
  #cert;
  constructor(cert) {
    this.#cert = cert;
    if ("signature" in cert) {
      this.#signature = cert.signature;
    }
  }
  get cert() {
    return this.#cert;
  }
  get isSigned() {
    return this.#signature !== void 0;
  }
  /**
   * Get the signature of the certificate.
   * If the certificate is not signed, it throws a CertificateError.
   */
  get signature() {
    if (this.#signature === void 0) {
      throw new CertificateError("Certificate is not signed");
    }
    return this.#signature;
  }
  /**
   * Set the signature of the certificate.
   * If the certificate is already signed, it throws a CertificateError.
   */
  set signature(signature) {
    if (this.isSigned) {
      throw new CertificateError("Certificate is already signed");
    }
    this.#signature = signature;
  }
  /**
   * Sign the certificate using the provided crypto and key.
   * It throws a CertificateError if the certificate is already signed.
   */
  async sign(crypto, key) {
    this.signature = await crypto.signEcdsa(key, this.asUnsignedAsn1());
  }
  /**
   * Convert the certificate to ASN.1 DER format without signature.
   */
  asUnsignedAsn1() {
    const certBytes = DerCodec.encode(this.genericBuildAsn1Structure(this.cert));
    assertCertificateDerSize(certBytes);
    return certBytes;
  }
  /**
   * Convert the subject or issuer field of the certificate to ASN.1 DER format.
   * Preserve order of keys from original subject and also copy potential custom elements
   */
  #subjectOrIssuerToAsn1(data) {
    const asn = {};
    Object.entries(data).forEach(([key, value]) => {
      if (value === void 0) {
        return;
      }
      switch (key) {
        case "commonName":
          asn.commonName = X520.CommonName(value);
          break;
        case "sureName":
          asn.sureName = X520.SurName(value);
          break;
        case "serialNum":
          asn.serialNum = X520.SerialNumber(value);
          break;
        case "countryName":
          asn.countryName = X520.CountryName(value);
          break;
        case "localityName":
          asn.localityName = X520.LocalityName(value);
          break;
        case "stateOrProvinceName":
          asn.stateOrProvinceName = X520.StateOrProvinceName(value);
          break;
        case "orgName":
          asn.orgName = X520.OrganisationName(value);
          break;
        case "orgUnitName":
          asn.orgUnitName = X520.OrganizationalUnitName(value);
          break;
        case "title":
          asn.title = X520.Title(value);
          break;
        case "name":
          asn.name = X520.Name(value);
          break;
        case "givenName":
          asn.givenName = X520.GivenName(value);
          break;
        case "initials":
          asn.initials = X520.Initials(value);
          break;
        case "genQualifier":
          asn.genQualifier = X520.GenerationQualifier(value);
          break;
        case "dnQualifier":
          asn.dnQualifier = X520.DnQualifier(value);
          break;
        case "pseudonym":
          asn.pseudonym = X520.Pseudonym(value);
          break;
        case "domainComponent":
          asn.domainComponent = X520.DomainComponent(value);
          break;
        case "nodeId":
          asn.nodeId = NodeId_Matter(value);
          break;
        case "firmwareSigningId":
          asn.firmwareSigningId = FirmwareSigningId_Matter(value);
          break;
        case "icacId":
          asn.icacId = IcacId_Matter(value);
          break;
        case "rcacId":
          asn.rcacId = RcacId_Matter(value);
          break;
        case "fabricId":
          asn.fabricId = FabricId_Matter(value);
          break;
        case "caseAuthenticatedTags":
          const caseAuthenticatedTags = value;
          CaseAuthenticatedTag.validateNocTagList(caseAuthenticatedTags);
          const cat0 = caseAuthenticatedTags[0];
          const cat1 = caseAuthenticatedTags[1];
          const cat2 = caseAuthenticatedTags[2];
          if (cat0 !== void 0) {
            asn.caseAuthenticatedTag0 = NocCat_Matter(cat0);
          }
          if (cat1 !== void 0) {
            asn.caseAuthenticatedTag1 = NocCat_Matter(cat1);
          }
          if (cat2 !== void 0) {
            asn.caseAuthenticatedTag2 = NocCat_Matter(cat2);
          }
          break;
        case "vendorId":
          asn.vendorId = VendorId_Matter(value);
          break;
        case "productId":
          asn.productId = ProductId_Matter(value);
          break;
        case "commonNamePs":
          asn.commonNamePs = X520.CommonName(value, true);
          break;
        case "sureNamePs":
          asn.sureNamePs = X520.SurName(value, true);
          break;
        case "serialNumPs":
          asn.serialNumPs = X520.SerialNumber(value, true);
          break;
        case "countryNamePs":
          asn.countryNamePs = X520.CountryName(value, true);
          break;
        case "localityNamePs":
          asn.localityNamePs = X520.LocalityName(value, true);
          break;
        case "stateOrProvinceNamePs":
          asn.stateOrProvinceNamePs = X520.StateOrProvinceName(value, true);
          break;
        case "orgNamePs":
          asn.orgNamePs = X520.OrganisationName(value, true);
          break;
        case "orgUnitNamePs":
          asn.orgUnitNamePs = X520.OrganizationalUnitName(value, true);
          break;
        case "titlePs":
          asn.titlePs = X520.Title(value, true);
          break;
        case "namePs":
          asn.namePs = X520.Name(value, true);
          break;
        case "givenNamePs":
          asn.givenNamePs = X520.GivenName(value, true);
          break;
        case "initialsPs":
          asn.initialsPs = X520.Initials(value, true);
          break;
        case "genQualifierPs":
          asn.genQualifierPs = X520.GenerationQualifier(value, true);
          break;
        case "dnQualifierPs":
          asn.dnQualifierPs = X520.DnQualifier(value, true);
          break;
        case "pseudonymPs":
          asn.pseudonymPs = X520.Pseudonym(value, true);
          break;
      }
    });
    return asn;
  }
  /**
   * Convert the extensions of the certificate to ASN.1 DER format.
   */
  #extensionsToAsn1(extensions) {
    const asn = {};
    Object.entries(extensions).forEach(([key, value]) => {
      if (value === void 0) {
        return;
      }
      switch (key) {
        case "basicConstraints":
          asn.basicConstraints = X509.BasicConstraints(value);
          break;
        case "keyUsage":
          asn.keyUsage = X509.KeyUsage(
            ExtensionKeyUsageSchema.encode(
              value
            )
          );
          break;
        case "extendedKeyUsage":
          asn.extendedKeyUsage = X509.ExtendedKeyUsage(value);
          break;
        case "subjectKeyIdentifier":
          asn.subjectKeyIdentifier = X509.SubjectKeyIdentifier(value);
          break;
        case "authorityKeyIdentifier":
          asn.authorityKeyIdentifier = X509.AuthorityKeyIdentifier(value);
          break;
        case "futureExtension":
          asn.futureExtension = RawBytes(Bytes.concat(...value ?? []));
          break;
      }
    });
    return asn;
  }
  /**
   * Build the ASN.1 DER structure for the certificate.
   */
  genericBuildAsn1Structure({
    serialNumber,
    notBefore,
    notAfter,
    issuer,
    subject,
    ellipticCurvePublicKey,
    extensions
  }) {
    const {
      basicConstraints: { isCa, pathLen }
    } = extensions;
    if (!isCa && pathLen !== void 0) {
      throw new CertificateError("Path length must be undefined for non-CA certificates.");
    }
    return {
      version: ContextTagged(0, 2),
      // v3
      serialNumber: DatatypeOverride(DerType.Integer, serialNumber),
      signatureAlgorithm: X962.EcdsaWithSHA256,
      issuer: this.#subjectOrIssuerToAsn1(issuer),
      validity: {
        notBefore: matterToJsDate(notBefore),
        notAfter: matterToJsDate(notAfter)
      },
      subject: this.#subjectOrIssuerToAsn1(subject),
      publicKey: X962.PublicKeyEcPrime256v1(ellipticCurvePublicKey),
      extensions: ContextTagged(3, this.#extensionsToAsn1(extensions))
    };
  }
  /**
   * Create a Certificate Signing Request (CSR) in ASN.1 DER format.
   */
  static async createCertificateSigningRequest(crypto, key) {
    const request = {
      version: 0,
      subject: { organization: X520.OrganisationName("CSR") },
      publicKey: X962.PublicKeyEcPrime256v1(key.publicKey),
      endSignedBytes: ContextTagged(0)
    };
    return DerCodec.encode({
      request,
      signAlgorithm: X962.EcdsaWithSHA256,
      signature: DerBitString(await crypto.signEcdsa(key, DerCodec.encode(request), "der"))
    });
  }
  /**
   * Extract the public key from a Certificate Signing Request (CSR) in ASN.1 DER format.
   */
  static async getPublicKeyFromCsr(crypto, encodedCsr) {
    const { [DerKey.Elements]: rootElements } = DerCodec.decode(encodedCsr);
    if (rootElements?.length !== 3) {
      throw new CertificateError("Invalid CSR data");
    }
    const [requestNode, signAlgorithmNode, signatureNode] = rootElements;
    const { [DerKey.Elements]: requestElements } = requestNode;
    if (requestElements?.length !== 4) {
      throw new CertificateError("Invalid CSR data");
    }
    const [versionNode, subjectNode, publicKeyNode] = requestElements;
    const requestVersionBytes = versionNode[DerKey.Bytes];
    if (requestVersionBytes.length !== 1 || requestVersionBytes[0] !== 0) {
      throw new CertificateError(`Unsupported CSR version ${requestVersionBytes[0]}`);
    }
    if (!subjectNode[DerKey.Elements]?.length) {
      throw new CertificateError("Missing subject in CSR data");
    }
    const { [DerKey.Elements]: publicKeyElements } = publicKeyNode;
    if (publicKeyElements?.length !== 2) {
      throw new CertificateError("Invalid CSR data");
    }
    const [publicKeyTypeNode, publicKeyBytesNode] = publicKeyElements;
    const { [DerKey.Elements]: publicKeyTypeNodeElements } = publicKeyTypeNode;
    if (publicKeyTypeNodeElements?.length !== 2) {
      throw new CertificateError("Invalid public key type in CSR");
    }
    if (!Bytes.areEqual(
      publicKeyTypeNodeElements[0][DerKey.Bytes],
      X962.PublicKeyAlgorithmEcPublicKey[DerKey.Bytes]
    )) {
      throw new CertificateError("Unsupported public key algorithm in CSR");
    }
    if (!Bytes.areEqual(
      publicKeyTypeNodeElements[1][DerKey.Bytes],
      X962.PublicKeyAlgorithmEcPublicKeyP256[DerKey.Bytes]
    )) {
      throw new CertificateError("Unsupported public key curve in CSR");
    }
    const publicKey = publicKeyBytesNode[DerKey.Bytes];
    const signatureAlgorithmBytes = signAlgorithmNode[DerKey.Elements]?.[0]?.[DerKey.Bytes];
    if (signatureAlgorithmBytes === void 0 || !Bytes.areEqual(X962.EcdsaWithSHA256[DerKey.ObjectId][DerKey.Bytes], signatureAlgorithmBytes)) {
      throw new CertificateError("Unsupported signature algorithm in CSR");
    }
    await crypto.verifyEcdsa(
      PublicKey(publicKey),
      DerCodec.encode(requestNode),
      signatureNode[DerKey.Bytes],
      "der"
    );
    return publicKey;
  }
}
export {
  X509Base
};
//# sourceMappingURL=X509Base.js.map
