/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { TypeFromSchema } from "#types";
/**
 * Matter specific Certificate Sizes
 * @see {@link MatterSpecification.v13.Core} 6.1.3.
 */
export declare const MAX_TLV_CERTIFICATE_SIZE = 400;
export declare const TlvCertificateExtension: import("#types").ObjectSchema<{
    basicConstraints: import("#types").FieldType<import("#types").TypeFromFields<{
        isCa: import("#types").FieldType<boolean>;
        pathLen: import("#types").OptionalFieldType<number>;
    }>>;
    keyUsage: import("#types").FieldType<import("#types").TypeFromPartialBitSchema<{
        digitalSignature: import("#types").BitFlag;
        nonRepudiation: import("#types").BitFlag;
        keyEncipherment: import("#types").BitFlag;
        dataEncipherment: import("#types").BitFlag;
        keyAgreement: import("#types").BitFlag;
        keyCertSign: import("#types").BitFlag;
        cRLSign: import("#types").BitFlag;
        encipherOnly: import("#types").BitFlag;
        decipherOnly: import("#types").BitFlag;
    }>>;
    extendedKeyUsage: import("#types").OptionalFieldType<number[]>;
    subjectKeyIdentifier: import("#types").FieldType<Uint8Array<ArrayBufferLike>>;
    authorityKeyIdentifier: import("#types").FieldType<Uint8Array<ArrayBufferLike>>;
    futureExtension: import("#types").OptionalRepeatedFieldType<Uint8Array<ArrayBufferLike>[]>;
}>;
export type CertificateExtension = TypeFromSchema<typeof TlvCertificateExtension>;
/** Definitions for Matter Operational Certificates (RCAC, ICAC, NOC) */
export declare namespace OperationalCertificate {
    const TlvRcac: import("#types").ObjectSchemaWithMaxSize<{
        serialNumber: import("#types").FieldType<Uint8Array<ArrayBufferLike>>;
        signatureAlgorithm: import("#types").FieldType<number>;
        issuer: import("#types").FieldType<import("#types").TypeFromFields<{
            commonName: import("#types").OptionalFieldType<string>;
            sureName: import("#types").OptionalFieldType<string>;
            serialNum: import("#types").OptionalFieldType<string>;
            countryName: import("#types").OptionalFieldType<string>;
            localityName: import("#types").OptionalFieldType<string>;
            stateOrProvinceName: import("#types").OptionalFieldType<string>;
            orgName: import("#types").OptionalFieldType<string>;
            orgUnitName: import("#types").OptionalFieldType<string>;
            title: import("#types").OptionalFieldType<string>;
            name: import("#types").OptionalFieldType<string>;
            givenName: import("#types").OptionalFieldType<string>;
            initials: import("#types").OptionalFieldType<string>;
            genQualifier: import("#types").OptionalFieldType<string>;
            dnQualifier: import("#types").OptionalFieldType<string>;
            pseudonym: import("#types").OptionalFieldType<string>;
            domainComponent: import("#types").OptionalFieldType<string>;
        } & {
            nodeId: import("#types").OptionalFieldType<import("#types").NodeId>;
            firmwareSigningId: import("#types").OptionalFieldType<number>;
            icacId: import("#types").OptionalFieldType<number | bigint>;
            rcacId: import("#types").OptionalFieldType<number | bigint>;
            fabricId: import("#types").OptionalFieldType<import("#types").FabricId>;
            caseAuthenticatedTags: import("#types").OptionalRepeatedFieldType<import("#types").CaseAuthenticatedTag[]>;
        } & {
            commonNamePs: import("#types").OptionalFieldType<string>;
            sureNamePs: import("#types").OptionalFieldType<string>;
            serialNumPs: import("#types").OptionalFieldType<string>;
            countryNamePs: import("#types").OptionalFieldType<string>;
            localityNamePs: import("#types").OptionalFieldType<string>;
            stateOrProvinceNamePs: import("#types").OptionalFieldType<string>;
            orgNamePs: import("#types").OptionalFieldType<string>;
            orgUnitNamePs: import("#types").OptionalFieldType<string>;
            titlePs: import("#types").OptionalFieldType<string>;
            namePs: import("#types").OptionalFieldType<string>;
            givenNamePs: import("#types").OptionalFieldType<string>;
            initialsPs: import("#types").OptionalFieldType<string>;
            genQualifierPs: import("#types").OptionalFieldType<string>;
            dnQualifierPs: import("#types").OptionalFieldType<string>;
            pseudonymPs: import("#types").OptionalFieldType<string>;
        }>>;
        notBefore: import("#types").FieldType<number>;
        notAfter: import("#types").FieldType<number>;
        subject: import("#types").FieldType<import("#types").TypeFromFields<{
            commonName: import("#types").OptionalFieldType<string>;
            sureName: import("#types").OptionalFieldType<string>;
            serialNum: import("#types").OptionalFieldType<string>;
            countryName: import("#types").OptionalFieldType<string>;
            localityName: import("#types").OptionalFieldType<string>;
            stateOrProvinceName: import("#types").OptionalFieldType<string>;
            orgName: import("#types").OptionalFieldType<string>;
            orgUnitName: import("#types").OptionalFieldType<string>;
            title: import("#types").OptionalFieldType<string>;
            name: import("#types").OptionalFieldType<string>;
            givenName: import("#types").OptionalFieldType<string>;
            initials: import("#types").OptionalFieldType<string>;
            genQualifier: import("#types").OptionalFieldType<string>;
            dnQualifier: import("#types").OptionalFieldType<string>;
            pseudonym: import("#types").OptionalFieldType<string>;
            domainComponent: import("#types").OptionalFieldType<string>;
        } & {
            rcacId: import("#types").FieldType<number | bigint>;
            fabricId: import("#types").OptionalFieldType<import("#types").FabricId>;
        } & {
            commonNamePs: import("#types").OptionalFieldType<string>;
            sureNamePs: import("#types").OptionalFieldType<string>;
            serialNumPs: import("#types").OptionalFieldType<string>;
            countryNamePs: import("#types").OptionalFieldType<string>;
            localityNamePs: import("#types").OptionalFieldType<string>;
            stateOrProvinceNamePs: import("#types").OptionalFieldType<string>;
            orgNamePs: import("#types").OptionalFieldType<string>;
            orgUnitNamePs: import("#types").OptionalFieldType<string>;
            titlePs: import("#types").OptionalFieldType<string>;
            namePs: import("#types").OptionalFieldType<string>;
            givenNamePs: import("#types").OptionalFieldType<string>;
            initialsPs: import("#types").OptionalFieldType<string>;
            genQualifierPs: import("#types").OptionalFieldType<string>;
            dnQualifierPs: import("#types").OptionalFieldType<string>;
            pseudonymPs: import("#types").OptionalFieldType<string>;
        }>>;
        publicKeyAlgorithm: import("#types").FieldType<number>;
        ellipticCurveIdentifier: import("#types").FieldType<number>;
        ellipticCurvePublicKey: import("#types").FieldType<Uint8Array<ArrayBufferLike>>;
        extensions: import("#types").FieldType<import("#types").TypeFromFields<{
            basicConstraints: import("#types").FieldType<import("#types").TypeFromFields<{
                isCa: import("#types").FieldType<boolean>;
                pathLen: import("#types").OptionalFieldType<number>;
            }>>;
            keyUsage: import("#types").FieldType<import("#types").TypeFromPartialBitSchema<{
                digitalSignature: import("#types").BitFlag;
                nonRepudiation: import("#types").BitFlag;
                keyEncipherment: import("#types").BitFlag;
                dataEncipherment: import("#types").BitFlag;
                keyAgreement: import("#types").BitFlag;
                keyCertSign: import("#types").BitFlag;
                cRLSign: import("#types").BitFlag;
                encipherOnly: import("#types").BitFlag;
                decipherOnly: import("#types").BitFlag;
            }>>;
            extendedKeyUsage: import("#types").OptionalFieldType<number[]>;
            subjectKeyIdentifier: import("#types").FieldType<Uint8Array<ArrayBufferLike>>;
            authorityKeyIdentifier: import("#types").FieldType<Uint8Array<ArrayBufferLike>>;
            futureExtension: import("#types").OptionalRepeatedFieldType<Uint8Array<ArrayBufferLike>[]>;
        }>>;
        signature: import("#types").FieldType<Uint8Array<ArrayBufferLike>>;
    }>;
    const TlvNoc: import("#types").ObjectSchemaWithMaxSize<{
        serialNumber: import("#types").FieldType<Uint8Array<ArrayBufferLike>>;
        signatureAlgorithm: import("#types").FieldType<number>;
        issuer: import("#types").FieldType<import("#types").TypeFromFields<{
            commonName: import("#types").OptionalFieldType<string>;
            sureName: import("#types").OptionalFieldType<string>;
            serialNum: import("#types").OptionalFieldType<string>;
            countryName: import("#types").OptionalFieldType<string>;
            localityName: import("#types").OptionalFieldType<string>;
            stateOrProvinceName: import("#types").OptionalFieldType<string>;
            orgName: import("#types").OptionalFieldType<string>;
            orgUnitName: import("#types").OptionalFieldType<string>;
            title: import("#types").OptionalFieldType<string>;
            name: import("#types").OptionalFieldType<string>;
            givenName: import("#types").OptionalFieldType<string>;
            initials: import("#types").OptionalFieldType<string>;
            genQualifier: import("#types").OptionalFieldType<string>;
            dnQualifier: import("#types").OptionalFieldType<string>;
            pseudonym: import("#types").OptionalFieldType<string>;
            domainComponent: import("#types").OptionalFieldType<string>;
        } & {
            nodeId: import("#types").OptionalFieldType<import("#types").NodeId>;
            firmwareSigningId: import("#types").OptionalFieldType<number>;
            icacId: import("#types").OptionalFieldType<number | bigint>;
            rcacId: import("#types").OptionalFieldType<number | bigint>;
            fabricId: import("#types").OptionalFieldType<import("#types").FabricId>;
            caseAuthenticatedTags: import("#types").OptionalRepeatedFieldType<import("#types").CaseAuthenticatedTag[]>;
        } & {
            commonNamePs: import("#types").OptionalFieldType<string>;
            sureNamePs: import("#types").OptionalFieldType<string>;
            serialNumPs: import("#types").OptionalFieldType<string>;
            countryNamePs: import("#types").OptionalFieldType<string>;
            localityNamePs: import("#types").OptionalFieldType<string>;
            stateOrProvinceNamePs: import("#types").OptionalFieldType<string>;
            orgNamePs: import("#types").OptionalFieldType<string>;
            orgUnitNamePs: import("#types").OptionalFieldType<string>;
            titlePs: import("#types").OptionalFieldType<string>;
            namePs: import("#types").OptionalFieldType<string>;
            givenNamePs: import("#types").OptionalFieldType<string>;
            initialsPs: import("#types").OptionalFieldType<string>;
            genQualifierPs: import("#types").OptionalFieldType<string>;
            dnQualifierPs: import("#types").OptionalFieldType<string>;
            pseudonymPs: import("#types").OptionalFieldType<string>;
        }>>;
        notBefore: import("#types").FieldType<number>;
        notAfter: import("#types").FieldType<number>;
        subject: import("#types").FieldType<import("#types").TypeFromFields<{
            commonName: import("#types").OptionalFieldType<string>;
            sureName: import("#types").OptionalFieldType<string>;
            serialNum: import("#types").OptionalFieldType<string>;
            countryName: import("#types").OptionalFieldType<string>;
            localityName: import("#types").OptionalFieldType<string>;
            stateOrProvinceName: import("#types").OptionalFieldType<string>;
            orgName: import("#types").OptionalFieldType<string>;
            orgUnitName: import("#types").OptionalFieldType<string>;
            title: import("#types").OptionalFieldType<string>;
            name: import("#types").OptionalFieldType<string>;
            givenName: import("#types").OptionalFieldType<string>;
            initials: import("#types").OptionalFieldType<string>;
            genQualifier: import("#types").OptionalFieldType<string>;
            dnQualifier: import("#types").OptionalFieldType<string>;
            pseudonym: import("#types").OptionalFieldType<string>;
            domainComponent: import("#types").OptionalFieldType<string>;
        } & {
            nodeId: import("#types").FieldType<import("#types").NodeId>;
            fabricId: import("#types").FieldType<import("#types").FabricId>;
            caseAuthenticatedTags: import("#types").OptionalRepeatedFieldType<import("#types").CaseAuthenticatedTag[]>;
        } & {
            commonNamePs: import("#types").OptionalFieldType<string>;
            sureNamePs: import("#types").OptionalFieldType<string>;
            serialNumPs: import("#types").OptionalFieldType<string>;
            countryNamePs: import("#types").OptionalFieldType<string>;
            localityNamePs: import("#types").OptionalFieldType<string>;
            stateOrProvinceNamePs: import("#types").OptionalFieldType<string>;
            orgNamePs: import("#types").OptionalFieldType<string>;
            orgUnitNamePs: import("#types").OptionalFieldType<string>;
            titlePs: import("#types").OptionalFieldType<string>;
            namePs: import("#types").OptionalFieldType<string>;
            givenNamePs: import("#types").OptionalFieldType<string>;
            initialsPs: import("#types").OptionalFieldType<string>;
            genQualifierPs: import("#types").OptionalFieldType<string>;
            dnQualifierPs: import("#types").OptionalFieldType<string>;
            pseudonymPs: import("#types").OptionalFieldType<string>;
        }>>;
        publicKeyAlgorithm: import("#types").FieldType<number>;
        ellipticCurveIdentifier: import("#types").FieldType<number>;
        ellipticCurvePublicKey: import("#types").FieldType<Uint8Array<ArrayBufferLike>>;
        extensions: import("#types").FieldType<import("#types").TypeFromFields<{
            basicConstraints: import("#types").FieldType<import("#types").TypeFromFields<{
                isCa: import("#types").FieldType<boolean>;
                pathLen: import("#types").OptionalFieldType<number>;
            }>>;
            keyUsage: import("#types").FieldType<import("#types").TypeFromPartialBitSchema<{
                digitalSignature: import("#types").BitFlag;
                nonRepudiation: import("#types").BitFlag;
                keyEncipherment: import("#types").BitFlag;
                dataEncipherment: import("#types").BitFlag;
                keyAgreement: import("#types").BitFlag;
                keyCertSign: import("#types").BitFlag;
                cRLSign: import("#types").BitFlag;
                encipherOnly: import("#types").BitFlag;
                decipherOnly: import("#types").BitFlag;
            }>>;
            extendedKeyUsage: import("#types").OptionalFieldType<number[]>;
            subjectKeyIdentifier: import("#types").FieldType<Uint8Array<ArrayBufferLike>>;
            authorityKeyIdentifier: import("#types").FieldType<Uint8Array<ArrayBufferLike>>;
            futureExtension: import("#types").OptionalRepeatedFieldType<Uint8Array<ArrayBufferLike>[]>;
        }>>;
        signature: import("#types").FieldType<Uint8Array<ArrayBufferLike>>;
    }>;
    const TlvIcac: import("#types").ObjectSchemaWithMaxSize<{
        serialNumber: import("#types").FieldType<Uint8Array<ArrayBufferLike>>;
        signatureAlgorithm: import("#types").FieldType<number>;
        issuer: import("#types").FieldType<import("#types").TypeFromFields<{
            commonName: import("#types").OptionalFieldType<string>;
            sureName: import("#types").OptionalFieldType<string>;
            serialNum: import("#types").OptionalFieldType<string>;
            countryName: import("#types").OptionalFieldType<string>;
            localityName: import("#types").OptionalFieldType<string>;
            stateOrProvinceName: import("#types").OptionalFieldType<string>;
            orgName: import("#types").OptionalFieldType<string>;
            orgUnitName: import("#types").OptionalFieldType<string>;
            title: import("#types").OptionalFieldType<string>;
            name: import("#types").OptionalFieldType<string>;
            givenName: import("#types").OptionalFieldType<string>;
            initials: import("#types").OptionalFieldType<string>;
            genQualifier: import("#types").OptionalFieldType<string>;
            dnQualifier: import("#types").OptionalFieldType<string>;
            pseudonym: import("#types").OptionalFieldType<string>;
            domainComponent: import("#types").OptionalFieldType<string>;
        } & {
            nodeId: import("#types").OptionalFieldType<import("#types").NodeId>;
            firmwareSigningId: import("#types").OptionalFieldType<number>;
            icacId: import("#types").OptionalFieldType<number | bigint>;
            rcacId: import("#types").OptionalFieldType<number | bigint>;
            fabricId: import("#types").OptionalFieldType<import("#types").FabricId>;
            caseAuthenticatedTags: import("#types").OptionalRepeatedFieldType<import("#types").CaseAuthenticatedTag[]>;
        } & {
            commonNamePs: import("#types").OptionalFieldType<string>;
            sureNamePs: import("#types").OptionalFieldType<string>;
            serialNumPs: import("#types").OptionalFieldType<string>;
            countryNamePs: import("#types").OptionalFieldType<string>;
            localityNamePs: import("#types").OptionalFieldType<string>;
            stateOrProvinceNamePs: import("#types").OptionalFieldType<string>;
            orgNamePs: import("#types").OptionalFieldType<string>;
            orgUnitNamePs: import("#types").OptionalFieldType<string>;
            titlePs: import("#types").OptionalFieldType<string>;
            namePs: import("#types").OptionalFieldType<string>;
            givenNamePs: import("#types").OptionalFieldType<string>;
            initialsPs: import("#types").OptionalFieldType<string>;
            genQualifierPs: import("#types").OptionalFieldType<string>;
            dnQualifierPs: import("#types").OptionalFieldType<string>;
            pseudonymPs: import("#types").OptionalFieldType<string>;
        }>>;
        notBefore: import("#types").FieldType<number>;
        notAfter: import("#types").FieldType<number>;
        subject: import("#types").FieldType<import("#types").TypeFromFields<{
            commonName: import("#types").OptionalFieldType<string>;
            sureName: import("#types").OptionalFieldType<string>;
            serialNum: import("#types").OptionalFieldType<string>;
            countryName: import("#types").OptionalFieldType<string>;
            localityName: import("#types").OptionalFieldType<string>;
            stateOrProvinceName: import("#types").OptionalFieldType<string>;
            orgName: import("#types").OptionalFieldType<string>;
            orgUnitName: import("#types").OptionalFieldType<string>;
            title: import("#types").OptionalFieldType<string>;
            name: import("#types").OptionalFieldType<string>;
            givenName: import("#types").OptionalFieldType<string>;
            initials: import("#types").OptionalFieldType<string>;
            genQualifier: import("#types").OptionalFieldType<string>;
            dnQualifier: import("#types").OptionalFieldType<string>;
            pseudonym: import("#types").OptionalFieldType<string>;
            domainComponent: import("#types").OptionalFieldType<string>;
        } & {
            icacId: import("#types").FieldType<number | bigint>;
            fabricId: import("#types").OptionalFieldType<import("#types").FabricId>;
        } & {
            commonNamePs: import("#types").OptionalFieldType<string>;
            sureNamePs: import("#types").OptionalFieldType<string>;
            serialNumPs: import("#types").OptionalFieldType<string>;
            countryNamePs: import("#types").OptionalFieldType<string>;
            localityNamePs: import("#types").OptionalFieldType<string>;
            stateOrProvinceNamePs: import("#types").OptionalFieldType<string>;
            orgNamePs: import("#types").OptionalFieldType<string>;
            orgUnitNamePs: import("#types").OptionalFieldType<string>;
            titlePs: import("#types").OptionalFieldType<string>;
            namePs: import("#types").OptionalFieldType<string>;
            givenNamePs: import("#types").OptionalFieldType<string>;
            initialsPs: import("#types").OptionalFieldType<string>;
            genQualifierPs: import("#types").OptionalFieldType<string>;
            dnQualifierPs: import("#types").OptionalFieldType<string>;
            pseudonymPs: import("#types").OptionalFieldType<string>;
        }>>;
        publicKeyAlgorithm: import("#types").FieldType<number>;
        ellipticCurveIdentifier: import("#types").FieldType<number>;
        ellipticCurvePublicKey: import("#types").FieldType<Uint8Array<ArrayBufferLike>>;
        extensions: import("#types").FieldType<import("#types").TypeFromFields<{
            basicConstraints: import("#types").FieldType<import("#types").TypeFromFields<{
                isCa: import("#types").FieldType<boolean>;
                pathLen: import("#types").OptionalFieldType<number>;
            }>>;
            keyUsage: import("#types").FieldType<import("#types").TypeFromPartialBitSchema<{
                digitalSignature: import("#types").BitFlag;
                nonRepudiation: import("#types").BitFlag;
                keyEncipherment: import("#types").BitFlag;
                dataEncipherment: import("#types").BitFlag;
                keyAgreement: import("#types").BitFlag;
                keyCertSign: import("#types").BitFlag;
                cRLSign: import("#types").BitFlag;
                encipherOnly: import("#types").BitFlag;
                decipherOnly: import("#types").BitFlag;
            }>>;
            extendedKeyUsage: import("#types").OptionalFieldType<number[]>;
            subjectKeyIdentifier: import("#types").FieldType<Uint8Array<ArrayBufferLike>>;
            authorityKeyIdentifier: import("#types").FieldType<Uint8Array<ArrayBufferLike>>;
            futureExtension: import("#types").OptionalRepeatedFieldType<Uint8Array<ArrayBufferLike>[]>;
        }>>;
        signature: import("#types").FieldType<Uint8Array<ArrayBufferLike>>;
    }>;
    type Rcac = TypeFromSchema<typeof TlvRcac>;
    type Icac = TypeFromSchema<typeof TlvIcac>;
    type Noc = TypeFromSchema<typeof TlvNoc>;
}
//# sourceMappingURL=operational.d.ts.map