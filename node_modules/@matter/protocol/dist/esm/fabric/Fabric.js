/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { Icac } from "#certificate/kinds/Icac.js";
import { Noc } from "#certificate/kinds/Noc.js";
import { Rcac } from "#certificate/kinds/Rcac.js";
import { X509Base } from "#certificate/kinds/X509Base.js";
import {
  Bytes,
  DataWriter,
  Diagnostic,
  Endian,
  ImplementationError,
  InternalError,
  Logger,
  MatterError,
  MatterFlowError,
  PrivateKey
} from "#general";
import { FabricGroups, GROUP_SECURITY_INFO } from "#groups/FabricGroups.js";
import { FabricAccessControl } from "#interaction/FabricAccessControl.js";
import { PeerAddress } from "#peer/PeerAddress.js";
import { CaseAuthenticatedTag, FabricId, GroupId, NodeId } from "#types";
const logger = Logger.get("Fabric");
const COMPRESSED_FABRIC_ID_INFO = Bytes.fromString("CompressedFabric");
class PublicKeyError extends MatterError {
}
class Fabric {
  #crypto;
  fabricIndex;
  fabricId;
  nodeId;
  rootNodeId;
  operationalId;
  rootPublicKey;
  rootVendorId;
  rootCert;
  identityProtectionKey;
  operationalIdentityProtectionKey;
  intermediateCACert;
  operationalCert;
  #keyPair;
  #sessions = /* @__PURE__ */ new Set();
  #groups;
  #aclManager;
  #label;
  #removeCallbacks = new Array();
  #persistCallback;
  #storage;
  constructor(crypto, config) {
    this.#crypto = crypto;
    this.fabricIndex = config.fabricIndex;
    this.fabricId = config.fabricId;
    this.nodeId = config.nodeId;
    this.rootNodeId = config.rootNodeId;
    this.operationalId = config.operationalId;
    this.rootPublicKey = config.rootPublicKey;
    this.rootVendorId = config.rootVendorId;
    this.rootCert = config.rootCert;
    this.identityProtectionKey = config.identityProtectionKey;
    this.operationalIdentityProtectionKey = config.operationalIdentityProtectionKey;
    this.intermediateCACert = config.intermediateCACert;
    this.operationalCert = config.operationalCert;
    this.#label = config.label;
    this.#keyPair = PrivateKey(config.keyPair);
    this.#aclManager = new FabricAccessControl(this);
    this.#groups = new FabricGroups(this);
  }
  get crypto() {
    return this.#crypto;
  }
  get config() {
    return {
      fabricIndex: this.fabricIndex,
      fabricId: this.fabricId,
      nodeId: this.nodeId,
      rootNodeId: this.rootNodeId,
      operationalId: this.operationalId,
      rootPublicKey: this.rootPublicKey,
      keyPair: this.#keyPair.keyPair,
      rootVendorId: this.rootVendorId,
      rootCert: this.rootCert,
      identityProtectionKey: this.identityProtectionKey,
      operationalIdentityProtectionKey: this.operationalIdentityProtectionKey,
      intermediateCACert: this.intermediateCACert,
      operationalCert: this.operationalCert,
      label: this.#label
    };
  }
  get label() {
    return this.#label;
  }
  async setLabel(label) {
    if (label.length === 0 || label.length > 32) {
      throw new ImplementationError("Fabric label must be between 1 and 32 characters long.");
    }
    if (this.#label === label) {
      return;
    }
    this.#label = label;
    await this.persist();
  }
  set storage(storage) {
    this.#storage = storage;
    this.#groups.storage = storage;
  }
  get storage() {
    return this.#storage;
  }
  get groups() {
    return this.#groups;
  }
  get acl() {
    return this.#aclManager;
  }
  get publicKey() {
    return this.#keyPair.publicKey;
  }
  sign(data) {
    return this.crypto.signEcdsa(this.#keyPair, data);
  }
  async verifyCredentials(operationalCert, intermediateCACert) {
    const rootCert = Rcac.fromTlv(this.rootCert);
    const nocCert = Noc.fromTlv(operationalCert);
    const icaCert = intermediateCACert !== void 0 ? Icac.fromTlv(intermediateCACert) : void 0;
    if (icaCert !== void 0) {
      await icaCert.verify(this.#crypto, rootCert);
    }
    await nocCert.verify(this.#crypto, rootCert, icaCert);
  }
  matchesFabricIdAndRootPublicKey(fabricId, rootPublicKey) {
    return this.fabricId === fabricId && Bytes.areEqual(this.rootPublicKey, rootPublicKey);
  }
  matchesKeyPair(keyPair) {
    return Bytes.areEqual(this.#keyPair.publicKey, keyPair.publicKey) && Bytes.areEqual(this.#keyPair.privateKey, keyPair.privateKey);
  }
  #generateSalt(nodeId, random) {
    const writer = new DataWriter(Endian.Little);
    writer.writeByteArray(random);
    writer.writeByteArray(this.rootPublicKey);
    writer.writeUInt64(this.fabricId);
    writer.writeUInt64(nodeId);
    return writer.toByteArray();
  }
  /**
   * Returns the destination IDs for a given nodeId, random value and optional groupId. When groupId is provided, it
   * returns the time-wise valid operational keys for that groupId.
   */
  async currentDestinationIdFor(nodeId, random) {
    return await this.#crypto.signHmac(
      this.groups.keySets.currentKeyForId(0).key,
      this.#generateSalt(nodeId, random)
    );
  }
  /**
   * Returns the destination IDs for a given nodeId, random value and optional groupId. When groupId is provided, it
   * returns all operational keys for that groupId.
   */
  async destinationIdsFor(nodeId, random) {
    const salt = this.#generateSalt(nodeId, random);
    const destinationIds = this.groups.keySets.allKeysForId(0).map(({ key }) => this.#crypto.signHmac(key, salt));
    return await Promise.all(destinationIds);
  }
  addSession(session) {
    this.#sessions.add(session);
  }
  removeSession(session) {
    this.#sessions.delete(session);
  }
  addRemoveCallback(callback) {
    this.#removeCallbacks.push(callback);
  }
  deleteRemoveCallback(callback) {
    const index = this.#removeCallbacks.indexOf(callback);
    if (index >= 0) {
      this.#removeCallbacks.splice(index, 1);
    }
  }
  set persistCallback(callback) {
    this.#persistCallback = callback;
  }
  async remove(currentSessionId) {
    for (const callback of this.#removeCallbacks) {
      await callback();
    }
    for (const session of [...this.#sessions]) {
      await session.destroy(false, session.id === currentSessionId);
    }
  }
  persist(isUpdate = true) {
    return this.#persistCallback?.(isUpdate);
  }
  get externalInformation() {
    return {
      fabricIndex: this.fabricIndex,
      fabricId: this.fabricId,
      nodeId: this.nodeId,
      rootNodeId: this.rootNodeId,
      rootVendorId: this.rootVendorId,
      label: this.#label
    };
  }
  addressOf(nodeId) {
    return PeerAddress({ fabricIndex: this.fabricIndex, nodeId });
  }
  groupAddressOf(groupId) {
    GroupId.assertGroupId(groupId);
    return PeerAddress({ fabricIndex: this.fabricIndex, nodeId: NodeId.fromGroupId(groupId) });
  }
}
class FabricBuilder {
  #crypto;
  #keyPair;
  #rootVendorId;
  #rootCert;
  #intermediateCACert;
  #operationalCert;
  #fabricId;
  #nodeId;
  #rootNodeId;
  #rootPublicKey;
  #identityProtectionKey;
  #fabricIndex;
  #label = "";
  constructor(crypto, key) {
    this.#crypto = crypto;
    this.#keyPair = key;
  }
  static async create(crypto) {
    return new FabricBuilder(crypto, await crypto.createKeyPair());
  }
  get publicKey() {
    return this.#keyPair.publicKey;
  }
  get fabricIndex() {
    return this.#fabricIndex;
  }
  createCertificateSigningRequest() {
    return X509Base.createCertificateSigningRequest(this.#crypto, this.#keyPair);
  }
  async setRootCert(rootCert) {
    const root = Rcac.fromTlv(rootCert);
    await root.verify(this.#crypto);
    this.#rootCert = rootCert;
    this.#rootPublicKey = root.cert.ellipticCurvePublicKey;
    return this;
  }
  get rootCert() {
    return this.#rootCert;
  }
  async setOperationalCert(operationalCert, intermediateCACert) {
    if (intermediateCACert !== void 0 && intermediateCACert.length === 0) {
      intermediateCACert = void 0;
    }
    const {
      subject: { nodeId, fabricId, caseAuthenticatedTags },
      ellipticCurvePublicKey
    } = Noc.fromTlv(operationalCert).cert;
    logger.debug(
      "Installing operational certificate",
      Diagnostic.dict({ nodeId, fabricId, caseAuthenticatedTags })
    );
    if (caseAuthenticatedTags !== void 0) {
      CaseAuthenticatedTag.validateNocTagList(caseAuthenticatedTags);
    }
    if (!Bytes.areEqual(ellipticCurvePublicKey, this.#keyPair.publicKey)) {
      throw new PublicKeyError("Operational certificate does not match public key");
    }
    if (this.#rootCert === void 0) {
      throw new MatterFlowError("Root certificate needs to be set first");
    }
    const rootCert = Rcac.fromTlv(this.#rootCert);
    const nocCert = Noc.fromTlv(operationalCert);
    const icaCert = intermediateCACert !== void 0 ? Icac.fromTlv(intermediateCACert) : void 0;
    if (icaCert !== void 0) {
      await icaCert.verify(this.#crypto, rootCert);
    }
    await nocCert.verify(this.#crypto, rootCert, icaCert);
    this.#operationalCert = operationalCert;
    this.#intermediateCACert = intermediateCACert;
    this.#fabricId = FabricId(fabricId);
    this.#nodeId = nodeId;
    return this;
  }
  setRootVendorId(rootVendorId) {
    this.#rootVendorId = rootVendorId;
    return this;
  }
  setRootNodeId(rootNodeId) {
    this.#rootNodeId = rootNodeId;
    return this;
  }
  setIdentityProtectionKey(key) {
    this.#identityProtectionKey = key;
    return this;
  }
  setLabel(label) {
    if (label.length === 0 || label.length > 32) {
      throw new ImplementationError("Fabric label must be between 1 and 32 characters long.");
    }
    this.#label = label;
    return this;
  }
  initializeFromFabricForUpdate(fabric) {
    this.#rootVendorId = fabric.rootVendorId;
    this.#rootNodeId = fabric.rootNodeId;
    this.#identityProtectionKey = fabric.identityProtectionKey;
    this.#rootCert = fabric.rootCert;
    this.#rootPublicKey = fabric.rootPublicKey;
    this.#label = fabric.label;
  }
  matchesToFabric(fabric) {
    if (this.#fabricId === void 0 || this.#rootPublicKey === void 0) {
      throw new MatterFlowError("Node Operational Data needs to be set first.");
    }
    return fabric.matchesFabricIdAndRootPublicKey(this.#fabricId, this.#rootPublicKey);
  }
  get nodeId() {
    return this.#nodeId;
  }
  get fabricId() {
    return this.#fabricId;
  }
  get keyPair() {
    return this.#keyPair;
  }
  async build(fabricIndex) {
    if (this.#fabricIndex !== void 0) throw new InternalError("FabricBuilder can only be built once");
    if (this.#rootNodeId === void 0) throw new InternalError("rootNodeId needs to be set");
    if (this.#rootVendorId === void 0) throw new InternalError("vendorId needs to be set");
    if (this.#rootCert === void 0 || this.#rootPublicKey === void 0)
      throw new InternalError("rootCert needs to be set");
    if (this.#identityProtectionKey === void 0) throw new InternalError("identityProtectionKey needs to be set");
    if (this.#operationalCert === void 0 || this.#fabricId === void 0 || this.#nodeId === void 0)
      throw new InternalError("operationalCert needs to be set");
    this.#fabricIndex = fabricIndex;
    const saltWriter = new DataWriter();
    saltWriter.writeUInt64(this.#fabricId);
    const operationalId = await this.#crypto.createHkdfKey(
      this.#rootPublicKey.slice(1),
      saltWriter.toByteArray(),
      COMPRESSED_FABRIC_ID_INFO,
      8
    );
    return new Fabric(this.#crypto, {
      fabricIndex: this.#fabricIndex,
      fabricId: this.#fabricId,
      nodeId: this.#nodeId,
      rootNodeId: this.#rootNodeId,
      operationalId,
      rootPublicKey: this.#rootPublicKey,
      keyPair: this.#keyPair,
      rootVendorId: this.#rootVendorId,
      rootCert: this.#rootCert,
      identityProtectionKey: this.#identityProtectionKey,
      // Epoch Key
      operationalIdentityProtectionKey: await this.#crypto.createHkdfKey(
        this.#identityProtectionKey,
        operationalId,
        GROUP_SECURITY_INFO
      ),
      intermediateCACert: this.#intermediateCACert,
      operationalCert: this.#operationalCert,
      label: this.#label
    });
  }
}
export {
  Fabric,
  FabricBuilder,
  PublicKeyError
};
//# sourceMappingURL=Fabric.js.map
