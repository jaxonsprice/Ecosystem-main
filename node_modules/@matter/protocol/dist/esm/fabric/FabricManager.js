/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import {
  Bytes,
  Construction,
  Crypto,
  Environmental,
  ImplementationError,
  MatterError,
  MatterFlowError,
  MaybePromise,
  Observable,
  StorageManager
} from "#general";
import { FabricIndex } from "#types";
import { Fabric } from "./Fabric.js";
class FabricNotFoundError extends MatterError {
}
class FabricTableFullError extends MatterError {
}
var FabricAction = /* @__PURE__ */ ((FabricAction2) => {
  FabricAction2[FabricAction2["Added"] = 0] = "Added";
  FabricAction2[FabricAction2["Removed"] = 1] = "Removed";
  FabricAction2[FabricAction2["Updated"] = 2] = "Updated";
  return FabricAction2;
})(FabricAction || {});
class FabricManager {
  #crypto;
  #nextFabricIndex = 1;
  #fabrics = /* @__PURE__ */ new Map();
  #initializationDone = false;
  #storage;
  #events = {
    added: Observable(),
    updated: Observable(),
    deleted: Observable(),
    failsafeClosed: Observable()
  };
  #construction;
  constructor(crypto, storage) {
    this.#crypto = crypto;
    this.#storage = storage;
    let construct;
    if (this.#storage === void 0) {
      construct = () => {
      };
    } else {
      construct = async () => {
        if (this.#storage === void 0) {
          return;
        }
        const fabrics = await this.#storage.get("fabrics", []);
        for (const fabricConfig of fabrics) {
          this.#addFabric(new Fabric(crypto, fabricConfig));
        }
        this.#nextFabricIndex = await this.#storage.get("nextFabricIndex", this.#nextFabricIndex);
        this.#initializationDone = true;
      };
    }
    this.#construction = Construction(this, construct);
  }
  get crypto() {
    return this.#crypto;
  }
  get construction() {
    return this.#construction;
  }
  async [Construction.construct]() {
    await this.construction;
  }
  static [Environmental.create](env) {
    const instance = new FabricManager(env.get(Crypto), env.get(StorageManager).createContext("fabrics"));
    env.set(FabricManager, instance);
    return instance;
  }
  get events() {
    return this.#events;
  }
  async clear() {
    await this.#construction;
    this.#nextFabricIndex = 1;
    this.#fabrics.clear();
    await this.#storage?.clear();
  }
  has(address) {
    if (typeof address === "object") {
      address = address.fabricIndex;
    }
    return this.#fabrics.has(address);
  }
  for(address) {
    if (typeof address === "object") {
      address = address.fabricIndex;
    }
    const fabric = this.#fabrics.get(address);
    if (fabric === void 0) {
      throw new FabricNotFoundError(`Cannot access fabric for unknown index ${address}`);
    }
    return fabric;
  }
  allocateFabricIndex() {
    this.#construction.assert();
    for (let i = 0; i < 254; i++) {
      const fabricIndex = this.#nextFabricIndex++;
      if (this.#nextFabricIndex > 254) this.#nextFabricIndex = 1;
      if (!this.#fabrics.has(FabricIndex(fabricIndex))) {
        return FabricIndex(fabricIndex);
      }
    }
    throw new FabricTableFullError("No free fabric index available.");
  }
  persistFabrics() {
    if (this.#storage === void 0) {
      throw new ImplementationError(
        "Fabric persistence is disabled because FabricManager constructed without storage"
      );
    }
    this.#construction.assert();
    const storeResult = this.#storage.set(
      "fabrics",
      Array.from(this.#fabrics.values()).map((fabric) => fabric.config)
    );
    if (MaybePromise.is(storeResult)) {
      return storeResult.then(() => this.#storage.set("nextFabricIndex", this.#nextFabricIndex));
    }
    return this.#storage.set("nextFabricIndex", this.#nextFabricIndex);
  }
  addFabric(fabric) {
    this.#construction.assert();
    this.#addFabric(fabric);
  }
  #addFabric(fabric) {
    const { fabricIndex } = fabric;
    if (this.#fabrics.has(fabricIndex)) {
      throw new MatterFlowError(`Fabric with index ${fabricIndex} already exists.`);
    }
    this.#fabrics.set(fabricIndex, fabric);
    fabric.addRemoveCallback(async () => this.removeFabric(fabricIndex));
    fabric.persistCallback = (isUpdate = true) => {
      if (!this.#storage) {
        return;
      }
      const persistResult = this.persistFabrics();
      return MaybePromise.then(persistResult, () => {
        if (isUpdate) {
          this.#events.updated.emit(fabric);
        }
      });
    };
    if (this.#storage !== void 0) {
      fabric.storage = this.#storage.createContext(`fabric-${fabricIndex}`);
    }
    if (this.#initializationDone) {
      this.#events.added.emit(fabric);
    }
  }
  async removeFabric(fabricIndex) {
    await this.#construction;
    const fabric = this.#fabrics.get(fabricIndex);
    if (fabric === void 0)
      throw new FabricNotFoundError(
        `Fabric with index ${fabricIndex} cannot be removed because it does not exist.`
      );
    this.#fabrics.delete(fabricIndex);
    if (this.#storage) {
      await this.persistFabrics();
    }
    await fabric.storage?.clearAll();
    this.#events.deleted.emit(fabric);
  }
  [Symbol.iterator]() {
    this.#construction.assert();
    return this.#fabrics.values();
  }
  get fabrics() {
    this.#construction.assert();
    return Array.from(this.#fabrics.values());
  }
  get length() {
    return this.fabrics.length;
  }
  find(predicate) {
    return this.fabrics.find(predicate);
  }
  map(translator) {
    return this.fabrics.map(translator);
  }
  async findFabricFromDestinationId(destinationId, initiatorRandom) {
    this.#construction.assert();
    for (const fabric of this.#fabrics.values()) {
      const candidateDestinationIds = await fabric.destinationIdsFor(fabric.nodeId, initiatorRandom);
      if (candidateDestinationIds.some((candidate) => Bytes.areEqual(candidate, destinationId))) {
        return fabric;
      }
    }
    throw new FabricNotFoundError();
  }
  findByKeypair(keypair) {
    this.#construction.assert();
    for (const fabric of this.#fabrics.values()) {
      if (fabric.matchesKeyPair(keypair)) {
        return fabric;
      }
    }
    return void 0;
  }
  findByIndex(index) {
    this.#construction.assert();
    return this.#fabrics.get(index);
  }
  async updateFabric(fabric) {
    await this.#construction;
    const { fabricIndex } = fabric;
    if (!this.#fabrics.has(fabricIndex)) {
      throw new FabricNotFoundError(
        `Fabric with index ${fabricIndex} cannot be updated because it does not exist.`
      );
    }
    this.#fabrics.set(fabricIndex, fabric);
    if (this.#storage) {
      await this.persistFabrics();
    }
    this.#events.updated.emit(fabric);
  }
  async revokeFabric(fabricIndex) {
    await this.#construction;
    const fabric = this.#fabrics.get(fabricIndex);
    if (fabric === void 0) {
      throw new MatterFlowError(`Fabric with index ${fabricIndex} does not exist to revoke.`);
    }
    await fabric.remove();
  }
}
export {
  FabricAction,
  FabricManager,
  FabricNotFoundError,
  FabricTableFullError
};
//# sourceMappingURL=FabricManager.js.map
