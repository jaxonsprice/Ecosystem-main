/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { BinaryKeyPair, Crypto, Key, MatterError, MaybePromise, PrivateKey, StorageContext } from "#general";
import { FabricGroups } from "#groups/FabricGroups.js";
import { FabricAccessControl } from "#interaction/FabricAccessControl.js";
import { PeerAddress } from "#peer/PeerAddress.js";
import { Session } from "#session/Session.js";
import { FabricId, FabricIndex, GroupId, NodeId, VendorId } from "#types";
export declare class PublicKeyError extends MatterError {
}
export type ExposedFabricInformation = {
    fabricIndex: FabricIndex;
    fabricId: FabricId;
    nodeId: NodeId;
    rootNodeId: NodeId;
    rootVendorId: VendorId;
    label: string;
};
export declare class Fabric {
    #private;
    readonly fabricIndex: FabricIndex;
    readonly fabricId: FabricId;
    readonly nodeId: NodeId;
    readonly rootNodeId: NodeId;
    readonly operationalId: Uint8Array;
    readonly rootPublicKey: Uint8Array;
    readonly rootVendorId: VendorId;
    readonly rootCert: Uint8Array;
    readonly identityProtectionKey: Uint8Array;
    readonly operationalIdentityProtectionKey: Uint8Array;
    readonly intermediateCACert: Uint8Array | undefined;
    readonly operationalCert: Uint8Array;
    constructor(crypto: Crypto, config: Fabric.Config);
    get crypto(): Crypto;
    get config(): Fabric.Config;
    get label(): string;
    setLabel(label: string): Promise<void>;
    set storage(storage: StorageContext);
    get storage(): StorageContext | undefined;
    get groups(): FabricGroups;
    get acl(): FabricAccessControl;
    get publicKey(): Uint8Array<ArrayBufferLike>;
    sign(data: Uint8Array): MaybePromise<Uint8Array<ArrayBufferLike>>;
    verifyCredentials(operationalCert: Uint8Array, intermediateCACert?: Uint8Array): Promise<void>;
    matchesFabricIdAndRootPublicKey(fabricId: FabricId, rootPublicKey: Uint8Array): boolean;
    matchesKeyPair(keyPair: Key): boolean;
    /**
     * Returns the destination IDs for a given nodeId, random value and optional groupId. When groupId is provided, it
     * returns the time-wise valid operational keys for that groupId.
     */
    currentDestinationIdFor(nodeId: NodeId, random: Uint8Array): Promise<Uint8Array<ArrayBufferLike>>;
    /**
     * Returns the destination IDs for a given nodeId, random value and optional groupId. When groupId is provided, it
     * returns all operational keys for that groupId.
     */
    destinationIdsFor(nodeId: NodeId, random: Uint8Array): Promise<Uint8Array<ArrayBufferLike>[]>;
    addSession(session: Session): void;
    removeSession(session: Session): void;
    addRemoveCallback(callback: () => MaybePromise<void>): void;
    deleteRemoveCallback(callback: () => MaybePromise<void>): void;
    set persistCallback(callback: (isUpdate?: boolean) => MaybePromise<void>);
    remove(currentSessionId?: number): Promise<void>;
    persist(isUpdate?: boolean): MaybePromise<void> | undefined;
    get externalInformation(): ExposedFabricInformation;
    addressOf(nodeId: NodeId): PeerAddress;
    groupAddressOf(groupId: GroupId): PeerAddress;
}
export declare class FabricBuilder {
    #private;
    constructor(crypto: Crypto, key: PrivateKey);
    static create(crypto: Crypto): Promise<FabricBuilder>;
    get publicKey(): Uint8Array<ArrayBufferLike>;
    get fabricIndex(): FabricIndex | undefined;
    createCertificateSigningRequest(): Promise<Uint8Array<ArrayBufferLike>>;
    setRootCert(rootCert: Uint8Array): Promise<this>;
    get rootCert(): Uint8Array<ArrayBufferLike> | undefined;
    setOperationalCert(operationalCert: Uint8Array, intermediateCACert?: Uint8Array): Promise<this>;
    setRootVendorId(rootVendorId: VendorId): this;
    setRootNodeId(rootNodeId: NodeId): this;
    setIdentityProtectionKey(key: Uint8Array): this;
    setLabel(label: string): this;
    initializeFromFabricForUpdate(fabric: Fabric): void;
    matchesToFabric(fabric: Fabric): boolean;
    get nodeId(): NodeId | undefined;
    get fabricId(): FabricId | undefined;
    get keyPair(): PrivateKey;
    build(fabricIndex: FabricIndex): Promise<Fabric>;
}
export declare namespace Fabric {
    type Config = {
        fabricIndex: FabricIndex;
        fabricId: FabricId;
        nodeId: NodeId;
        rootNodeId: NodeId;
        operationalId: Uint8Array;
        rootPublicKey: Uint8Array;
        keyPair: BinaryKeyPair;
        rootVendorId: VendorId;
        rootCert: Uint8Array;
        identityProtectionKey: Uint8Array;
        operationalIdentityProtectionKey: Uint8Array;
        intermediateCACert: Uint8Array | undefined;
        operationalCert: Uint8Array;
        label: string;
    };
}
//# sourceMappingURL=Fabric.d.ts.map