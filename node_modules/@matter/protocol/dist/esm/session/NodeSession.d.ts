/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { Subject } from "#action/server/Subject.js";
import { DecodedMessage, DecodedPacket, Message, Packet, SessionType } from "#codec/MessageCodec.js";
import { Fabric } from "#fabric/Fabric.js";
import { BasicSet, Crypto, Diagnostic, MatterError } from "#general";
import type { Subscription } from "#interaction/Subscription.js";
import { PeerAddress } from "#peer/PeerAddress.js";
import { CaseAuthenticatedTag, NodeId, StatusResponseError } from "#types";
import { SecureSession } from "./SecureSession.js";
import { Session, SessionParameterOptions } from "./Session.js";
import type { SessionManager } from "./SessionManager.js";
export declare class NoChannelError extends MatterError {
}
export declare class NoAssociatedFabricError extends StatusResponseError {
    constructor(message: string);
}
export declare class NodeSession extends SecureSession {
    #private;
    readonly supportsMRP = true;
    readonly type = SessionType.Unicast;
    static create(args: {
        crypto: Crypto;
        manager?: SessionManager;
        id: number;
        fabric: Fabric | undefined;
        peerNodeId: NodeId;
        peerSessionId: number;
        sharedSecret: Uint8Array;
        salt: Uint8Array;
        isInitiator: boolean;
        isResumption: boolean;
        peerSessionParameters?: SessionParameterOptions;
        caseAuthenticatedTags?: CaseAuthenticatedTag[];
    }): Promise<NodeSession>;
    constructor(args: {
        crypto: Crypto;
        manager?: SessionManager;
        id: number;
        fabric: Fabric | undefined;
        peerNodeId: NodeId;
        peerSessionId: number;
        decryptKey: Uint8Array;
        encryptKey: Uint8Array;
        attestationKey: Uint8Array;
        sessionParameters?: SessionParameterOptions;
        caseAuthenticatedTags?: CaseAuthenticatedTag[];
        isInitiator: boolean;
    });
    parameterDiagnostics(): Record<string, unknown> & Diagnostic;
    get caseAuthenticatedTags(): CaseAuthenticatedTag[];
    get closingAfterExchangeFinished(): boolean;
    get sendCloseMessageWhenClosing(): boolean;
    get isPase(): boolean;
    get subscriptions(): BasicSet<Subscription, Subscription>;
    get isInitiator(): boolean;
    get isClosing(): boolean;
    subjectFor(_message?: Message): Subject;
    close(closeAfterExchangeFinished?: boolean): Promise<void>;
    decode({ header, applicationPayload, messageExtension }: DecodedPacket, aad: Uint8Array): DecodedMessage;
    encode(message: Message): Packet;
    get attestationChallengeKey(): Uint8Array;
    get fabric(): Fabric | undefined;
    addAssociatedFabric(fabric: Fabric): void;
    get id(): number;
    get name(): string;
    get peerSessionId(): number;
    get nodeId(): NodeId;
    get peerNodeId(): NodeId;
    get associatedFabric(): Fabric;
    clearSubscriptions(flushSubscriptions?: boolean, cancelledByPeer?: boolean): Promise<number>;
    /** Ends a session. Outstanding subscription data will be flushed before the session is destroyed. */
    end(sendClose: boolean, closeAfterExchangeFinished?: boolean): Promise<void>;
    /** Destroys a session. Outstanding subscription data will be discarded. */
    destroy(sendClose?: boolean, closeAfterExchangeFinished?: boolean): Promise<void>;
    /**
     * The peer node's address.
     */
    get peerAddress(): PeerAddress;
    /**
     * Indicates whether a peer matches a specific address.
     */
    peerIs(address: PeerAddress): boolean;
}
export declare namespace NodeSession {
    function assert(session?: Session, errorText?: string): asserts session is NodeSession;
    function is(session?: Session): session is NodeSession;
}
//# sourceMappingURL=NodeSession.d.ts.map