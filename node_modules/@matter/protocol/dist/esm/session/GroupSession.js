/**
 * @license
 * Copyright 2022-2023 Project CHIP Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { MessageCodec, SessionType } from "#codec/MessageCodec.js";
import {
  Bytes,
  CryptoDecryptError,
  ImplementationError,
  InternalError,
  Logger,
  MatterFlowError,
  UnexpectedDataError
} from "#general";
import { GroupId } from "#types";
import { SecureSession } from "./SecureSession.js";
import { Session } from "./Session.js";
const logger = Logger.get("SecureGroupSession");
class GroupSession extends SecureSession {
  #id;
  #fabric;
  #peerNodeId;
  #operationalGroupKey;
  supportsMRP = false;
  closingAfterExchangeFinished = false;
  // Group sessions do not close after exchange finished, they are long-lived
  keySetId;
  constructor(args) {
    const { manager, fabric, operationalGroupKey, id, peerNodeId, keySetId } = args;
    super({
      ...args,
      setActiveTimestamp: false,
      // We always set the active timestamp for Secure sessions TODO Check
      messageCounter: fabric.groups.messaging.counterFor(operationalGroupKey)
    });
    this.#id = id;
    this.#fabric = fabric;
    this.#peerNodeId = peerNodeId;
    this.keySetId = keySetId;
    this.#operationalGroupKey = operationalGroupKey;
    manager?.registerGroupSession(this);
    fabric.addSession(this);
    logger.debug(`Created secure GROUP session for fabric index ${fabric.fabricIndex}`, this.name);
  }
  get type() {
    return SessionType.Group;
  }
  get fabric() {
    return this.#fabric;
  }
  get id() {
    return this.#id;
  }
  get peerSessionId() {
    return this.#id;
  }
  get name() {
    return `group/${this.#id}`;
  }
  get nodeId() {
    return this.#fabric.nodeId;
  }
  get peerNodeId() {
    return this.#peerNodeId;
  }
  get associatedFabric() {
    return this.#fabric;
  }
  subjectFor(message) {
    if (message === void 0 || message.packetHeader.destGroupId === void 0) {
      throw new ImplementationError("GroupSession requires a message with destGroupId");
    }
    return this.fabric.groups.subjectForGroup(GroupId(message.packetHeader.destGroupId), this.keySetId);
  }
  notifyActivity(_messageReceived) {
  }
  updateMessageCounter(messageCounter, sourceNodeId, operationalKey) {
    if (sourceNodeId === void 0 || operationalKey === void 0) {
      throw new InternalError("Source Node ID is required for GroupSession updateMessageCounter.");
    }
    const receptionState = this.#fabric.groups.messaging.receptionStateFor(sourceNodeId, operationalKey);
    receptionState.updateMessageCounter(messageCounter);
  }
  encode(message) {
    message.packetHeader.sessionId = this.#id;
    const { header, applicationPayload } = MessageCodec.encodePayload(message);
    if (header.destGroupId === void 0) {
      throw new UnexpectedDataError("Group ID is required for GroupSession encode.");
    }
    const headerBytes = MessageCodec.encodePacketHeader(message.packetHeader);
    const securityFlags = headerBytes[3];
    const nonce = Session.generateNonce(securityFlags, header.messageId, this.#fabric.nodeId);
    return {
      header,
      applicationPayload: this.#fabric.crypto.encrypt(
        this.#operationalGroupKey,
        applicationPayload,
        nonce,
        headerBytes
      )
    };
  }
  decode() {
    throw new InternalError("GroupSession does not support decode on instance.");
  }
  static decode(fabrics, { header, applicationPayload, messageExtension }, aad) {
    if (header.hasMessageExtensions) {
      logger.info(
        `Message extensions are not supported. Ignoring ${messageExtension ? Bytes.toHex(messageExtension) : void 0}`
      );
    }
    const sourceNodeId = header.sourceNodeId;
    if (sourceNodeId === void 0) {
      throw new UnexpectedDataError("Source Node ID is required for GroupSession decode.");
    }
    const nonce = Session.generateNonce(header.securityFlags, header.messageId, sourceNodeId);
    const sessionId = header.sessionId;
    const keys = new Array();
    for (const fabric2 of fabrics) {
      const sessions = fabric2.groups.sessions.get(sessionId);
      if (sessions?.length) {
        for (const session of sessions) {
          keys.push({ ...session, fabric: fabric2 });
        }
      }
    }
    if (keys.length === 0) {
      throw new MatterFlowError("No key candidate found for group session decryption.");
    }
    let message;
    let key;
    let fabric;
    let keySetId;
    let found = false;
    for ({ key, keySetId, fabric } of keys) {
      try {
        message = MessageCodec.decodePayload({
          header,
          applicationPayload: fabric.crypto.decrypt(key, applicationPayload, nonce, aad)
        });
        found = true;
        break;
      } catch (error) {
        CryptoDecryptError.accept(error);
      }
    }
    if (!found || !message || !key || !keySetId || !fabric) {
      throw new MatterFlowError("Failed to decode group message with any key candidate.");
    }
    if (message.payloadHeader.hasSecuredExtension) {
      logger.info(
        `Secured extensions are not supported. Ignoring ${message.securityExtension ? Bytes.toHex(message.securityExtension) : void 0}`
      );
    }
    return { message, key, sessionId, sourceNodeId, keySetId, fabric };
  }
  async destroy() {
    logger.info(`End group session ${this.name}`);
    this.manager?.removeGroupSession(this);
  }
  end() {
    return this.destroy();
  }
}
((GroupSession2) => {
  function assert(session, errorText) {
    if (!is(session)) {
      throw new MatterFlowError(errorText ?? "Insecure session in secure context");
    }
  }
  GroupSession2.assert = assert;
  function is(session) {
    return session?.type === SessionType.Group;
  }
  GroupSession2.is = is;
})(GroupSession || (GroupSession = {}));
export {
  GroupSession
};
//# sourceMappingURL=GroupSession.js.map
