/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { Behavior } from "#behavior/Behavior.js";
import { Events as BaseEvents } from "#behavior/Events.js";
import { OperationalCredentialsClient } from "#behaviors/operational-credentials";
import { ImplementationError, NotImplementedError, Observable, Time } from "#general";
import { DatatypeModel, FieldElement } from "#model";
import { IdentityService } from "#node/server/IdentityService.js";
import {
  ControllerCommissioner,
  FabricAuthority,
  FabricManager
} from "#protocol";
import {
  ManualPairingCodeCodec
} from "#types";
import { ControllerBehavior } from "../controller/ControllerBehavior.js";
import { NetworkClient } from "../network/NetworkClient.js";
import { RemoteDescriptor } from "./RemoteDescriptor.js";
class CommissioningClient extends Behavior {
  static early = true;
  static id = "commissioning";
  initialize(options) {
    const descriptor = options?.descriptor;
    if (descriptor) {
      this.descriptor = descriptor;
    }
    if (this.state.discoveredAt === void 0) {
      this.state.discoveredAt = Time.nowMs();
    }
    this.reactTo(this.endpoint.lifecycle.partsReady, this.#initializeNode);
    this.reactTo(this.events.peerAddress$Changed, this.#peerAddressChanged);
  }
  async commission(options) {
    const node = this.endpoint;
    if (this.state.peerAddress !== void 0) {
      throw new ImplementationError(`${node} is already commissioned`);
    }
    if (typeof options === "number") {
      options = { passcode: options };
    } else if (typeof options === "string") {
      options = { pairingCode: options };
    }
    const opts = CommissioningClient.PasscodeOptions(options);
    let { passcode } = opts;
    if (typeof passcode !== "number" || Number.isNaN(passcode)) {
      passcode = Number.parseInt(passcode);
      if (Number.isNaN(passcode)) {
        throw new ImplementationError(`You must provide the numeric passcode to commission a node`);
      }
    }
    await node.owner?.act((agent) => agent.load(ControllerBehavior));
    const fabricAuthority = opts.fabricAuthority || this.env.get(FabricAuthority);
    let { fabric } = opts;
    if (fabric === void 0) {
      if (this.context.fabric === void 0) {
        fabric = await fabricAuthority.defaultFabric();
      } else {
        fabric = node.env.get(FabricManager).for(this.context.fabric);
      }
    }
    if (!fabricAuthority.hasControlOf(fabric)) {
      throw new ImplementationError(
        `Cannot commission ${node} fabric ${fabric.fabricIndex} because we do not control this fabric`
      );
    }
    const addresses = this.state.addresses;
    if (!addresses?.length) {
      throw new ImplementationError(`Cannot commission ${node} because the node has not been located`);
    }
    const commissioner = node.env.get(ControllerCommissioner);
    const identityService = node.env.get(IdentityService);
    const address = identityService.assignNodeAddress(node, fabric.fabricIndex, opts.nodeId);
    const commissioningOptions = {
      addresses,
      fabric,
      nodeId: address.nodeId,
      passcode,
      discoveryData: this.descriptor
    };
    if (this.finalizeCommissioning !== CommissioningClient.prototype.finalizeCommissioning) {
      commissioningOptions.finalizeCommissioning = this.finalizeCommissioning.bind(this);
    }
    try {
      await commissioner.commission(commissioningOptions);
      this.state.peerAddress = address;
    } catch (e) {
      identityService.releaseNodeAddress(address);
      throw e;
    }
    await this.context.transaction.commit();
    const network = this.agent.get(NetworkClient);
    network.state.startupSubscription = opts.startupSubscription;
    node.lifecycle.commissioned.emit(this.context);
    await node.start();
    return node;
  }
  /**
   * Remove this node from the fabric.
   *
   * After removal the {@link ClientNode} remains intact.  You can use {@link ClientNode#delete} to remove the node
   * permanently.
   *
   * Only legal if this node controls the peer's fabric.
   */
  async decommission() {
    const { peerAddress } = this.state;
    if (peerAddress === void 0) {
      throw new ImplementationError("Cannot decommission node that is not commissioned");
    }
    const opcreds = this.agent.get(OperationalCredentialsClient);
    await opcreds.removeFabric({ fabricIndex: opcreds.state.currentFabricIndex });
    this.state.peerAddress = void 0;
  }
  /**
   * Override to implement CASE commissioning yourself.
   *
   * If you override, matter.js commissions to the point where commissioning over PASE is complete.  You must then
   * complete commissioning yourself by connecting to the device and invokeint the "CommissioningComplete" command.
   */
  async finalizeCommissioning(_address, _discoveryData) {
    throw new NotImplementedError();
  }
  get descriptor() {
    return RemoteDescriptor.fromLongForm(this.state);
  }
  set descriptor(descriptor) {
    RemoteDescriptor.toLongForm(descriptor, this.state);
  }
  #initializeNode() {
    const endpoint = this.endpoint;
    endpoint.lifecycle.initialized.emit(this.state.peerAddress !== void 0);
  }
  #peerAddressChanged(addr) {
    const node = this.endpoint;
    if (addr) {
      node.lifecycle.commissioned.emit(this.context);
    } else {
      node.lifecycle.decommissioned.emit(this.context);
    }
  }
  /**
   * Define logical schema.  This enables runtime validation, make fields persistent and makes subfields editable.
   */
  static schema = new DatatypeModel({
    name: "CommissioningState",
    type: "struct",
    children: [
      FieldElement({
        name: "peerAddress",
        type: "struct",
        quality: "N",
        children: [
          FieldElement({ name: "fabricIndex", type: "fabric-id" }),
          FieldElement({ name: "nodeId", type: "node-id" })
        ]
      }),
      FieldElement({
        name: "addresses",
        type: "list",
        quality: "N",
        children: [
          FieldElement({
            name: "entry",
            type: "struct",
            children: [
              FieldElement({ name: "type", type: "string" }),
              FieldElement({ name: "ip", type: "string" }),
              FieldElement({ name: "port", type: "uint16" }),
              FieldElement({ name: "peripheralAddress", type: "string" })
            ]
          })
        ]
      }),
      FieldElement({ name: "discoveredAt", type: "systime-ms", quality: "N", conformance: "M" }),
      FieldElement({ name: "onlineAt", type: "systime-ms" }),
      FieldElement({ name: "offlineAt", type: "systime-ms" }),
      FieldElement({ name: "ttl", type: "uint32", quality: "N" }),
      FieldElement({ name: "deviceIdentifier", type: "string", quality: "N" }),
      FieldElement({ name: "discriminator", type: "uint16", quality: "N" }),
      FieldElement({ name: "commissioningMode", type: "uint8", quality: "N" }),
      FieldElement({ name: "vendorId", type: "vendor-id", quality: "N" }),
      FieldElement({ name: "productId", type: "uint16", quality: "N" }),
      FieldElement({ name: "deviceType", type: "uint16", quality: "N" }),
      FieldElement({ name: "deviceName", type: "string", quality: "N" }),
      FieldElement({ name: "rotatingIdentifier", type: "string", quality: "N" }),
      FieldElement({ name: "pairingHint", type: "uint32", quality: "N" }),
      FieldElement({ name: "pairingInstructions", type: "string", quality: "N" }),
      FieldElement({
        name: "sessionParameters",
        type: "struct",
        quality: "N",
        children: [
          FieldElement({ name: "idleIntervalMs", type: "uint32", constraint: "max 3600000" }),
          FieldElement({ name: "activeIntervalMs", type: "uint32", constraint: "max 3600000" }),
          FieldElement({ name: "activeThresholdMs", type: "uint16" })
        ]
      }),
      FieldElement({ name: "tcpSupport", type: "uint8", quality: "N" }),
      FieldElement({ name: "longIdleOperatingMode", type: "bool", quality: "N" })
    ]
  });
}
((CommissioningClient2) => {
  class State {
    /**
     * Fabric index and node ID for paired peers.  If this is undefined the node is uncommissioned.
     */
    peerAddress;
    /**
     * Known network addresses for the device.  If this is undefined the node has not been located on any network
     * interface.
     */
    addresses;
    /**
     * Time at which the device was discovered.
     */
    discoveredAt;
    /**
     * Time at which we discovered the device's current operational addresses.
     */
    onlineAt;
    /**
     * Time at which we concluded the device's current operational address is unreachable.
     */
    offlineAt;
    /**
     * The TTL of the discovery record if applicable.
     */
    ttl;
    /**
     * The canonical global ID of the device.
     */
    deviceIdentifier;
    /**
     * The device's long discriminator.
     */
    discriminator;
    /**
     * The last know commissioning mode of the device.
     */
    commissioningMode;
    /**
     * Vendor.
     */
    vendorId;
    /**
     * Product.
     */
    productId;
    /**
     * Advertised device type.
     */
    deviceType;
    /**
     * The advertised device name specified by the user.
     */
    deviceName;
    /**
     * An optional manufacturer-specific unique rotating ID for uniquely identifying the device.
     */
    rotatingIdentifier;
    /**
     * A bitmap indicating how to transition the device to commissioning mode from its current state.
     */
    pairingHint;
    /**
     * Textual pairing instructions associated with pairing hint.
     */
    pairingInstructions;
    /**
     * The remote node's session parameters.
     */
    sessionParameters;
    /**
     * TCP support bitmap.
     */
    tcpSupport;
    /**
     * Indicates whether node is ICD with a slow (15 s+) polling interval.
     */
    longIdleTimeOperatingMode;
  }
  CommissioningClient2.State = State;
  class Events extends BaseEvents {
    peerAddress$Changed = new Observable();
  }
  CommissioningClient2.Events = Events;
  function PasscodeOptions(options) {
    let opts;
    if ("pairingCode" in options) {
      const decoded = ManualPairingCodeCodec.decode(options.pairingCode);
      opts = {
        ...options,
        ...decoded
      };
    } else {
      opts = options;
    }
    let { passcode } = opts;
    if (typeof passcode !== "number" || Number.isNaN(passcode)) {
      passcode = Number.parseInt(passcode);
      if (Number.isNaN(passcode)) {
        throw new ImplementationError("You must provide a pairing code or passcode to pair a node");
      }
    }
    return opts;
  }
  CommissioningClient2.PasscodeOptions = PasscodeOptions;
})(CommissioningClient || (CommissioningClient = {}));
export {
  CommissioningClient
};
//# sourceMappingURL=CommissioningClient.js.map
