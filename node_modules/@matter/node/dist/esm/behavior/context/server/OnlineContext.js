/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { AsyncObservable, Diagnostic, ImplementationError, InternalError, Transaction } from "#general";
import {
  AccessControl,
  FabricAccessControl,
  SecureSession,
  Subject
} from "#protocol";
import { Contextual } from "../Contextual.js";
import { ContextAgents } from "./ContextAgents.js";
const exchangeCompleteEvents = /* @__PURE__ */ new WeakMap();
function OnlineContext(options) {
  let fabric;
  let subject;
  let nodeProtocol;
  let accessLevelCache;
  let aclManager;
  const { exchange, message } = options;
  const session = exchange?.session;
  if (session) {
    SecureSession.assert(session);
    fabric = session.fabric?.fabricIndex;
    subject = session.subjectFor(message);
    aclManager = session?.fabric?.acl ?? new FabricAccessControl();
  } else {
    fabric = options.fabric;
    if (options.subject !== void 0) {
      subject = Subject.Node({ id: options.subject });
    } else {
      throw new ImplementationError("OnlineContext requires an authorized subject");
    }
    aclManager = options.aclManager ?? new FabricAccessControl();
  }
  const via = Diagnostic.via(
    `online#${message?.packetHeader?.messageId?.toString(16) ?? "?"}@${subject.id.toString(16)}`
  );
  return {
    /**
     * Run an actor with a read/write context.
     *
     * If the actor changes state, this may return a promise even if {@link actor} does not return a promise.
     */
    act(actor) {
      const context = this.open();
      let result;
      try {
        result = actor(context);
      } catch (e) {
        return context.reject(e);
      }
      return context.resolve(result);
    },
    /**
     * Create an online context.
     *
     * This context operates with a {@link Transaction} created via {@link Transaction.open} and the same rules
     * apply for lifecycle management using {@link Transaction.Finalization}.
     */
    open() {
      let close;
      let tx;
      try {
        close = initialize();
        tx = Transaction.open(via);
        tx.onClose(close);
      } catch (e) {
        close?.();
        throw e;
      }
      return createContext(tx, {
        resolve: tx.resolve.bind(tx),
        reject: tx.reject.bind(tx)
      });
    },
    /**
     * Begin an operation with a read-only context.
     *
     * A read-only context offers simpler lifecycle semantics than a r/w OnlineContext but you must still close the
     * context after use to properly deregister activity.
     */
    beginReadOnly() {
      const close = initialize();
      return createContext(Transaction.open(via, "snapshot"), {
        [Symbol.dispose]: close
      });
    },
    [Symbol.toStringTag]: "OnlineContext"
  };
  function initialize() {
    const activity = options.activity?.frame(via);
    const close = () => {
      if (message) {
        Contextual.setContextOf(message, void 0);
      }
      if (activity) {
        activity[Symbol.dispose]();
      }
    };
    return close;
  }
  function createContext(transaction, methods) {
    if (session) {
      SecureSession.assert(session);
    }
    let agents;
    let interactionComplete;
    if (exchange !== void 0) {
      interactionComplete = exchangeCompleteEvents.get(exchange);
      if (interactionComplete === void 0) {
        interactionComplete = new AsyncObservable();
        exchangeCompleteEvents.set(exchange, interactionComplete);
      }
      const notifyInteractionComplete = () => {
        exchange.closing.off(notifyInteractionComplete);
        exchangeCompleteEvents.delete(exchange);
        if (context.interactionComplete?.isObserved) {
          context.interactionComplete.emit(context);
        }
      };
      exchange.closing.on(notifyInteractionComplete);
    }
    const context = {
      ...options,
      session,
      exchange,
      subject,
      fabric,
      transaction,
      interactionComplete,
      ...methods,
      // TODO - Matter 1.4 - add support for ARLs
      authorityAt(desiredAccessLevel, location) {
        if (location === void 0) {
          throw new InternalError("AccessControl.Location is required");
        }
        const cachedAccessLevels = accessLevelCache?.get(location);
        if (cachedAccessLevels !== void 0) {
          return cachedAccessLevels.includes(desiredAccessLevel) ? AccessControl.Authority.Granted : AccessControl.Authority.Unauthorized;
        }
        if (options.node === void 0) {
          throw new InternalError("OnlineContext initialized without node");
        }
        const accessLevels = aclManager.accessLevelsFor(context, location, aclEndpointContextFor(location));
        if (accessLevelCache === void 0) {
          accessLevelCache = /* @__PURE__ */ new Map();
        }
        accessLevelCache.set(location, accessLevels);
        return accessLevels.includes(desiredAccessLevel) ? AccessControl.Authority.Granted : AccessControl.Authority.Unauthorized;
      },
      agentFor(endpoint) {
        if (!agents) {
          agents = ContextAgents(context);
        }
        return agents.agentFor(endpoint);
      },
      get [Contextual.context]() {
        return this;
      }
    };
    if (message) {
      Contextual.setContextOf(message, context);
    }
    return context;
  }
  function aclEndpointContextFor({ endpoint: number }) {
    if (number === void 0) {
      throw new InternalError("Online location missing required endpoint number");
    }
    if (options.node === void 0) {
      throw new InternalError("Online context has no node defined");
    }
    if (nodeProtocol === void 0) {
      nodeProtocol = options.node.protocol;
    }
    const endpoint = nodeProtocol[number];
    if (endpoint !== void 0) {
      return endpoint;
    }
    return {
      id: number,
      deviceTypes: []
    };
  }
}
export {
  OnlineContext
};
//# sourceMappingURL=OnlineContext.js.map
