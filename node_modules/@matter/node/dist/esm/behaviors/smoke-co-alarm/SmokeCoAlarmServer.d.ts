/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { SmokeCoAlarm } from "#clusters/smoke-co-alarm";
import { ClusterType } from "#types";
declare const SmokeCoAlarmBase: import("../../index.js").ClusterBehavior.Type<import("#types").ClusterComposer.WithFeatures<ClusterType.Of<{
    readonly id: 92;
    readonly name: "SmokeCoAlarm";
    readonly revision: 1;
    readonly features: {
        readonly smokeAlarm: import("#types").BitFlag;
        readonly coAlarm: import("#types").BitFlag;
    };
    readonly attributes: {
        readonly expressedState: import("#types").Attribute<SmokeCoAlarm.ExpressedState, any>;
        readonly batteryAlert: import("#types").Attribute<SmokeCoAlarm.AlarmState, any>;
        readonly deviceMuted: import("#types").OptionalAttribute<SmokeCoAlarm.MuteState, any>;
        readonly testInProgress: import("#types").Attribute<boolean, any>;
        readonly hardwareFaultAlert: import("#types").Attribute<boolean, any>;
        readonly endOfServiceAlert: import("#types").Attribute<SmokeCoAlarm.EndOfService, any>;
        readonly interconnectSmokeAlarm: import("#types").OptionalAttribute<SmokeCoAlarm.AlarmState, any>;
        readonly interconnectCoAlarm: import("#types").OptionalAttribute<SmokeCoAlarm.AlarmState, any>;
        readonly expiryDate: import("#types").OptionalFixedAttribute<number, any>;
    };
    readonly commands: {
        readonly selfTestRequest: import("#types").OptionalCommand<void, void, any>;
    };
    readonly events: {
        readonly lowBattery: import("#types").Event<import("#types").TypeFromFields<{
            alarmSeverityLevel: import("#types").FieldType<SmokeCoAlarm.AlarmState>;
        }>, any>;
        readonly hardwareFault: import("#types").Event<void, any>;
        readonly endOfService: import("#types").Event<void, any>;
        readonly selfTestComplete: import("#types").Event<void, any>;
        readonly alarmMuted: import("#types").OptionalEvent<void, any>;
        readonly muteEnded: import("#types").OptionalEvent<void, any>;
        readonly allClear: import("#types").Event<void, any>;
    };
    readonly extensions: readonly [{
        readonly flags: {
            readonly smokeAlarm: true;
        };
        readonly component: {
            readonly attributes: {
                readonly smokeState: import("#types").Attribute<SmokeCoAlarm.AlarmState, any>;
                readonly contaminationState: import("#types").OptionalAttribute<SmokeCoAlarm.ContaminationState, any>;
                readonly smokeSensitivityLevel: import("#types").OptionalWritableAttribute<SmokeCoAlarm.Sensitivity, any>;
            };
            readonly events: {
                readonly smokeAlarm: import("#types").Event<import("#types").TypeFromFields<{
                    alarmSeverityLevel: import("#types").FieldType<SmokeCoAlarm.AlarmState>;
                }>, any>;
                readonly interconnectSmokeAlarm: import("#types").OptionalEvent<import("#types").TypeFromFields<{
                    alarmSeverityLevel: import("#types").FieldType<SmokeCoAlarm.AlarmState>;
                }>, any>;
            };
        };
    }, {
        readonly flags: {
            readonly coAlarm: true;
        };
        readonly component: {
            readonly attributes: {
                readonly coState: import("#types").Attribute<SmokeCoAlarm.AlarmState, any>;
            };
            readonly events: {
                readonly coAlarm: import("#types").Event<import("#types").TypeFromFields<{
                    alarmSeverityLevel: import("#types").FieldType<SmokeCoAlarm.AlarmState>;
                }>, any>;
                readonly interconnectCoAlarm: import("#types").OptionalEvent<import("#types").TypeFromFields<{
                    alarmSeverityLevel: import("#types").FieldType<SmokeCoAlarm.AlarmState>;
                }>, any>;
            };
        };
    }, {
        readonly flags: {
            readonly smokeAlarm: false;
            readonly coAlarm: false;
        };
        readonly component: false;
    }];
}>, readonly [SmokeCoAlarm.Feature.SmokeAlarm, SmokeCoAlarm.Feature.CoAlarm]>, import("./SmokeCoAlarmBehavior.js").SmokeCoAlarmBehaviorConstructor, import("./SmokeCoAlarmInterface.js").SmokeCoAlarmInterface>;
/**
 * This is the default server implementation of {@link SmokeCoAlarmBehavior}.
 *
 * The Matter specification requires the SmokeCoAlarm cluster to support features we do not enable by default. You
 * should use {@link SmokeCoAlarmServer.with} to specialize the class for the features your implementation supports.
 */
export declare class SmokeCoAlarmBaseServer extends SmokeCoAlarmBase {
    initialize(): void;
}
declare const SmokeCoAlarmServer_base: import("../../index.js").ClusterBehavior.Type<ClusterType.Of<{
    readonly id: 92;
    readonly name: "SmokeCoAlarm";
    readonly revision: 1;
    readonly features: {
        readonly smokeAlarm: import("#types").BitFlag;
        readonly coAlarm: import("#types").BitFlag;
    };
    readonly attributes: {
        readonly expressedState: import("#types").Attribute<SmokeCoAlarm.ExpressedState, any>;
        readonly batteryAlert: import("#types").Attribute<SmokeCoAlarm.AlarmState, any>;
        readonly deviceMuted: import("#types").OptionalAttribute<SmokeCoAlarm.MuteState, any>;
        readonly testInProgress: import("#types").Attribute<boolean, any>;
        readonly hardwareFaultAlert: import("#types").Attribute<boolean, any>;
        readonly endOfServiceAlert: import("#types").Attribute<SmokeCoAlarm.EndOfService, any>;
        readonly interconnectSmokeAlarm: import("#types").OptionalAttribute<SmokeCoAlarm.AlarmState, any>;
        readonly interconnectCoAlarm: import("#types").OptionalAttribute<SmokeCoAlarm.AlarmState, any>;
        readonly expiryDate: import("#types").OptionalFixedAttribute<number, any>;
    };
    readonly commands: {
        readonly selfTestRequest: import("#types").OptionalCommand<void, void, any>;
    };
    readonly events: {
        readonly lowBattery: import("#types").Event<import("#types").TypeFromFields<{
            alarmSeverityLevel: import("#types").FieldType<SmokeCoAlarm.AlarmState>;
        }>, any>;
        readonly hardwareFault: import("#types").Event<void, any>;
        readonly endOfService: import("#types").Event<void, any>;
        readonly selfTestComplete: import("#types").Event<void, any>;
        readonly alarmMuted: import("#types").OptionalEvent<void, any>;
        readonly muteEnded: import("#types").OptionalEvent<void, any>;
        readonly allClear: import("#types").Event<void, any>;
    };
    readonly extensions: readonly [{
        readonly flags: {
            readonly smokeAlarm: true;
        };
        readonly component: {
            readonly attributes: {
                readonly smokeState: import("#types").Attribute<SmokeCoAlarm.AlarmState, any>;
                readonly contaminationState: import("#types").OptionalAttribute<SmokeCoAlarm.ContaminationState, any>;
                readonly smokeSensitivityLevel: import("#types").OptionalWritableAttribute<SmokeCoAlarm.Sensitivity, any>;
            };
            readonly events: {
                readonly smokeAlarm: import("#types").Event<import("#types").TypeFromFields<{
                    alarmSeverityLevel: import("#types").FieldType<SmokeCoAlarm.AlarmState>;
                }>, any>;
                readonly interconnectSmokeAlarm: import("#types").OptionalEvent<import("#types").TypeFromFields<{
                    alarmSeverityLevel: import("#types").FieldType<SmokeCoAlarm.AlarmState>;
                }>, any>;
            };
        };
    }, {
        readonly flags: {
            readonly coAlarm: true;
        };
        readonly component: {
            readonly attributes: {
                readonly coState: import("#types").Attribute<SmokeCoAlarm.AlarmState, any>;
            };
            readonly events: {
                readonly coAlarm: import("#types").Event<import("#types").TypeFromFields<{
                    alarmSeverityLevel: import("#types").FieldType<SmokeCoAlarm.AlarmState>;
                }>, any>;
                readonly interconnectCoAlarm: import("#types").OptionalEvent<import("#types").TypeFromFields<{
                    alarmSeverityLevel: import("#types").FieldType<SmokeCoAlarm.AlarmState>;
                }>, any>;
            };
        };
    }, {
        readonly flags: {
            readonly smokeAlarm: false;
            readonly coAlarm: false;
        };
        readonly component: false;
    }];
}>, typeof SmokeCoAlarmBaseServer, import("./SmokeCoAlarmInterface.js").SmokeCoAlarmInterface>;
export declare class SmokeCoAlarmServer extends SmokeCoAlarmServer_base {
}
export {};
//# sourceMappingURL=SmokeCoAlarmServer.d.ts.map