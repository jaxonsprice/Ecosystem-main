/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { ClusterBehavior } from "#behavior/cluster/ClusterBehavior.js";
import { camelize, capitalize, InternalError } from "#general";
import { AttributeModel, ClusterModel, CommandModel, Matter } from "#model";
import { Node } from "#node/Node.js";
import { Invoke } from "#protocol";
import {
  Attribute,
  ClusterComposer,
  ClusterRegistry,
  Command,
  MutableCluster,
  Status,
  StatusResponseError,
  TlvAny,
  TlvNoResponse
} from "#types";
const BIT_BLOCK_SIZE = Math.log2(Number.MAX_SAFE_INTEGER);
const cache = {};
function ClientBehavior(shape) {
  const analysis = ShapeAnalysis(shape);
  const fingerprint = createFingerprint(analysis);
  let type = cache[fingerprint];
  if (type) {
    return type;
  }
  let baseType;
  const standardCluster = ClusterRegistry.get(shape.id);
  if (standardCluster) {
    baseType = ClusterBehavior.for(standardCluster);
  } else {
    baseType = ClusterBehavior;
  }
  type = cache[fingerprint] = generateType(analysis, baseType);
  return type;
}
function generateType(analysis, baseType) {
  if (!ClusterBehavior.is(baseType)) {
    throw new InternalError(`Base Behavior for cluster ${analysis.schema.name} is not a ClusterBehavior`);
  }
  let { schema } = analysis;
  const { extraAttrs, extraCommands } = analysis;
  let { cluster } = baseType;
  if (!cluster) {
    cluster = MutableCluster({ id: schema.id, name: schema.name, revision: schema.revision });
  }
  let supportedFeatures = analysis.shape.features;
  if (typeof supportedFeatures === "number") {
    if (supportedFeatures) {
      supportedFeatures = cluster.attributes.featureMap.schema.decode(supportedFeatures);
    } else {
      supportedFeatures = {};
    }
  }
  const featureNames = Object.entries(supportedFeatures).filter(([, v]) => v).map(([k]) => k);
  if (featureNames.length) {
    schema = schema.clone();
    schema.supportedFeatures = featureNames;
    cluster = new ClusterComposer(cluster, true).compose(featureNames.map(capitalize));
  }
  if (schema.revision !== analysis.shape.revision || extraAttrs.size || extraCommands.size) {
    schema = schema.clone();
    cluster = {
      ...cluster,
      supportedFeatures,
      attributes: { ...cluster.attributes },
      commands: { ...cluster.commands }
    };
    schema.supportedFeatures = supportedFeatures;
    for (const id of extraAttrs) {
      const name = createUnknownName("attr", id);
      cluster.attributes[camelize(name, false)] = Attribute(id, TlvAny);
      schema.children.push(new AttributeModel({ id, name, type: "any" }));
    }
    for (const id of extraCommands) {
      const name = createUnknownName("command", id);
      cluster.commands[camelize(name, false)] = Command(id, TlvAny, 0, TlvNoResponse);
      schema.children.push(new CommandModel({ id, name, type: "any" }));
    }
  }
  const type = baseType.for(cluster, schema, `${schema.name}Client`);
  for (const id of analysis.shape.commands) {
    const name = schema.get(CommandModel, id)?.name ?? createUnknownName("command", id);
    const command = cluster.commands[camelize(name)];
    type.prototype[camelize(name, false)] = implementCommand(command);
  }
  return type;
  function implementCommand(command) {
    return async function(fields) {
      const node = this.env.get(Node);
      const chunks = node.interaction.invoke(
        Invoke(
          Invoke.Command({
            endpoint: this.endpoint,
            cluster,
            command,
            fields
          })
        )
      );
      for await (const chunk of chunks) {
        for (const entry of chunk) {
          switch (entry.kind) {
            case "cmd-status":
              if (entry.status !== Status.Success) {
                throw StatusResponseError.create(entry.status, void 0, entry.clusterStatus);
              }
              break;
            case "cmd-response":
              return command.responseSchema.decodeTlv(entry.data);
          }
        }
      }
    };
  }
}
function createFingerprint(analysis) {
  const fingerprint = [analysis.shape.id];
  if (analysis.extraAttrs.size) {
    fingerprint.push("a", createElementFingerprint(analysis.extraAttrs));
  }
  if (analysis.extraCommands.size) {
    fingerprint.push("c", createElementFingerprint(analysis.extraCommands));
  }
  return fingerprint.join(";");
  function createElementFingerprint(ids) {
    const blocks = {};
    for (const id of ids) {
      const block = Math.floor(id / BIT_BLOCK_SIZE);
      blocks[block] = (blocks[block] ?? 0) | 1 << id % BIT_BLOCK_SIZE;
    }
    return Object.entries(blocks).sort(([a], [b]) => a.localeCompare(b)).map(([block, map]) => block ? `${block}:${map}` : map).join(",");
  }
}
function createUnknownName(prefix, id) {
  return `${prefix}$${id.toString(16)}`;
}
function ShapeAnalysis(shape) {
  const schema = Matter.get(ClusterModel, shape.id) ?? new ClusterModel({ id: shape.id, name: createUnknownName("Cluster", shape.id), revision: shape.revision });
  const extraAttrs = new Set(shape.attributes);
  for (const attr of schema.attributes) {
    extraAttrs.delete(attr.id);
  }
  const extraCommands = new Set(shape.commands);
  for (const command of schema.commands) {
    extraCommands.delete(command.id);
  }
  return {
    schema,
    shape,
    extraAttrs,
    extraCommands
  };
}
export {
  ClientBehavior
};
//# sourceMappingURL=ClientBehavior.js.map
