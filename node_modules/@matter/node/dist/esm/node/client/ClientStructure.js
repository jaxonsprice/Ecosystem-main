/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { Datasource } from "#behavior/state/managed/Datasource.js";
import { DescriptorCluster } from "#clusters/descriptor";
import { Endpoint } from "#endpoint/Endpoint.js";
import { EndpointType } from "#endpoint/type/EndpointType.js";
import { AcceptedCommandList, AttributeList, ClusterRevision, FeatureMap } from "#model";
import { ReadScope } from "#protocol";
import { DatasourceCache } from "#storage/client/DatasourceCache.js";
import { ClientNodeStore } from "#storage/index.js";
import { ClientBehavior } from "./ClientBehavior.js";
const DEVICE_TYPE_LIST_ATTR_ID = DescriptorCluster.attributes.deviceTypeList.id;
const SERVER_LIST_ATTR_ID = DescriptorCluster.attributes.serverList.id;
const PARTS_LIST_ATTR_ID = DescriptorCluster.attributes.partsList.id;
class ClientStructure {
  #nodeStore;
  #endpoints = {};
  constructor(node) {
    this.#nodeStore = node.env.get(ClientNodeStore);
    this.#endpoints[node.number] = {
      endpoint: node,
      clusters: {}
    };
  }
  /**
   * Load initial structure from cache.
   */
  loadCache() {
    for (const store of this.#nodeStore.endpointStores) {
      const id = store.id;
      const number = Number.parseInt(id);
      if (Number.isNaN(number)) {
        continue;
      }
      const endpoint = this.#endpointFor(number);
      for (const idStr of store.knownBehaviors) {
        const id2 = Number.parseInt(idStr);
        if (Number.isNaN(id2)) {
          continue;
        }
        const cluster = this.#clusterFor(endpoint, id2);
        this.#initializeCluster(endpoint, cluster);
      }
    }
  }
  /**
   * Obtain the store for a remote cluster.
   */
  storeForRemote(endpoint, type) {
    const endpointStructure = this.#endpointFor(endpoint.number);
    const clusterStructure = this.#clusterFor(endpointStructure, type.cluster.id);
    return clusterStructure.store;
  }
  /**
   *
   * @param request
   * @returns
   */
  storeForLocal(endpoint, type) {
    return this.#nodeStore.storeForEndpoint(endpoint).createStoreForLocalBehavior(type.id);
  }
  /**
   * Inject version filters into a Read or Subscribe request.
   */
  injectVersionFilters(request) {
    const scope = ReadScope(request);
    let result = request;
    for (const {
      endpoint: { number: endpointId },
      clusters
    } of Object.values(this.#endpoints)) {
      for (const {
        id: clusterId,
        store: { version }
      } of Object.values(clusters)) {
        if (!scope.isRelevant(endpointId, clusterId)) {
          continue;
        }
        if (version === Datasource.UNKNOWN_VERSION) {
          continue;
        }
        if (result === request) {
          result = { ...request };
        }
        if (result.dataVersionFilters === void 0) {
          result.dataVersionFilters = [];
        }
        result.dataVersionFilters.push({ path: { endpointId, clusterId }, dataVersion: version });
      }
    }
    return result;
  }
  /**
   * Update the node structure by applying attribute changes.
   */
  async *mutate(request, changes) {
    const scope = ReadScope(request);
    let currentUpdates;
    for await (const chunk of changes) {
      for (const change of chunk) {
        if (change.kind !== "attr-value") {
          continue;
        }
        const { endpointId, clusterId, attributeId } = change.path;
        if (currentUpdates && (currentUpdates.endpointId !== endpointId || currentUpdates.clusterId !== clusterId)) {
          await this.#updateCluster(currentUpdates);
          currentUpdates = void 0;
        }
        if (currentUpdates === void 0) {
          currentUpdates = {
            endpointId,
            clusterId,
            values: {
              [attributeId]: change.value
            }
          };
          if (scope.isWildcard(endpointId, clusterId)) {
            currentUpdates.values[DatasourceCache.VERSION_KEY] = change.version;
          }
        } else {
          currentUpdates.values[attributeId] = change.value;
        }
      }
      yield chunk;
    }
    if (currentUpdates) {
      await this.#updateCluster(currentUpdates);
    }
  }
  /**
   * Obtain the {@link ClusterType} for an endpoint number and cluster ID.
   */
  clusterFor(endpoint, cluster) {
    const ep = this.#endpointFor(endpoint);
    if (!ep) {
      return;
    }
    return this.#clusterFor(ep, cluster)?.behavior?.cluster;
  }
  /**
   * Apply new attribute values for specific endpoint/cluster.
   *
   * This is invoked in a batch when we've collected all sequential values for the current endpoint/cluster.
   */
  async #updateCluster(attrs) {
    const endpoint = this.#endpointFor(attrs.endpointId);
    const cluster = this.#clusterFor(endpoint, attrs.clusterId);
    await cluster.store.externalSet(attrs.values);
    this.#initializeCluster(endpoint, cluster);
  }
  /**
   * If enough attributes are present, installs a behavior on an endpoint
   *
   * If the cluster is Descriptor, performs additional {@link Endpoint} configuration such as installing parts and
   * device types.
   *
   * Invoked once we've loaded all attributes in an interaction.
   */
  #initializeCluster(endpoint, cluster) {
    const attrs = cluster.store.initialValues ?? {};
    if (cluster.behavior === void 0) {
      const {
        [ClusterRevision.id]: clusterRevision,
        [FeatureMap.id]: features,
        [AttributeList.id]: attributeList,
        [AcceptedCommandList.id]: commandList
      } = attrs;
      if (typeof clusterRevision === "number") {
        cluster.revision = clusterRevision;
      }
      if (typeof features === "object" && features !== null && !Array.isArray(features)) {
        cluster.features = features;
      }
      if (Array.isArray(attributeList)) {
        cluster.attributes = attributeList.filter((attr) => typeof attr === "number");
      }
      if (Array.isArray(commandList)) {
        cluster.commands = commandList.filter((cmd) => typeof cmd === "number");
      }
      if (cluster.revision !== void 0 && cluster.features !== void 0 && cluster.attributes !== void 0 && cluster.commands !== void 0) {
        cluster.behavior = ClientBehavior(cluster);
        endpoint.endpoint.behaviors.require(cluster.behavior);
      }
    }
    if (cluster.id === DescriptorCluster.id) {
      this.#synchronizeDescriptor(endpoint, attrs);
    }
  }
  #synchronizeDescriptor(endpoint, attrs) {
    const deviceTypeList = attrs[DEVICE_TYPE_LIST_ATTR_ID];
    if (Array.isArray(deviceTypeList) && deviceTypeList?.[0]) {
      const [{ deviceType, revision }] = deviceTypeList;
      if (typeof deviceType === "number") {
        endpoint.endpoint.type.deviceType = deviceType;
      }
      if (typeof revision === "number") {
        endpoint.endpoint.type.deviceRevision = revision;
      }
    }
    const serverList = attrs[SERVER_LIST_ATTR_ID];
    if (Array.isArray(serverList)) {
      for (const cluster of serverList) {
        if (typeof cluster === "number") {
          this.#clusterFor(endpoint, cluster);
        }
      }
    }
    const partsList = attrs[PARTS_LIST_ATTR_ID];
    if (Array.isArray(partsList)) {
      for (const partNo of partsList) {
        if (typeof partNo !== "number") {
          continue;
        }
        const part = this.#endpointFor(partNo);
        let isAlreadyDescendant = false;
        for (let owner = part.endpoint.owner; owner; owner = owner.owner) {
          if (owner === endpoint.endpoint) {
            isAlreadyDescendant = true;
            break;
          }
        }
        if (isAlreadyDescendant) {
          continue;
        }
        part.endpoint.owner = endpoint.endpoint;
      }
    }
  }
  #endpointFor(number) {
    let endpoint = this.#endpoints[number];
    if (endpoint) {
      return endpoint;
    }
    endpoint = {
      endpoint: new Endpoint({
        id: `ep${number}`,
        number,
        type: EndpointType({
          name: "ClientEndpoint",
          deviceType: -1,
          deviceRevision: -1
        })
      }),
      clusters: {}
    };
    this.#endpoints[number] = endpoint;
    return endpoint;
  }
  #clusterFor(endpoint, id) {
    let cluster = endpoint.clusters[id];
    if (cluster) {
      return cluster;
    }
    cluster = {
      id,
      store: this.#nodeStore.storeForEndpoint(endpoint.endpoint).createStoreForBehavior(id.toString())
    };
    endpoint.clusters[id] = cluster;
    return cluster;
  }
}
export {
  ClientStructure
};
//# sourceMappingURL=ClientStructure.js.map
