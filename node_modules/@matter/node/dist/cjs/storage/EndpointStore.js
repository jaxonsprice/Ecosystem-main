"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var EndpointStore_exports = {};
__export(EndpointStore_exports, {
  EndpointStore: () => EndpointStore
});
module.exports = __toCommonJS(EndpointStore_exports);
/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
class EndpointStore {
  initialValues = /* @__PURE__ */ new Map();
  #storage;
  #knownBehaviors = /* @__PURE__ */ new Set();
  constructor(storage) {
    this.#storage = storage;
  }
  /**
   * Retrieve the primary key used to identify this store.
   */
  get id() {
    return this.storage.thisContexts[this.storage.thisContexts.length - 1];
  }
  /**
   * Extract initial values for a behavior.  Derivatives invoke this when instantiating a store.  The values are then
   * owned by the store.
   */
  consumeInitialValues(behaviorId) {
    const initialValues = this.initialValues.get(behaviorId);
    if (initialValues !== void 0) {
      this.initialValues.delete(behaviorId);
    }
    return initialValues;
  }
  /**
   * Patch values.  Keyed by {@link Behavior.id} then property name.
   *
   * See {@link Datasource.Store.set} for the patch semantics the individual structs use.
   */
  async set(values) {
    for (const behaviorId in values) {
      const behaviorValues = values[behaviorId];
      const behaviorStorage = this.storage.createContext(behaviorId);
      if (behaviorValues === void 0) {
        if (this.knownBehaviors.has(behaviorId)) {
          await behaviorStorage.clearAll();
          this.knownBehaviors.delete(behaviorId);
        }
        continue;
      }
      if (!this.knownBehaviors.has(behaviorId)) {
        this.knownBehaviors.add(behaviorId);
      }
      const toSave = {};
      let keysToSave = 0;
      for (const key in behaviorValues) {
        const value = behaviorValues[key];
        if (value === void 0) {
          await behaviorStorage.delete(key);
        } else {
          toSave[key] = value;
          keysToSave++;
        }
      }
      if (keysToSave > 0) {
        await behaviorStorage.set(toSave);
      }
    }
  }
  /**
   * Description used in diagnostic messages.
   */
  toString() {
    return `storage:${this.#storage.thisContexts.join(".")}`;
  }
  /**
   * IDs for behaviors persisted in this store.
   */
  get knownBehaviors() {
    return this.#knownBehaviors;
  }
  /**
   * Load the store with persisted values.
   */
  async load() {
    this.#knownBehaviors = new Set(await this.storage.contexts());
    for (const behaviorId of this.#knownBehaviors) {
      const behaviorValues = {};
      this.initialValues.set(behaviorId, behaviorValues);
      const behaviorStorage = this.storage.createContext(behaviorId);
      const storedValues = await behaviorStorage.values();
      for (const [key, value] of Object.entries(storedValues)) {
        if (value !== void 0) {
          behaviorValues[key] = value;
        }
      }
    }
  }
  /**
   * Remove all persisted information for the {@link Endpoint}
   */
  erase() {
    return this.storage.clearAll();
  }
  get storage() {
    return this.#storage;
  }
}
//# sourceMappingURL=EndpointStore.js.map
