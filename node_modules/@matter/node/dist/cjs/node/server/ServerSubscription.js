"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var ServerSubscription_exports = {};
__export(ServerSubscription_exports, {
  DEFAULT_RANDOMIZATION_WINDOW_S: () => DEFAULT_RANDOMIZATION_WINDOW_S,
  INTERNAL_INTERVAL_PUBLISHER_LIMIT_S: () => INTERNAL_INTERVAL_PUBLISHER_LIMIT_S,
  MAX_INTERVAL_PUBLISHER_LIMIT_S: () => MAX_INTERVAL_PUBLISHER_LIMIT_S,
  MIN_INTERVAL_S: () => MIN_INTERVAL_S,
  ServerSubscription: () => ServerSubscription,
  ServerSubscriptionConfig: () => ServerSubscriptionConfig
});
module.exports = __toCommonJS(ServerSubscription_exports);
var import_NodeActivity = require("#behavior/context/NodeActivity.js");
var import_OnlineContext = require("#behavior/context/server/OnlineContext.js");
var import_general = require("#general");
var import_model = require("#model");
var import_protocol = require("#protocol");
var import_types = require("#types");
/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
const logger = import_general.Logger.get("ServerSubscription");
const MAX_INTERVAL_PUBLISHER_LIMIT_S = 60 * 60;
const INTERNAL_INTERVAL_PUBLISHER_LIMIT_S = 3 * 60;
const MIN_INTERVAL_S = 2;
const DEFAULT_RANDOMIZATION_WINDOW_S = 10;
var ServerSubscriptionConfig;
((ServerSubscriptionConfig2) => {
  function of(options) {
    return {
      maxIntervalSeconds: options?.maxIntervalSeconds ?? INTERNAL_INTERVAL_PUBLISHER_LIMIT_S,
      minIntervalSeconds: Math.max(options?.minIntervalSeconds ?? MIN_INTERVAL_S, MIN_INTERVAL_S),
      randomizationWindowSeconds: options?.randomizationWindowSeconds ?? DEFAULT_RANDOMIZATION_WINDOW_S
    };
  }
  ServerSubscriptionConfig2.of = of;
})(ServerSubscriptionConfig || (ServerSubscriptionConfig = {}));
class ServerSubscription extends import_protocol.Subscription {
  #context;
  #lastUpdateTimeMs = 0;
  #updateTimer;
  #sendDelayTimer = import_general.Time.getTimer(
    `Subscription ${this.id} delay`,
    50,
    () => this.#triggerSendUpdate()
  );
  #outstandingAttributeUpdates;
  #outstandingEventsMinNumber;
  #changeHandlers = new import_general.ObserverGroup();
  #sendUpdatesActivated = false;
  #seededClusterDetails = /* @__PURE__ */ new Map();
  #latestSeededEventNumber = (0, import_types.EventNumber)(0);
  #sendIntervalMs;
  #minIntervalFloorMs;
  #maxIntervalCeilingMs;
  #peerAddress;
  #sendNextUpdateImmediately = false;
  #sendUpdateErrorCounter = 0;
  #currentUpdatePromise;
  constructor(options) {
    const {
      id,
      context,
      criteria,
      minIntervalFloorSeconds,
      maxIntervalCeilingSeconds,
      subscriptionOptions,
      useAsMaxInterval,
      useAsSendInterval
    } = options;
    super(context.session, id, criteria);
    this.#context = context;
    this.#peerAddress = this.session.peerAddress;
    this.#minIntervalFloorMs = minIntervalFloorSeconds * 1e3;
    this.#maxIntervalCeilingMs = maxIntervalCeilingSeconds * 1e3;
    let maxInterval;
    let sendInterval;
    if (useAsMaxInterval !== void 0 && useAsSendInterval !== void 0) {
      maxInterval = useAsMaxInterval * 1e3;
      sendInterval = useAsSendInterval * 1e3;
    } else {
      ({ maxInterval, sendInterval } = this.#determineSendingIntervals(
        subscriptionOptions.minIntervalSeconds * 1e3,
        subscriptionOptions.maxIntervalSeconds * 1e3,
        subscriptionOptions.randomizationWindowSeconds * 1e3
      ));
    }
    this.maxIntervalMs = maxInterval;
    this.#sendIntervalMs = sendInterval;
    this.#updateTimer = import_general.Time.getTimer(
      `Subscription ${this.id} update`,
      this.#sendIntervalMs,
      () => this.#prepareDataUpdate()
    );
  }
  #determineSendingIntervals(subscriptionMinIntervalMs, subscriptionMaxIntervalMs, subscriptionRandomizationWindowMs) {
    const maxInterval = Math.min(
      Math.max(
        subscriptionMinIntervalMs,
        Math.max(this.#minIntervalFloorMs, Math.min(subscriptionMaxIntervalMs, this.#maxIntervalCeilingMs))
      ) + Math.floor(subscriptionRandomizationWindowMs * Math.random()),
      MAX_INTERVAL_PUBLISHER_LIMIT_S * 1e3
    );
    let sendInterval = Math.floor(maxInterval / 2);
    if (sendInterval < 6e4) {
      sendInterval = Math.max(this.#minIntervalFloorMs, Math.floor(maxInterval * 0.8));
    }
    if (sendInterval < subscriptionMinIntervalMs) {
      logger.warn(
        `Determined subscription send interval of ${sendInterval}ms is too low. Using maxInterval (${maxInterval}ms) instead.`
      );
      sendInterval = subscriptionMinIntervalMs;
    }
    return { maxInterval, sendInterval };
  }
  #addOutstandingAttributes(endpointId, clusterId, changedAttrs) {
    if (!changedAttrs.length) {
      return;
    }
    this.#outstandingAttributeUpdates = this.#outstandingAttributeUpdates ?? {};
    this.#outstandingAttributeUpdates[endpointId] = this.#outstandingAttributeUpdates[endpointId] ?? {};
    this.#outstandingAttributeUpdates[endpointId][clusterId] = this.#outstandingAttributeUpdates[endpointId][clusterId] ?? /* @__PURE__ */ new Set();
    for (const attributeId of changedAttrs) {
      this.#outstandingAttributeUpdates[endpointId][clusterId].add(attributeId);
    }
  }
  #handleClusterStateChanges(endpointId, clusterId, changedAttrs, version) {
    if (this.isClosed || !changedAttrs.length) {
      return;
    }
    if (this.#seededClusterDetails !== void 0) {
      const seededVersion = this.#seededClusterDetails.get(`${endpointId}-${clusterId}`);
      if (seededVersion === void 0 || seededVersion === version) {
        return;
      }
    }
    this.#addOutstandingAttributes(endpointId, clusterId, changedAttrs);
    this.#prepareDataUpdate();
  }
  #handleAddedEvents(occurrence) {
    if (this.isClosed) {
      return;
    }
    if (this.#outstandingEventsMinNumber === void 0 || this.#latestSeededEventNumber !== void 0) {
      this.#outstandingEventsMinNumber = occurrence.number;
    }
    if (this.#sendEventUrgently(occurrence)) {
      this.#prepareDataUpdate();
    }
  }
  #sendEventUrgently({ endpointId, clusterId, eventId }) {
    return (this.criteria.eventRequests ?? []).some(
      ({ endpointId: reqEndpointId, clusterId: reqClusterId, eventId: reqEventId, isUrgent }) => isUrgent && (reqEndpointId === void 0 || reqEndpointId === endpointId) && (reqClusterId === void 0 || reqClusterId === clusterId) && (reqEventId === void 0 || reqEventId === eventId)
    );
  }
  get sendInterval() {
    return Math.ceil(this.#sendIntervalMs / 1e3);
  }
  get minIntervalFloorSeconds() {
    return Math.ceil(this.#minIntervalFloorMs / 1e3);
  }
  get maxIntervalCeilingSeconds() {
    return Math.ceil(this.#maxIntervalCeilingMs / 1e3);
  }
  activate() {
    super.activate();
    if (this.criteria.eventFilters !== void 0) this.criteria.eventFilters.length = 0;
    if (this.criteria.dataVersionFilters !== void 0) this.criteria.dataVersionFilters.length = 0;
    this.#sendUpdatesActivated = true;
    if (this.#outstandingEventsMinNumber !== void 0 && this.#latestSeededEventNumber !== void 0) {
      if (this.#latestSeededEventNumber < this.#outstandingEventsMinNumber) {
        this.#outstandingEventsMinNumber = (0, import_types.EventNumber)(BigInt(this.#latestSeededEventNumber) + BigInt(1));
      } else {
        this.#outstandingEventsMinNumber = void 0;
      }
    }
    this.#latestSeededEventNumber = void 0;
    this.#seededClusterDetails = void 0;
    if (this.#outstandingAttributeUpdates !== void 0 || this.#outstandingEventsMinNumber !== void 0) {
      this.#triggerSendUpdate();
    }
    this.#updateTimer = import_general.Time.getTimer(
      "Subscription update",
      this.#sendIntervalMs,
      () => this.#prepareDataUpdate()
    ).start();
  }
  /**
   * Check if data should be sent straight away or delayed because the minimum interval is not reached. Delay real
   * sending by 50ms in any case to make sure to catch all updates.
   */
  #prepareDataUpdate() {
    if (this.#sendDelayTimer.isRunning || this.isClosed) {
      return;
    }
    if (!this.#sendUpdatesActivated) {
      return;
    }
    this.#updateTimer.stop();
    const now = import_general.Time.nowMs();
    const timeSinceLastUpdateMs = now - this.#lastUpdateTimeMs;
    if (timeSinceLastUpdateMs < this.#minIntervalFloorMs) {
      this.#updateTimer = import_general.Time.getTimer(
        "Subscription update",
        this.#minIntervalFloorMs - timeSinceLastUpdateMs,
        () => this.#prepareDataUpdate()
      ).start();
      return;
    }
    this.#sendDelayTimer.start();
    this.#updateTimer = import_general.Time.getTimer(
      `Subscription update ${this.id}`,
      this.#sendIntervalMs,
      () => this.#prepareDataUpdate()
    ).start();
  }
  #triggerSendUpdate(onlyWithData = false) {
    if (this.#currentUpdatePromise !== void 0) {
      logger.debug("Sending update already in progress, delaying update ...");
      this.#sendNextUpdateImmediately = true;
      return;
    }
    this.#currentUpdatePromise = this.#sendUpdate(onlyWithData).catch((error) => logger.warn("Sending subscription update failed:", error)).finally(() => this.#currentUpdatePromise = void 0);
  }
  /**
   * Determine all attributes that have changed since the last update and send them tout to the subscriber.
   * Important: This method MUST NOT be called directly. Use triggerSendUpdate() instead!
   */
  async #sendUpdate(onlyWithData = false) {
    const attributeFilter = this.#outstandingAttributeUpdates;
    this.#outstandingAttributeUpdates = void 0;
    const eventsMinNumber = this.#outstandingEventsMinNumber;
    this.#outstandingEventsMinNumber = void 0;
    if (onlyWithData && attributeFilter === void 0 && eventsMinNumber === void 0) {
      return;
    }
    this.#lastUpdateTimeMs = import_general.Time.nowMs();
    try {
      if (await this.#sendUpdateMessage(attributeFilter, eventsMinNumber, onlyWithData)) {
        this.#sendUpdateErrorCounter = 0;
      }
    } catch (error) {
      if (this.isClosed) {
        return;
      }
      this.#sendUpdateErrorCounter++;
      logger.info(
        `Error sending subscription update message (error count=${this.#sendUpdateErrorCounter}):`,
        error instanceof import_general.MatterError && error.message || error
      );
      if (this.#sendUpdateErrorCounter <= 2) {
        if (attributeFilter !== void 0) {
          for (const [endpointId, clusters] of Object.entries(attributeFilter)) {
            for (const [clusterId, attributes] of Object.entries(clusters)) {
              this.#addOutstandingAttributes(
                (0, import_types.EndpointNumber)(parseInt(endpointId)),
                (0, import_types.ClusterId)(parseInt(clusterId)),
                Array.from(attributes)
              );
            }
          }
        }
        if (eventsMinNumber !== void 0) {
          this.#outstandingEventsMinNumber = eventsMinNumber;
        }
      } else {
        logger.info(
          `Sending update failed 3 times in a row, canceling subscription ${this.id} and let controller subscribe again.`
        );
        this.#sendNextUpdateImmediately = false;
        if (error instanceof import_general.NoResponseTimeoutError || error instanceof import_general.NetworkError || error instanceof import_protocol.NoChannelError) {
          this.isCanceledByPeer = true;
          await this.destroy();
          return;
        } else {
          throw error;
        }
      }
    }
    if (this.#sendNextUpdateImmediately) {
      logger.debug("Sending delayed update immediately after last one was sent.");
      this.#sendNextUpdateImmediately = false;
      await this.#sendUpdate(true);
    }
  }
  /**
   * Returns an iterator that yields the data reports and events data for the given read request.
   */
  async *#processAttributesAndEventsReport(context, suppressStatusReports = false) {
    const request = {
      ...this.criteria,
      interactionModelRevision: import_model.Specification.INTERACTION_MODEL_REVISION
      // irrelevant here, set to our version
    };
    const delayedStatusReports = new Array();
    let hasValuesInResponse = false;
    let validAttributes = 0;
    let validEvents = 0;
    const session = (0, import_OnlineContext.OnlineContext)(context).beginReadOnly();
    try {
      if (import_protocol.Read.containsAttribute(request)) {
        const attributeReader = new import_protocol.AttributeReadResponse(this.#context.node.protocol, session);
        for (const chunk of attributeReader.process(request)) {
          for (const report of chunk) {
            if (report.kind === "attr-status") {
              if (suppressStatusReports) {
                continue;
              }
              if (!hasValuesInResponse) {
                delayedStatusReports.push(report);
                continue;
              }
            } else if (!hasValuesInResponse && report.kind === "attr-value") {
              for (const delayedReport of delayedStatusReports) {
                yield import_protocol.InteractionServerMessenger.convertServerInteractionReport(delayedReport);
              }
              delayedStatusReports.length = 0;
              hasValuesInResponse = true;
            }
            if (this.#seededClusterDetails !== void 0 && report.kind === "attr-value") {
              const {
                path: { endpointId, clusterId },
                version
              } = report;
              this.#seededClusterDetails.set(`${endpointId}-${clusterId}`, version);
            }
            yield import_protocol.InteractionServerMessenger.convertServerInteractionReport(report);
          }
        }
        validAttributes = attributeReader.counts.existent;
      }
      if (import_protocol.Read.containsEvent(request)) {
        const eventReader = new import_protocol.EventReadResponse(this.#context.node.protocol, session);
        for await (const chunk of eventReader.process(request)) {
          for (const report of chunk) {
            if (report.kind === "event-status") {
              if (suppressStatusReports) {
                continue;
              }
              if (!hasValuesInResponse) {
                delayedStatusReports.push(report);
                continue;
              }
            } else if (!hasValuesInResponse && report.kind === "event-value") {
              for (const delayedReport of delayedStatusReports) {
                yield import_protocol.InteractionServerMessenger.convertServerInteractionReport(delayedReport);
              }
              delayedStatusReports.length = 0;
              hasValuesInResponse = true;
            }
            if (this.#latestSeededEventNumber !== void 0 && report.kind === "event-value") {
              this.#latestSeededEventNumber = report.number;
            }
            yield import_protocol.InteractionServerMessenger.convertServerInteractionReport(report);
          }
        }
        validEvents = eventReader.counts.existent;
      }
      if (validAttributes === 0 && validEvents === 0) {
        throw new import_types.StatusResponseError(
          "Subscription failed because no attributes or events are matching the query",
          import_types.StatusCode.InvalidAction
        );
      } else if (!hasValuesInResponse && delayedStatusReports.length) {
        for (const delayedReport of delayedStatusReports) {
          yield import_protocol.InteractionServerMessenger.convertServerInteractionReport(delayedReport);
        }
      }
    } finally {
      session[Symbol.dispose]();
    }
    this.#lastUpdateTimeMs = import_general.Time.nowMs();
  }
  async sendInitialReport(messenger, readContext, suppressStatusReports) {
    this.#updateTimer.stop();
    if (this.criteria.attributeRequests?.length) {
      this.#changeHandlers.on(
        this.#context.node.protocol.stateChanged,
        this.#handleClusterStateChanges.bind(this)
      );
    }
    if (this.criteria.eventRequests?.length) {
      this.#changeHandlers.on(this.#context.node.protocol.eventHandler.added, this.#handleAddedEvents.bind(this));
    }
    await messenger.sendDataReport({
      baseDataReport: {
        suppressResponse: false,
        // we always need proper response for initial report
        subscriptionId: this.id,
        interactionModelRevision: import_model.Specification.INTERACTION_MODEL_REVISION
      },
      forFabricFilteredRead: this.criteria.isFabricFiltered,
      payload: this.#processAttributesAndEventsReport(readContext, suppressStatusReports)
    });
  }
  async #flush() {
    this.#sendDelayTimer.stop();
    if (this.#outstandingAttributeUpdates !== void 0 || this.#outstandingEventsMinNumber !== void 0) {
      logger.debug(`Flushing subscription ${this.id}${this.isClosed ? " (for closing)" : ""}`);
      this.#triggerSendUpdate(true);
      if (this.#currentUpdatePromise) {
        await this.#currentUpdatePromise;
      }
    }
  }
  async destroy() {
    this.#sendUpdatesActivated = false;
    this.#changeHandlers.close();
    this.#updateTimer.stop();
    this.#sendDelayTimer.stop();
    await super.destroy();
  }
  /**
   * Closes the subscription and flushes all outstanding data updates if requested.
   */
  async close(graceful = false, cancelledByPeer = false) {
    if (this.isClosed) {
      return;
    }
    if (cancelledByPeer) {
      this.isCanceledByPeer = true;
    }
    await this.destroy();
    if (graceful) {
      await this.#flush();
    }
    if (this.#currentUpdatePromise) {
      await this.#currentUpdatePromise;
    }
  }
  /**
   * Iterates over all attributes and events that have changed since the last update and sends them to
   * the controller.
   * A thrown exception will cancel the sending process immediately.
   */
  async *#iterateDataUpdate(exchange, attributeFilter, eventsMinNumber) {
    const request = {
      ...this.criteria,
      interactionModelRevision: import_model.Specification.INTERACTION_MODEL_REVISION
      // irrelevant here, set to our version
    };
    const session = (0, import_OnlineContext.OnlineContext)({
      activity: exchange[import_NodeActivity.NodeActivity.activityKey],
      fabricFiltered: request.isFabricFiltered,
      message: {},
      exchange,
      node: this.#context.node
    }).beginReadOnly();
    try {
      if (attributeFilter !== void 0 && import_protocol.Read.containsAttribute(request)) {
        const attributeReader = new import_protocol.AttributeSubscriptionResponse(
          this.#context.node.protocol,
          session,
          attributeFilter
        );
        for (const chunk of attributeReader.process(request)) {
          for (const report of chunk) {
            yield import_protocol.InteractionServerMessenger.convertServerInteractionReport(report);
          }
        }
      }
      if (eventsMinNumber !== void 0 && import_protocol.Read.containsEvent(request)) {
        request.eventFilters = [{ eventMin: eventsMinNumber }];
        const eventReader = new import_protocol.EventReadResponse(this.#context.node.protocol, session);
        for await (const chunk of eventReader.process(request)) {
          for (const report of chunk) {
            if (report.kind === "event-status") {
              continue;
            }
            yield import_protocol.InteractionServerMessenger.convertServerInteractionReport(report);
          }
        }
      }
    } finally {
      session[Symbol.dispose]();
    }
  }
  async #sendUpdateMessage(attributeFilter, eventsMinNumber, onlyWithData) {
    const exchange = this.#context.initiateExchange(this.#peerAddress, import_types.INTERACTION_PROTOCOL_ID);
    if (exchange === void 0) return false;
    const messenger = new import_protocol.InteractionServerMessenger(exchange);
    try {
      if (attributeFilter === void 0 && eventsMinNumber === void 0) {
        await messenger.sendDataReport({
          baseDataReport: {
            suppressResponse: true,
            // suppressResponse true for empty DataReports
            subscriptionId: this.id,
            interactionModelRevision: import_model.Specification.INTERACTION_MODEL_REVISION
          },
          forFabricFilteredRead: this.criteria.isFabricFiltered,
          waitForAck: !this.isClosed
          // Do not wait for ack when closed
        });
      } else {
        await messenger.sendDataReport({
          baseDataReport: {
            suppressResponse: false,
            // Non-empty data reports always need to send response
            subscriptionId: this.id,
            interactionModelRevision: import_model.Specification.INTERACTION_MODEL_REVISION
          },
          forFabricFilteredRead: this.criteria.isFabricFiltered,
          payload: this.#iterateDataUpdate(exchange, attributeFilter, eventsMinNumber),
          waitForAck: !this.isClosed,
          // Do not wait for ack when closed
          suppressEmptyReport: onlyWithData
        });
      }
    } catch (error) {
      if (import_types.StatusResponseError.is(error, import_types.StatusCode.InvalidSubscription, import_types.StatusCode.Failure)) {
        logger.info(`Subscription ${this.id} cancelled by peer.`);
        this.isCanceledByPeer = true;
        await this.close(false);
      } else {
        import_types.StatusResponseError.accept(error);
        logger.info(`Subscription ${this.id} update failed:`, error);
        await this.close(false);
      }
    } finally {
      await messenger.close();
    }
    return true;
  }
}
//# sourceMappingURL=ServerSubscription.js.map
