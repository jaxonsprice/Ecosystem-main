"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var ClientBehavior_exports = {};
__export(ClientBehavior_exports, {
  ClientBehavior: () => ClientBehavior
});
module.exports = __toCommonJS(ClientBehavior_exports);
var import_ClusterBehavior = require("#behavior/cluster/ClusterBehavior.js");
var import_general = require("#general");
var import_model = require("#model");
var import_Node = require("#node/Node.js");
var import_protocol = require("#protocol");
var import_types = require("#types");
/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
const BIT_BLOCK_SIZE = Math.log2(Number.MAX_SAFE_INTEGER);
const cache = {};
function ClientBehavior(shape) {
  const analysis = ShapeAnalysis(shape);
  const fingerprint = createFingerprint(analysis);
  let type = cache[fingerprint];
  if (type) {
    return type;
  }
  let baseType;
  const standardCluster = import_types.ClusterRegistry.get(shape.id);
  if (standardCluster) {
    baseType = import_ClusterBehavior.ClusterBehavior.for(standardCluster);
  } else {
    baseType = import_ClusterBehavior.ClusterBehavior;
  }
  type = cache[fingerprint] = generateType(analysis, baseType);
  return type;
}
function generateType(analysis, baseType) {
  if (!import_ClusterBehavior.ClusterBehavior.is(baseType)) {
    throw new import_general.InternalError(`Base Behavior for cluster ${analysis.schema.name} is not a ClusterBehavior`);
  }
  let { schema } = analysis;
  const { extraAttrs, extraCommands } = analysis;
  let { cluster } = baseType;
  if (!cluster) {
    cluster = (0, import_types.MutableCluster)({ id: schema.id, name: schema.name, revision: schema.revision });
  }
  let supportedFeatures = analysis.shape.features;
  if (typeof supportedFeatures === "number") {
    if (supportedFeatures) {
      supportedFeatures = cluster.attributes.featureMap.schema.decode(supportedFeatures);
    } else {
      supportedFeatures = {};
    }
  }
  const featureNames = Object.entries(supportedFeatures).filter(([, v]) => v).map(([k]) => k);
  if (featureNames.length) {
    schema = schema.clone();
    schema.supportedFeatures = featureNames;
    cluster = new import_types.ClusterComposer(cluster, true).compose(featureNames.map(import_general.capitalize));
  }
  if (schema.revision !== analysis.shape.revision || extraAttrs.size || extraCommands.size) {
    schema = schema.clone();
    cluster = {
      ...cluster,
      supportedFeatures,
      attributes: { ...cluster.attributes },
      commands: { ...cluster.commands }
    };
    schema.supportedFeatures = supportedFeatures;
    for (const id of extraAttrs) {
      const name = createUnknownName("attr", id);
      cluster.attributes[(0, import_general.camelize)(name, false)] = (0, import_types.Attribute)(id, import_types.TlvAny);
      schema.children.push(new import_model.AttributeModel({ id, name, type: "any" }));
    }
    for (const id of extraCommands) {
      const name = createUnknownName("command", id);
      cluster.commands[(0, import_general.camelize)(name, false)] = (0, import_types.Command)(id, import_types.TlvAny, 0, import_types.TlvNoResponse);
      schema.children.push(new import_model.CommandModel({ id, name, type: "any" }));
    }
  }
  const type = baseType.for(cluster, schema, `${schema.name}Client`);
  for (const id of analysis.shape.commands) {
    const name = schema.get(import_model.CommandModel, id)?.name ?? createUnknownName("command", id);
    const command = cluster.commands[(0, import_general.camelize)(name)];
    type.prototype[(0, import_general.camelize)(name, false)] = implementCommand(command);
  }
  return type;
  function implementCommand(command) {
    return async function(fields) {
      const node = this.env.get(import_Node.Node);
      const chunks = node.interaction.invoke(
        (0, import_protocol.Invoke)(
          import_protocol.Invoke.Command({
            endpoint: this.endpoint,
            cluster,
            command,
            fields
          })
        )
      );
      for await (const chunk of chunks) {
        for (const entry of chunk) {
          switch (entry.kind) {
            case "cmd-status":
              if (entry.status !== import_types.Status.Success) {
                throw import_types.StatusResponseError.create(entry.status, void 0, entry.clusterStatus);
              }
              break;
            case "cmd-response":
              return command.responseSchema.decodeTlv(entry.data);
          }
        }
      }
    };
  }
}
function createFingerprint(analysis) {
  const fingerprint = [analysis.shape.id];
  if (analysis.extraAttrs.size) {
    fingerprint.push("a", createElementFingerprint(analysis.extraAttrs));
  }
  if (analysis.extraCommands.size) {
    fingerprint.push("c", createElementFingerprint(analysis.extraCommands));
  }
  return fingerprint.join(";");
  function createElementFingerprint(ids) {
    const blocks = {};
    for (const id of ids) {
      const block = Math.floor(id / BIT_BLOCK_SIZE);
      blocks[block] = (blocks[block] ?? 0) | 1 << id % BIT_BLOCK_SIZE;
    }
    return Object.entries(blocks).sort(([a], [b]) => a.localeCompare(b)).map(([block, map]) => block ? `${block}:${map}` : map).join(",");
  }
}
function createUnknownName(prefix, id) {
  return `${prefix}$${id.toString(16)}`;
}
function ShapeAnalysis(shape) {
  const schema = import_model.Matter.get(import_model.ClusterModel, shape.id) ?? new import_model.ClusterModel({ id: shape.id, name: createUnknownName("Cluster", shape.id), revision: shape.revision });
  const extraAttrs = new Set(shape.attributes);
  for (const attr of schema.attributes) {
    extraAttrs.delete(attr.id);
  }
  const extraCommands = new Set(shape.commands);
  for (const command of schema.commands) {
    extraCommands.delete(command.id);
  }
  return {
    schema,
    shape,
    extraAttrs,
    extraCommands
  };
}
//# sourceMappingURL=ClientBehavior.js.map
