"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var ClientStructure_exports = {};
__export(ClientStructure_exports, {
  ClientStructure: () => ClientStructure
});
module.exports = __toCommonJS(ClientStructure_exports);
var import_Datasource = require("#behavior/state/managed/Datasource.js");
var import_descriptor = require("#clusters/descriptor");
var import_Endpoint = require("#endpoint/Endpoint.js");
var import_EndpointType = require("#endpoint/type/EndpointType.js");
var import_model = require("#model");
var import_protocol = require("#protocol");
var import_DatasourceCache = require("#storage/client/DatasourceCache.js");
var import_storage = require("#storage/index.js");
var import_ClientBehavior = require("./ClientBehavior.js");
/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
const DEVICE_TYPE_LIST_ATTR_ID = import_descriptor.DescriptorCluster.attributes.deviceTypeList.id;
const SERVER_LIST_ATTR_ID = import_descriptor.DescriptorCluster.attributes.serverList.id;
const PARTS_LIST_ATTR_ID = import_descriptor.DescriptorCluster.attributes.partsList.id;
class ClientStructure {
  #nodeStore;
  #endpoints = {};
  constructor(node) {
    this.#nodeStore = node.env.get(import_storage.ClientNodeStore);
    this.#endpoints[node.number] = {
      endpoint: node,
      clusters: {}
    };
  }
  /**
   * Load initial structure from cache.
   */
  loadCache() {
    for (const store of this.#nodeStore.endpointStores) {
      const id = store.id;
      const number = Number.parseInt(id);
      if (Number.isNaN(number)) {
        continue;
      }
      const endpoint = this.#endpointFor(number);
      for (const idStr of store.knownBehaviors) {
        const id2 = Number.parseInt(idStr);
        if (Number.isNaN(id2)) {
          continue;
        }
        const cluster = this.#clusterFor(endpoint, id2);
        this.#initializeCluster(endpoint, cluster);
      }
    }
  }
  /**
   * Obtain the store for a remote cluster.
   */
  storeForRemote(endpoint, type) {
    const endpointStructure = this.#endpointFor(endpoint.number);
    const clusterStructure = this.#clusterFor(endpointStructure, type.cluster.id);
    return clusterStructure.store;
  }
  /**
   *
   * @param request
   * @returns
   */
  storeForLocal(endpoint, type) {
    return this.#nodeStore.storeForEndpoint(endpoint).createStoreForLocalBehavior(type.id);
  }
  /**
   * Inject version filters into a Read or Subscribe request.
   */
  injectVersionFilters(request) {
    const scope = (0, import_protocol.ReadScope)(request);
    let result = request;
    for (const {
      endpoint: { number: endpointId },
      clusters
    } of Object.values(this.#endpoints)) {
      for (const {
        id: clusterId,
        store: { version }
      } of Object.values(clusters)) {
        if (!scope.isRelevant(endpointId, clusterId)) {
          continue;
        }
        if (version === import_Datasource.Datasource.UNKNOWN_VERSION) {
          continue;
        }
        if (result === request) {
          result = { ...request };
        }
        if (result.dataVersionFilters === void 0) {
          result.dataVersionFilters = [];
        }
        result.dataVersionFilters.push({ path: { endpointId, clusterId }, dataVersion: version });
      }
    }
    return result;
  }
  /**
   * Update the node structure by applying attribute changes.
   */
  async *mutate(request, changes) {
    const scope = (0, import_protocol.ReadScope)(request);
    let currentUpdates;
    for await (const chunk of changes) {
      for (const change of chunk) {
        if (change.kind !== "attr-value") {
          continue;
        }
        const { endpointId, clusterId, attributeId } = change.path;
        if (currentUpdates && (currentUpdates.endpointId !== endpointId || currentUpdates.clusterId !== clusterId)) {
          await this.#updateCluster(currentUpdates);
          currentUpdates = void 0;
        }
        if (currentUpdates === void 0) {
          currentUpdates = {
            endpointId,
            clusterId,
            values: {
              [attributeId]: change.value
            }
          };
          if (scope.isWildcard(endpointId, clusterId)) {
            currentUpdates.values[import_DatasourceCache.DatasourceCache.VERSION_KEY] = change.version;
          }
        } else {
          currentUpdates.values[attributeId] = change.value;
        }
      }
      yield chunk;
    }
    if (currentUpdates) {
      await this.#updateCluster(currentUpdates);
    }
  }
  /**
   * Obtain the {@link ClusterType} for an endpoint number and cluster ID.
   */
  clusterFor(endpoint, cluster) {
    const ep = this.#endpointFor(endpoint);
    if (!ep) {
      return;
    }
    return this.#clusterFor(ep, cluster)?.behavior?.cluster;
  }
  /**
   * Apply new attribute values for specific endpoint/cluster.
   *
   * This is invoked in a batch when we've collected all sequential values for the current endpoint/cluster.
   */
  async #updateCluster(attrs) {
    const endpoint = this.#endpointFor(attrs.endpointId);
    const cluster = this.#clusterFor(endpoint, attrs.clusterId);
    await cluster.store.externalSet(attrs.values);
    this.#initializeCluster(endpoint, cluster);
  }
  /**
   * If enough attributes are present, installs a behavior on an endpoint
   *
   * If the cluster is Descriptor, performs additional {@link Endpoint} configuration such as installing parts and
   * device types.
   *
   * Invoked once we've loaded all attributes in an interaction.
   */
  #initializeCluster(endpoint, cluster) {
    const attrs = cluster.store.initialValues ?? {};
    if (cluster.behavior === void 0) {
      const {
        [import_model.ClusterRevision.id]: clusterRevision,
        [import_model.FeatureMap.id]: features,
        [import_model.AttributeList.id]: attributeList,
        [import_model.AcceptedCommandList.id]: commandList
      } = attrs;
      if (typeof clusterRevision === "number") {
        cluster.revision = clusterRevision;
      }
      if (typeof features === "object" && features !== null && !Array.isArray(features)) {
        cluster.features = features;
      }
      if (Array.isArray(attributeList)) {
        cluster.attributes = attributeList.filter((attr) => typeof attr === "number");
      }
      if (Array.isArray(commandList)) {
        cluster.commands = commandList.filter((cmd) => typeof cmd === "number");
      }
      if (cluster.revision !== void 0 && cluster.features !== void 0 && cluster.attributes !== void 0 && cluster.commands !== void 0) {
        cluster.behavior = (0, import_ClientBehavior.ClientBehavior)(cluster);
        endpoint.endpoint.behaviors.require(cluster.behavior);
      }
    }
    if (cluster.id === import_descriptor.DescriptorCluster.id) {
      this.#synchronizeDescriptor(endpoint, attrs);
    }
  }
  #synchronizeDescriptor(endpoint, attrs) {
    const deviceTypeList = attrs[DEVICE_TYPE_LIST_ATTR_ID];
    if (Array.isArray(deviceTypeList) && deviceTypeList?.[0]) {
      const [{ deviceType, revision }] = deviceTypeList;
      if (typeof deviceType === "number") {
        endpoint.endpoint.type.deviceType = deviceType;
      }
      if (typeof revision === "number") {
        endpoint.endpoint.type.deviceRevision = revision;
      }
    }
    const serverList = attrs[SERVER_LIST_ATTR_ID];
    if (Array.isArray(serverList)) {
      for (const cluster of serverList) {
        if (typeof cluster === "number") {
          this.#clusterFor(endpoint, cluster);
        }
      }
    }
    const partsList = attrs[PARTS_LIST_ATTR_ID];
    if (Array.isArray(partsList)) {
      for (const partNo of partsList) {
        if (typeof partNo !== "number") {
          continue;
        }
        const part = this.#endpointFor(partNo);
        let isAlreadyDescendant = false;
        for (let owner = part.endpoint.owner; owner; owner = owner.owner) {
          if (owner === endpoint.endpoint) {
            isAlreadyDescendant = true;
            break;
          }
        }
        if (isAlreadyDescendant) {
          continue;
        }
        part.endpoint.owner = endpoint.endpoint;
      }
    }
  }
  #endpointFor(number) {
    let endpoint = this.#endpoints[number];
    if (endpoint) {
      return endpoint;
    }
    endpoint = {
      endpoint: new import_Endpoint.Endpoint({
        id: `ep${number}`,
        number,
        type: (0, import_EndpointType.EndpointType)({
          name: "ClientEndpoint",
          deviceType: -1,
          deviceRevision: -1
        })
      }),
      clusters: {}
    };
    this.#endpoints[number] = endpoint;
    return endpoint;
  }
  #clusterFor(endpoint, id) {
    let cluster = endpoint.clusters[id];
    if (cluster) {
      return cluster;
    }
    cluster = {
      id,
      store: this.#nodeStore.storeForEndpoint(endpoint.endpoint).createStoreForBehavior(id.toString())
    };
    endpoint.clusters[id] = cluster;
    return cluster;
  }
}
//# sourceMappingURL=ClientStructure.js.map
