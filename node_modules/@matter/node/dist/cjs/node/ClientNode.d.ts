/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { ActionContext } from "#behavior/context/ActionContext.js";
import { CommissioningClient } from "#behavior/system/commissioning/CommissioningClient.js";
import { NetworkClient } from "#behavior/system/network/NetworkClient.js";
import { NetworkRuntime } from "#behavior/system/network/NetworkRuntime.js";
import { Agent } from "#endpoint/Agent.js";
import { Identity, MaybePromise } from "#general";
import { Interactable } from "#protocol";
import { MatterModel } from "@matter/model";
import { Node } from "./Node.js";
import type { ServerNode } from "./ServerNode.js";
/**
 * A remote Matter {@link Node}.
 *
 * Client nodes may be peers (commissioned into a shared fabric) or commissionable, in which they are not usable until
 * you invoke {@link commissioned}.
 */
export declare class ClientNode extends Node<ClientNode.RootEndpoint> {
    #private;
    constructor(options: ClientNode.Options);
    /**
     * Model of Matter semantics understood by this node.
     *
     * Matter elements missing from this model will not support all functionality.
     */
    get matter(): MatterModel;
    initialize(): MaybePromise;
    get owner(): ServerNode | undefined;
    set owner(owner: ServerNode);
    /**
     * Add this node to a fabric.
     */
    commission(options: CommissioningClient.CommissioningOptions): Promise<void>;
    /**
     * Remove this node from the fabric (if commissioned) and locally.
     */
    delete(): Promise<void>;
    /**
     * Force-remove the node without first decommissioning.
     *
     * If the node is still available you should use {@link delete} to remove it from the fabric.
     */
    erase(): Promise<void>;
    protected eraseWithMutex(): Promise<void>;
    protected createRuntime(): NetworkRuntime;
    prepareRuntimeShutdown(): Promise<void>;
    protected get container(): import("./index.js").ClientNodes | undefined;
    act<R>(purpose: string, actor: (agent: Agent.Instance<ClientNode.RootEndpoint>) => MaybePromise<R>): MaybePromise<R>;
    act<R>(actor: (agent: Agent.Instance<ClientNode.RootEndpoint>) => MaybePromise<R>): MaybePromise<R>;
    get interaction(): Interactable<ActionContext>;
}
export declare namespace ClientNode {
    interface Options extends Node.Options<RootEndpoint> {
        matter?: MatterModel;
    }
    const RootEndpoint: import("../index.js").MutableEndpoint.With<import("../index.js").EndpointType.For<{
        readonly name: "RootNode";
        readonly deviceType: import("@matter/types").DeviceTypeId;
        readonly deviceRevision: number;
        readonly deviceClass: import("@matter/model").DeviceClassification;
        readonly requirements: typeof import("../endpoints/root.js").RootRequirements;
        readonly behaviors: {
            readonly parts: typeof import("../index.js").PartsBehavior;
            readonly index: typeof import("../index.js").IndexBehavior;
        };
    }>, import("../index.js").SupportedBehaviors.With<{
        readonly parts: typeof import("../index.js").PartsBehavior;
        readonly index: typeof import("../index.js").IndexBehavior;
    }, readonly [typeof CommissioningClient, typeof NetworkClient]>>;
    interface RootEndpoint extends Identity<typeof RootEndpoint> {
    }
}
//# sourceMappingURL=ClientNode.d.ts.map