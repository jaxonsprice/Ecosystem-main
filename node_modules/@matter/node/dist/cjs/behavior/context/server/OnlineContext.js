"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var OnlineContext_exports = {};
__export(OnlineContext_exports, {
  OnlineContext: () => OnlineContext
});
module.exports = __toCommonJS(OnlineContext_exports);
var import_general = require("#general");
var import_protocol = require("#protocol");
var import_Contextual = require("../Contextual.js");
var import_ContextAgents = require("./ContextAgents.js");
/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
const exchangeCompleteEvents = /* @__PURE__ */ new WeakMap();
function OnlineContext(options) {
  let fabric;
  let subject;
  let nodeProtocol;
  let accessLevelCache;
  let aclManager;
  const { exchange, message } = options;
  const session = exchange?.session;
  if (session) {
    import_protocol.SecureSession.assert(session);
    fabric = session.fabric?.fabricIndex;
    subject = session.subjectFor(message);
    aclManager = session?.fabric?.acl ?? new import_protocol.FabricAccessControl();
  } else {
    fabric = options.fabric;
    if (options.subject !== void 0) {
      subject = import_protocol.Subject.Node({ id: options.subject });
    } else {
      throw new import_general.ImplementationError("OnlineContext requires an authorized subject");
    }
    aclManager = options.aclManager ?? new import_protocol.FabricAccessControl();
  }
  const via = import_general.Diagnostic.via(
    `online#${message?.packetHeader?.messageId?.toString(16) ?? "?"}@${subject.id.toString(16)}`
  );
  return {
    /**
     * Run an actor with a read/write context.
     *
     * If the actor changes state, this may return a promise even if {@link actor} does not return a promise.
     */
    act(actor) {
      const context = this.open();
      let result;
      try {
        result = actor(context);
      } catch (e) {
        return context.reject(e);
      }
      return context.resolve(result);
    },
    /**
     * Create an online context.
     *
     * This context operates with a {@link Transaction} created via {@link Transaction.open} and the same rules
     * apply for lifecycle management using {@link Transaction.Finalization}.
     */
    open() {
      let close;
      let tx;
      try {
        close = initialize();
        tx = import_general.Transaction.open(via);
        tx.onClose(close);
      } catch (e) {
        close?.();
        throw e;
      }
      return createContext(tx, {
        resolve: tx.resolve.bind(tx),
        reject: tx.reject.bind(tx)
      });
    },
    /**
     * Begin an operation with a read-only context.
     *
     * A read-only context offers simpler lifecycle semantics than a r/w OnlineContext but you must still close the
     * context after use to properly deregister activity.
     */
    beginReadOnly() {
      const close = initialize();
      return createContext(import_general.Transaction.open(via, "snapshot"), {
        [Symbol.dispose]: close
      });
    },
    [Symbol.toStringTag]: "OnlineContext"
  };
  function initialize() {
    const activity = options.activity?.frame(via);
    const close = () => {
      if (message) {
        import_Contextual.Contextual.setContextOf(message, void 0);
      }
      if (activity) {
        activity[Symbol.dispose]();
      }
    };
    return close;
  }
  function createContext(transaction, methods) {
    if (session) {
      import_protocol.SecureSession.assert(session);
    }
    let agents;
    let interactionComplete;
    if (exchange !== void 0) {
      interactionComplete = exchangeCompleteEvents.get(exchange);
      if (interactionComplete === void 0) {
        interactionComplete = new import_general.AsyncObservable();
        exchangeCompleteEvents.set(exchange, interactionComplete);
      }
      const notifyInteractionComplete = () => {
        exchange.closing.off(notifyInteractionComplete);
        exchangeCompleteEvents.delete(exchange);
        if (context.interactionComplete?.isObserved) {
          context.interactionComplete.emit(context);
        }
      };
      exchange.closing.on(notifyInteractionComplete);
    }
    const context = {
      ...options,
      session,
      exchange,
      subject,
      fabric,
      transaction,
      interactionComplete,
      ...methods,
      // TODO - Matter 1.4 - add support for ARLs
      authorityAt(desiredAccessLevel, location) {
        if (location === void 0) {
          throw new import_general.InternalError("AccessControl.Location is required");
        }
        const cachedAccessLevels = accessLevelCache?.get(location);
        if (cachedAccessLevels !== void 0) {
          return cachedAccessLevels.includes(desiredAccessLevel) ? import_protocol.AccessControl.Authority.Granted : import_protocol.AccessControl.Authority.Unauthorized;
        }
        if (options.node === void 0) {
          throw new import_general.InternalError("OnlineContext initialized without node");
        }
        const accessLevels = aclManager.accessLevelsFor(context, location, aclEndpointContextFor(location));
        if (accessLevelCache === void 0) {
          accessLevelCache = /* @__PURE__ */ new Map();
        }
        accessLevelCache.set(location, accessLevels);
        return accessLevels.includes(desiredAccessLevel) ? import_protocol.AccessControl.Authority.Granted : import_protocol.AccessControl.Authority.Unauthorized;
      },
      agentFor(endpoint) {
        if (!agents) {
          agents = (0, import_ContextAgents.ContextAgents)(context);
        }
        return agents.agentFor(endpoint);
      },
      get [import_Contextual.Contextual.context]() {
        return this;
      }
    };
    if (message) {
      import_Contextual.Contextual.setContextOf(message, context);
    }
    return context;
  }
  function aclEndpointContextFor({ endpoint: number }) {
    if (number === void 0) {
      throw new import_general.InternalError("Online location missing required endpoint number");
    }
    if (options.node === void 0) {
      throw new import_general.InternalError("Online context has no node defined");
    }
    if (nodeProtocol === void 0) {
      nodeProtocol = options.node.protocol;
    }
    const endpoint = nodeProtocol[number];
    if (endpoint !== void 0) {
      return endpoint;
    }
    return {
      id: number,
      deviceTypes: []
    };
  }
}
//# sourceMappingURL=OnlineContext.js.map
