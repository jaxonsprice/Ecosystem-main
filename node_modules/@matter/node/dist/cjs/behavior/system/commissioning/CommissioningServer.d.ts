/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import { Endpoint } from "#endpoint/Endpoint.js";
import { AsyncObservable, EventEmitter, Mutex, Observable } from "#general";
import { DatatypeModel } from "#model";
import { ExposedFabricInformation, FabricAction, Val } from "#protocol";
import { CommissioningFlowType, FabricIndex } from "#types";
import { Behavior } from "../../Behavior.js";
import { ActionContext } from "../../context/ActionContext.js";
/**
 * Server behavior related to commissioning.
 *
 * Updates node state based on commissioning status.
 */
export declare class CommissioningServer extends Behavior {
    #private;
    static readonly id = "commissioning";
    state: CommissioningServer.State;
    events: CommissioningServer.Events;
    internal: CommissioningServer.Internal;
    static early: boolean;
    initialize(): void;
    [Symbol.asyncDispose](): Promise<void>;
    handleFabricChange(fabricIndex: FabricIndex, fabricAction: FabricAction): void;
    /**
     * An uncommissioned node is not yet associated with fabrics.  It cannot be used until commissioned by a controller.
     *
     * The server normally invokes this method when the node starts and is not yet commissioned.  You can disable by
     * setting {@link CommissioningServer.State#enabled} to false.  Then you must invoke yourself.
     */
    enterCommissionableMode(): void;
    /**
     * The server invokes this method when the node starts and is already commissioned, or immediately after
     * commissioning.
     */
    protected enterOperationalMode(): void;
    /**
     * Display instructions on commissioning the device.
     *
     * The default implementation logs the QR code and credentials.
     */
    protected initiateCommissioning(): void;
    /**
     * Obtain pairing codes for a node.
     */
    static pairingCodesFor(node: Endpoint): {
        manualPairingCode: string;
        qrPairingCode: string;
    };
    /**
     * Define logical schema to make passcode and discriminator persistent.
     */
    static readonly schema: DatatypeModel;
    /**
     * Advertise and continue advertising at regular intervals until timeout per Matter specification.  If already
     * advertising, the advertisement timeout resets.
     */
    beginAdvertising(): void;
}
export declare namespace CommissioningServer {
    interface PairingCodes {
        manualPairingCode: string;
        qrPairingCode: string;
    }
    class Internal {
        unregisterFailsafeListener?: () => void;
        /**
         * We use this to synchronize internal state transitions that would otherwise have race conditions due to the
         * large number of asynchronous calls.
         */
        mutex: Mutex;
        /**
         * Passed to the mutex for error handling purposes
         */
        name: string;
    }
    class State {
        enabled?: boolean;
        commissioned: boolean;
        fabrics: Record<FabricIndex, ExposedFabricInformation>;
        passcode: number;
        discriminator: number;
        flowType: CommissioningFlowType;
        additionalBleAdvertisementData?: Uint8Array;
        pairingCodes: PairingCodes;
        [Val.properties](endpoint: Endpoint): {
            readonly pairingCodes: {
                manualPairingCode: string;
                qrPairingCode: string;
            };
            readonly fabrics: Record<FabricIndex, ExposedFabricInformation>;
        };
    }
    class Events extends EventEmitter {
        commissioned: Observable<[context: ActionContext], void>;
        decommissioned: Observable<[context: ActionContext], void>;
        fabricsChanged: Observable<[fabricIndex: FabricIndex, action: FabricAction], void>;
        enabled$Changed: AsyncObservable<[context: ActionContext], void>;
    }
}
//# sourceMappingURL=CommissioningServer.d.ts.map