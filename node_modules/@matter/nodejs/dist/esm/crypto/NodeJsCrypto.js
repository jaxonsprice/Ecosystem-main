/**
 * @license
 * Copyright 2022-2025 Matter.js Authors
 * SPDX-License-Identifier: Apache-2.0
 */
import {
  Bytes,
  CRYPTO_AUTH_TAG_LENGTH,
  CRYPTO_EC_CURVE,
  CRYPTO_EC_KEY_BYTES,
  CRYPTO_ENCRYPT_ALGORITHM,
  CRYPTO_HASH_ALGORITHM,
  CRYPTO_SYMMETRIC_KEY_LENGTH,
  Crypto,
  CryptoDecryptError,
  CryptoVerifyError,
  PrivateKey,
  asError
} from "#general";
import * as crypto from "node:crypto";
class NodeJsCrypto extends Crypto {
  implementationName = "Node.js";
  encrypt(key, data, nonce, aad) {
    const cipher = crypto.createCipheriv(CRYPTO_ENCRYPT_ALGORITHM, key, nonce, {
      authTagLength: CRYPTO_AUTH_TAG_LENGTH
    });
    if (aad !== void 0) {
      cipher.setAAD(aad, { plaintextLength: data.length });
    }
    const encrypted = cipher.update(data);
    cipher.final();
    return Bytes.concat(encrypted, cipher.getAuthTag());
  }
  decrypt(key, data, nonce, aad) {
    const cipher = crypto.createDecipheriv(CRYPTO_ENCRYPT_ALGORITHM, key, nonce, {
      authTagLength: CRYPTO_AUTH_TAG_LENGTH
    });
    const plaintextLength = data.length - CRYPTO_AUTH_TAG_LENGTH;
    if (aad !== void 0) {
      cipher.setAAD(aad, { plaintextLength });
    }
    cipher.setAuthTag(data.slice(plaintextLength));
    const result = cipher.update(data.slice(0, plaintextLength));
    try {
      cipher.final();
    } catch (e) {
      throw new CryptoDecryptError(`${CRYPTO_ENCRYPT_ALGORITHM} decryption failed: ${asError(e).message}`);
    }
    return new Uint8Array(result);
  }
  randomBytes(length) {
    return new Uint8Array(crypto.randomBytes(length));
  }
  ecdhGeneratePublicKey() {
    const ecdh = crypto.createECDH(CRYPTO_EC_CURVE);
    ecdh.generateKeys();
    return { publicKey: new Uint8Array(ecdh.getPublicKey()), ecdh };
  }
  ecdhGeneratePublicKeyAndSecret(peerPublicKey) {
    const ecdh = crypto.createECDH(CRYPTO_EC_CURVE);
    ecdh.generateKeys();
    return {
      publicKey: new Uint8Array(ecdh.getPublicKey()),
      sharedSecret: new Uint8Array(ecdh.computeSecret(peerPublicKey))
    };
  }
  computeSha256(data) {
    const hasher = crypto.createHash(CRYPTO_HASH_ALGORITHM);
    if (Array.isArray(data)) {
      data.forEach((chunk) => hasher.update(chunk));
    } else {
      hasher.update(data);
    }
    return new Uint8Array(hasher.digest());
  }
  createPbkdf2Key(secret, salt, iteration, keyLength) {
    return new Promise((resolver, rejecter) => {
      crypto.pbkdf2(secret, salt, iteration, keyLength, CRYPTO_HASH_ALGORITHM, (error, key) => {
        if (error !== null) rejecter(error);
        resolver(new Uint8Array(key));
      });
    });
  }
  createHkdfKey(secret, salt, info, length = CRYPTO_SYMMETRIC_KEY_LENGTH) {
    return new Promise((resolver, rejecter) => {
      crypto.hkdf(CRYPTO_HASH_ALGORITHM, secret, salt, info, length, (error, key) => {
        if (error !== null) rejecter(error);
        resolver(new Uint8Array(key));
      });
    });
  }
  signHmac(key, data) {
    const hmac = crypto.createHmac(CRYPTO_HASH_ALGORITHM, key);
    hmac.update(data);
    return new Uint8Array(hmac.digest());
  }
  signEcdsa(privateKey, data, dsaEncoding = "ieee-p1363") {
    const signer = crypto.createSign(CRYPTO_HASH_ALGORITHM);
    if (Array.isArray(data)) {
      data.forEach((chunk) => signer.update(chunk));
    } else {
      signer.update(data);
    }
    return new Uint8Array(
      signer.sign({
        key: privateKey,
        format: "jwk",
        type: "pkcs8",
        dsaEncoding
      })
    );
  }
  verifyEcdsa(publicKey, data, signature, dsaEncoding = "ieee-p1363") {
    const verifier = crypto.createVerify(CRYPTO_HASH_ALGORITHM);
    verifier.update(data);
    const success = verifier.verify(
      {
        key: publicKey,
        format: "jwk",
        type: "spki",
        dsaEncoding
      },
      signature
    );
    if (!success) throw new CryptoVerifyError("Signature verification failed");
  }
  createKeyPair() {
    const ecdh = crypto.createECDH(CRYPTO_EC_CURVE);
    ecdh.generateKeys();
    const privateKey = new Uint8Array(CRYPTO_EC_KEY_BYTES);
    const nodePrivateKey = ecdh.getPrivateKey();
    privateKey.set(nodePrivateKey, CRYPTO_EC_KEY_BYTES - nodePrivateKey.length);
    return PrivateKey(privateKey, { publicKey: ecdh.getPublicKey() });
  }
  generateDhSecret(key, peerKey) {
    const ecdh = crypto.createECDH(CRYPTO_EC_CURVE);
    ecdh.setPrivateKey(key.privateBits);
    return ecdh.computeSecret(peerKey.publicBits);
  }
}
export {
  NodeJsCrypto
};
//# sourceMappingURL=NodeJsCrypto.js.map
